<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-21 Thu 17:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algoritmi</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Algoritmi</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgac5493e">Ordinamento</a></li>
<li><a href="#orgddb46b1">Alberi</a></li>
<li><a href="#org9d4fd8b">Heap e code con priorità</a></li>
<li><a href="#orge78101e">Analisi ammortizzata</a></li>
<li><a href="#orgac4ade6">Union-Find</a></li>
<li><a href="#org178c95a">Grafi</a></li>
<li><a href="#orgc905642">Alberi ricoprenti minimi</a>
<ul>
<li><a href="#org35c2729">Kruskal</a></li>
<li><a href="#orgfe8d082"><span class="todo TODO">TODO</span> Aggiungere lezione precedente</a></li>
<li><a href="#orgafc467a">AlgoritmoDiPrim</a></li>
</ul>
</li>
<li><a href="#orga490adf">Programmazione dinamica</a>
<ul>
<li><a href="#orgf1c06b5">Distanza fra stringhe</a></li>
<li><a href="#org791a6d8">diff con divide et impera</a>
<ul>
<li><a href="#org9b091e8">Principio di ottimalità</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2607ddf">Cammini minimi</a>
<ul>
<li><a href="#orgc584eea">Rappresentazioni</a></li>
<li><a href="#orgb2ccc7b">Problemi sui cammini minimi</a></li>
<li><a href="#orgf232acb">Floyd-Marshall</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgac5493e" class="outline-2">
<h2 id="orgac5493e"><a href="ordinamento.html#ID-b3612a70-1431-4665-9189-87a36fe5ab15">Ordinamento</a></h2>
</div>
<div id="outline-container-orgddb46b1" class="outline-2">
<h2 id="orgddb46b1">Alberi</h2>
</div>
<div id="outline-container-org9d4fd8b" class="outline-2">
<h2 id="org9d4fd8b">Heap e code con priorità</h2>
</div>
<div id="outline-container-orge78101e" class="outline-2">
<h2 id="orge78101e">Analisi ammortizzata</h2>
</div>
<div id="outline-container-orgac4ade6" class="outline-2">
<h2 id="orgac4ade6">Union-Find</h2>
</div>
<div id="outline-container-org178c95a" class="outline-2">
<h2 id="org178c95a">Grafi</h2>
</div>
<div id="outline-container-orgc905642" class="outline-2">
<h2 id="orgc905642">Alberi ricoprenti minimi</h2>
<div class="outline-text-2" id="text-orgc905642">
<p>
Strategie greedy differenti
</p>
<ul class="org-ul">
<li>Kruskal
<ul class="org-ul">
<li>Soluzione parziale: foresta di alberi con insieme di vertici V</li>
<li>Inizialmente: tutti i vertici, nessun arco</li>
</ul></li>
<li>Prim</li>
</ul>
</div>

<div id="outline-container-org35c2729" class="outline-3">
<h3 id="org35c2729"><a href="kruskal.html#ID-ae91152d-739d-45f7-8db0-24ca2706ae92">Kruskal</a></h3>
</div>
<div id="outline-container-orgfe8d082" class="outline-3">
<h3 id="orgfe8d082"><span class="todo TODO">TODO</span> Aggiungere lezione precedente</h3>
</div>
<div id="outline-container-orgafc467a" class="outline-3">
<h3 id="orgafc467a"><a href="algoritmodiprim.html#ID-8efdf95f-db48-4ddd-8446-ba66233df723">AlgoritmoDiPrim</a></h3>
<div class="outline-text-3" id="text-orgafc467a">
</div>
</div>
</div>

<div id="outline-container-orga490adf" class="outline-2">
<h2 id="orga490adf">Programmazione dinamica</h2>
<div class="outline-text-2" id="text-orga490adf">
<p>
In alcuni casi, il problema viene scomposto in sottoproblemi più piccoli che ritornano più volte. In certi casi, il calcolo di tali sottoproblemi minori porta ad un aumento disastroso del tempo, alle volte esponenziale.
Un esempio è il calcolo dei numeri di Fibonacci. Usando la definizione base avrebbe tempo esponenziale, perchè richiede di calcolare molteplici volte lo stesso valore.
Salvando invece tutti i valori in una tabella, o almeno gli ultimi 2 valori, l'algoritmo esegue in tempo lineare.
</p>
</div>

<div id="outline-container-orgf1c06b5" class="outline-3">
<h3 id="orgf1c06b5">Distanza fra stringhe</h3>
<div class="outline-text-3" id="text-orgf1c06b5">
<p>
Siano ammesse soltanto le tre operazioni di sostituzione, inserimento e cancellazione: allora la distanza di Levenstein (edit distance) è il numero di operazioni necessarie per passare da una stringa all'altra, operando alla fine dell'una per arrivare all'altra.
Allora si dimostra che se una delle due è vuota, allora il numero di operazioni è uguale alla lunghezza di quella non vuota, perchè serve effettuare tante cancellazioni/inserimenti quante sono le lettere di quella non vuota.
Se nessuna è vuota, guardo l'ultimo simbolo e se l'ultimo simbolo è uguale, chiamo la funzione ricorsiva sulle stringhe senza ultimo simbolo. Se l'ultimo simbolo è diverso, allora faccio le chiamate ricorsive per ognuno dei tre casi e prendo il minimo fra essi.
Il problema è che applicando questa strategia, ottengo un equazione di ricorrenza affine a \(3^{n}\). Il motivo per cui le chiamate ricorsive esplodono è proprio che effettuo chiamate sugli stessi argomenti.
Introduco allora una tabella in cui inserico le informazioni man mano, poi ogni volta che devo calcolare una cella utilizzo le tre caselle adiacenti che contengono informazioni già memorizzate in precedenza. Quando le due lettere correnti sono diverse, al minimo dei tre elementi adiacenti già presenti sommo \(1\). Quando sono uguali, copio il numero adiacente diagonalmente.
Il motivo per cui si effettuano queste operazioni è che le tre caselle rappresentano i 3 casi, di sostituzione, inserimento o cancellazione. Quando le lettere sono diverse, allora necessariamente ho effettuato una delle operazioni e quindi al valore precedente devo sommare uno. Quando invece le lettere sono ugali, copio il numero della casella diagonale, che corrisponde al valore invariato di entrambe le stringhe con un valore in meno.
</p>
</div>
</div>

<div id="outline-container-org791a6d8" class="outline-3">
<h3 id="org791a6d8">diff con divide et impera</h3>
<div class="outline-text-3" id="text-org791a6d8">
<p>
Nella tecniva divide-et-impera, si sottodivide il problema in sottoproblemi in direzione top-down, risolvendo i sottoproblemi ridotti che giungono dopo la riduzione.
Nella programmazione dinamica, al contrario, si usa un approccio bottom-up in cui i sottoproblemi minimi sono subito risolti e salvati, in modo che i problemi più grandi possono sfruttare le soluzioni già calcolate.
La divide-et-impera viene usata quando le istanze dei sottoproblemi sono disgiunte.
Si chiama programmazione dinamica (molto vecchia) perchè riempire le tabelle veniva anche chiamato programmare le tabelle e riempire quest'ultime è effettuato in modo dinamico.
</p>
</div>

<div id="outline-container-org9b091e8" class="outline-4">
<h4 id="org9b091e8">Principio di ottimalità</h4>
<div class="outline-text-4" id="text-org9b091e8">
<p>
Stiamo risolvendo un problema di ottimizzazione.
Nel caso della distanza si applica il principio che la soluzione ottima del problema deriva dalle soluzioni ottime dei problemi più piccoli.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org2607ddf" class="outline-2">
<h2 id="org2607ddf">Cammini minimi</h2>
<div class="outline-text-2" id="text-org2607ddf">
<p>
Definiamo il cammino minimo un cammino il cui peso è minore o uguale di ogni altro cammino.
Le proprietà dei cammini minimi sono le seguenti:
</p>
<ul class="org-ul">
<li>se tutti i pesi sono positivi, allora ogni cammino minimo è semplice.</li>
<li>se ci sono pesi negativi ma non cicli di peso negativo allora dato un cammino da x a y, esiste sempre un cammino minimo da x a y che è di peso positivo.</li>
</ul>
</div>
<div id="outline-container-orgc584eea" class="outline-3">
<h3 id="orgc584eea">Rappresentazioni</h3>
<div class="outline-text-3" id="text-orgc584eea">
<ul class="org-ul">
<li>matrice dei pesi: utile per fare manipolazioni algebriche</li>
</ul>
</div>
</div>
<div id="outline-container-orgb2ccc7b" class="outline-3">
<h3 id="orgb2ccc7b">Problemi sui cammini minimi</h3>
<div class="outline-text-3" id="text-orgb2ccc7b">
<ul class="org-ul">
<li>trovare il cammino minimo fra due vertici</li>
<li>trovare i cammini minimi fra un vertice s e gli altri</li>
<li>trovare i cammini minimi fra ogni coppia di vertici</li>
</ul>

<p>
Inoltre, possiamo voler vedere come una tabella di cammini minimi cambia all'inserimento di un nuovo vertice.
Ovvero, aggiunte una riga ed una colonna
</p>
</div>
</div>
<div id="outline-container-orgf232acb" class="outline-3">
<h3 id="orgf232acb">Floyd-Marshall</h3>
<div class="outline-text-3" id="text-orgf232acb">
<p>
Determinare \(d_{ij}\) per ogni elemento, ovvero costruire la tabella.
Scompongo il problema nel considerare nei passi intermendi soltanto gli elementi fino ad un certo indice, indicato con \(k\) in superscript, rilassando man mano \(k\).
Quando \(k=0\), allora
</p>
<ul class="org-ul">
<li>due vertici sono collegati, il peso è la loro distanza (ignoro tutti gli altri element)</li>
<li>0 se è lo stesso vertice</li>
<li>infinito altrimenti, ovvero se non c'è un collegamento fra i due elementi con più di un</li>
</ul>

<p>
Nel passo generale, mi trovo a conoscere la strada fra due elementi e la condizione viene rilassata. Così, posso valutare se passare attraverso i nuovi vertici o meno.
</p>
<pre class="example" id="org5bddd41">
ALGORITMO FloydMarshall(Grafo G) -&gt; Matrice
    Siano D0[1..n, 1..n],...,D0[1..n,1..n] matrici
    # gestisco il caso di k=0
    FOR i&lt;-1 TO n DO
        FOR j&lt;-i TO n DO
            IF i=j THEN D[i,j] &lt;- 0
            ELSE IF c'è i-j fra gli archi THEN D0[i,j] &lt;- o(i,j)
            ELSE inf
    # passo generale
    FOR k=1 to n DO
        FOR i&lt;-1 TO n DO
            FOR j&lt;-i TO n DO
                IF la distanza fra i e k più quella fra k e j è minore di quella fra i e j (nella matrice precedente) THEN
                THEN questa è la nuova distanza
                ELSE lasciala
</pre>
<p>
^ Spazio n<sup>3</sup>
Si può ridurre l'utilizzo di memoria, utilizzando una sola matrice, considerando che i valori i-k e k-j non cambiano nell'aggiornare una matrice.
Ovve
</p>

<pre class="example" id="orgeed9296">
ALGORITMO FloydMarshall(Grafo G) -&gt; Matrice
    CAMBIO
    Abbiamo una sola matrice
    # gestisco il caso di k=0
    FOR i&lt;-1 TO n DO
        FOR j&lt;-i TO n DO
            IF i=j THEN D[i,j] &lt;- 0
            ELSE IF c'è i-j fra gli archi THEN D0[i,j] &lt;- o(i,j)
            ELSE inf
    # passo generale
    FOR k=1 to n DO
        FOR i&lt;-1 TO n DO
            FOR j&lt;-i TO n DO
                CAMBIO
                Prendo la distanza i-k k-j nella stessa matrice
                e aggiorno pure
</pre>
<p>
Spazio n<sup>2</sup>
</p>

<p>
Come stabilire adesso il cammino minimo?
Ho una matrice ausiliaria P in cui P[i,j]
indica il nodo che mi ha portato lì. In questo modo, prendo il valore minore della riga(?non ne sono sicuro) e recupero chi mi ci ha portato
</p>

<p>
Notare che l'algoritmo di floyd marshall prevede che non ci siano cicli negativi, ma è corretto anche in caso di pesi negativi.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-11-21 Thu 17:02</p>
</div>
</body>
</html>
