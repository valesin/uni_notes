<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-21 Thu 19:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ordinamento</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      {packages: {'[+]': ['mathtools']}},
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'scale'
    },
    loader: {
      load: ['[tex]/mathtools']
    },
};
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Ordinamento</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgaaf3b9f">Algoritmi di ordinamento</a>
<ul>
<li><a href="#org5001f69"><span class="todo TODO">TODO</span> Inserire casi migliori e peggiori per ogni algoritmo</a></li>
<li><a href="#org670590c">Introduzione</a>
<ul>
<li><a href="#org4047b58">Stabilità</a></li>
<li><a href="#org7f2f2a1">Complessità</a></li>
</ul>
</li>
<li><a href="#orgda7ef56">Algoritmi elementari</a>
<ul>
<li><a href="#org48ff491">SelectionSort</a></li>
<li><a href="#org59041c0">InsertionSort</a></li>
<li><a href="#org95391b8">BubbleSort</a></li>
</ul>
</li>
<li><a href="#orgb25e762">Algoritmi avanzati</a>
<ul>
<li><a href="#org719779b">MergeSort</a></li>
<li><a href="#org62433cd">QuickSort</a></li>
<li><a href="#org833d49d">Heapsort</a></li>
</ul>
</li>
<li><a href="#org0f2b90a">Algoritmi senza confronti</a></li>
</ul>
</li>
<li><a href="#org3182bc2">Ragionamenti su binari</a>
<ul>
<li><a href="#org0e4def5"><span class="todo TODO">TODO</span> Ragionare su questo, cosa c'entra il log e come esplicitare attraverso gli esponenti</a></li>
</ul>
</li>
<li><a href="#orgce23eaa">Trovare limite superiore per somma</a></li>
<li><a href="#org89018da">Riassunto ordinamento basato su confronti</a></li>
<li><a href="#orgdf9025c">Limite inferiore ai metodi basati sui confronti</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgaaf3b9f" class="outline-2">
<h2 id="orgaaf3b9f">Algoritmi di ordinamento</h2>
<div class="outline-text-2" id="text-orgaaf3b9f">
</div>
<div id="outline-container-org5001f69" class="outline-3">
<h3 id="org5001f69"><span class="todo TODO">TODO</span> Inserire casi migliori e peggiori per ogni algoritmo</h3>
</div>
<div id="outline-container-org670590c" class="outline-3">
<h3 id="org670590c">Introduzione</h3>
<div class="outline-text-3" id="text-org670590c">
<p>
In questo corso si tratta soltanto di ordinamento interno, non di quello esterno, in cui i dati vengono prelevati in blocchi dalla memoria di massa.
</p>

<p>
Si ordinano array di strutture complesse, in cui uno dei campi viene scelto come chiave per l'ordinamento ed una relazione di ordine viene definita su di esso.
</p>

<p>
Durante il corso, si utilizzeranno degli array di interi, per semplificare il ragionamento, che viene poi facilmente espanso al caso generale.
</p>
</div>

<div id="outline-container-org4047b58" class="outline-4">
<h4 id="org4047b58">Stabilità</h4>
<div class="outline-text-4" id="text-org4047b58">
<p>
Un algoritmo si dice <b>stabile</b> quando, dati due record con la medesima chiave, l'ordine in cui essi si trovano nell'array ordinato è lo stesso in cui si trovavano in quello iniziale.
</p>
</div>
</div>

<div id="outline-container-org7f2f2a1" class="outline-4">
<h4 id="org7f2f2a1">Complessità</h4>
<div class="outline-text-4" id="text-org7f2f2a1">
<p>
Si studieranno principalmente algoritmi di ordinamento basati su confronti da chiavi. Si valuteranno la complessità in termini di <b>tempo</b> e <b>spazio</b>.
</p>
</div>

<ul class="org-ul">
<li><a id="org9a2a53a"></a>Spazio<br />
<div class="outline-text-5" id="text-org9a2a53a">
<p>
Lo spazio ulteriore a quello necessario per l'array.
</p>
</div>
</li>

<li><a id="org84e1a7e"></a>Tempo<br />
<div class="outline-text-5" id="text-org84e1a7e">
<p>
Si utilizza il numero di confronti come criterio. Infatti, questi sono le operazioni più costose. Se ciascun confronto viene effettuato in tempo costante, il numero di confronti fornisce una stima del tempo di calcolo. Infatti, in base al criterio di costo uniforme, può essere poi molitplicato per il tempo necessario per un singolo confronto (es. O(1) per interi, O(s) per stringhe di lunghezza s) per ottenere una stima del tempo totale.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgda7ef56" class="outline-3">
<h3 id="orgda7ef56">Algoritmi elementari</h3>
<div class="outline-text-3" id="text-orgda7ef56">
<p>
I seguenti algoritmi sono eseguiti in tempo O(n<sup>2</sup>). La loro implementazione è semplice, ma l'efficienza limitata. Agiscono tutti <i>in loco</i>, ovvero non necessitano di strutture ausiliare.
I primi due algo lavorano in modo incrementale. Una parte è ordinata, l'altra no e fra la seconda selezioniamo il posto corretto per aggiungervi un nuovo elemento.
Il bubblesort invece, scambia a coppie e si ferma quando non c'è più modo di scambiare.
</p>
</div>

<div id="outline-container-org48ff491" class="outline-4">
<h4 id="org48ff491">SelectionSort</h4>
<div class="outline-text-4" id="text-org48ff491">
<pre class="example" id="org14a96eb">
ALGORITMO selectionSort (Array A[0..N-1])
    FOR k &lt;- 0 to n-2 DO
        m &lt;- k                            //posizione del minimo
        FOR j &lt;- k+1 to n-1 DO
            IF A[j] &lt; A[m] THEN m &lt;- j
            ENDIF
        ENDFOR
        scambia A[m] con A[k]             //sistema il minimo in posizione k
    ENDFOR
</pre>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #a020f0;">package</span> main

<span style="color: #a020f0;">import</span> <span style="color: #8b2252;">"fmt"</span>

<span style="color: #a020f0;">func</span> <span style="color: #0000ff;">selectionSort</span>(<span style="color: #a0522d;">A</span> *[]<span style="color: #228b22;">int</span>) {
        <span style="color: #a0522d;">n</span> := <span style="color: #483d8b;">len</span>(*A)
        <span style="color: #a020f0;">for</span> <span style="color: #a0522d;">k</span> := 0; k &lt;= n-2; k++ {
                <span style="color: #a0522d;">m</span> := k
                <span style="color: #a020f0;">for</span> <span style="color: #a0522d;">j</span> := k + 1; j &lt;= n-1; j++ {
                        <span style="color: #a020f0;">if</span> (*A)[j] &lt; (*A)[m] {
                                m = j
                        }
                }
                (*A)[k], (*A)[m] = (*A)[m], (*A)[k]
        }
}

<span style="color: #a020f0;">func</span> <span style="color: #0000ff;">main</span>() {
        <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">A</span> = &amp;[]<span style="color: #228b22;">int</span>{2, 4, 3, 8, 7, 5, 1, 6}
        fmt.<span style="color: #0000ff;">Println</span>(*A)
        <span style="color: #0000ff;">selectionSort</span>(A)
        fmt.<span style="color: #0000ff;">Println</span>(*A)
}
</pre>
</div>

<pre class="example">
[2 4 3 8 7 5 1 6]
[1 2 3 4 5 6 7 8]
</pre>



<p>
Ad ogni passo viene selezionato l'elemento che dev'essere inserito in posizione \(k\), posizione dalla quale non verrà più spostato. 
</p>

<p>
Prima di ogni passo \(k\), i primi \(k\) elementi si trovano nella posizione corretta.
</p>

<p>
Alla fine del passo, un elemento verrà aggiunto in posizione \(k\), portando gli elementi ordinati a \(k+1\).
</p>

<p>
Al passo \(n-1\), i primi \(n-1\) elementi sono ordinati e ne manca \(1\) da ordinare. L'ultimo passo, quindi, è superfluo e ci fermiamo alla posizione \(n-2\).
</p>

<p>
Se il criterio con cui si vuole ordinare l'array è crescente, l'elemento scelto è il minore.
</p>

<p>
Quindi, scansioniamo l'array partendo da sinistra, sostituendo ogni elemento incontrato con quello che dovrebbe trovarsi lì, ovvero il minimo dei successivi.
</p>

<p>
Per trovare il minimo, scansioniamo l'array partendo dall'elemento appena dopo l'indice attuale, ovvero l'indice che vogliamo aggiustare.
</p>

<p>
Arrivati alla fine, scambiamo il minimo con l'elemento attuale e andiamo avanti.
</p>

<p>
L'ultimo elemento non viene controllato, perchè si trova automaticamente nella sua posizione. Infatti, dovrei trovare il minimo fra un solo elemento e poi spostare l'elemento trovato nell'unica posizione disponibile, che è quella in cui si trova già.
</p>

<p>
<b>Non è stabile</b>, perchè l'elemento che viene scambiato con il minimo perde la propria posizione iniziale relativa ai suoi equivalenti.
</p>

<p>
Un esempio è l'array \([10_{1},\;10_{2},\;5] \rightarrow [5,\;10_{2}\;10_{1}]\).
</p>
</div>

<ul class="org-ul">
<li><a id="orgd647c9d"></a>Analisi<br />
<div class="outline-text-5" id="text-orgd647c9d">
<p>
Per la stima del tempo, notare che alla \(k\) -esima iterazione, sono stati effettuati \(n-k-1\) confronti.
</p>

<p>
Dato che il numero di iterazioni è \(n-2\), il numero totale di confronti è \(\sum_{k=0}^{n-2} (n-k-1)\), che con un cambio di variabile \((n-k-1) = i+1\), diventa &sum;<sub>1</sub><sup>n-1</sup> i$, che per la formula di gauss e risostituendo il valore iniziale, diventa \(\frac{(n-1)(n)}{2}\), quindi \(\Theta(n^2)\)
</p>

<p>
Lo spazio è costante perchè si opera <b>in loco</b>.
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org59041c0" class="outline-4">
<h4 id="org59041c0">InsertionSort</h4>
<div class="outline-text-4" id="text-org59041c0">
<pre class="example" id="org7013090">
ALGORITMO insertionSort(Array A[0..N-1])
    FOR k -&gt; 1 TO N-1 DO
        x &lt;- A[k]                       // copia l'elemento da inserire
        j &lt;- k-1
        WHILE j &gt;= 0 &amp;&amp; x &lt; A[j] DO
            A[j+1] = A[j]               // shifta verso destra
            j = j-1
        A[j-1] = x
</pre>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #a020f0;">package</span> main

<span style="color: #a020f0;">import</span> <span style="color: #8b2252;">"fmt"</span>

<span style="color: #a020f0;">func</span> <span style="color: #0000ff;">insertionSort</span>(<span style="color: #a0522d;">A</span> *[]<span style="color: #228b22;">int</span>)  {
        <span style="color: #a0522d;">N</span>:= <span style="color: #483d8b;">len</span>(*A)
        <span style="color: #a020f0;">for</span> <span style="color: #a0522d;">k</span>:=1; k&lt;N; k++{
                <span style="color: #a0522d;">x</span>:=(*A)[k]
                <span style="color: #a0522d;">j</span> := k-1
                <span style="color: #a020f0;">for</span> ;j&gt;=0 &amp;&amp; x &lt; (*A)[j];{
                        (*A)[j+1] = (*A)[j]
                        j--
                }
                (*A)[j+1] = x
        }
}

<span style="color: #a020f0;">func</span> <span style="color: #0000ff;">main</span>() {
        <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">A</span> = &amp;[]<span style="color: #228b22;">int</span>{2, 4, 3, 8, 7, 5, 1, 6}
        fmt.<span style="color: #0000ff;">Println</span>(*A)
        <span style="color: #0000ff;">insertionSort</span>(A)
        fmt.<span style="color: #0000ff;">Println</span>(*A)
}

</pre>
</div>

<pre class="example">
[2 4 3 8 7 5 1 6]
[1 2 3 4 5 6 7 8]
</pre>


<p>
Prima del passo principale, i primi \(k\) elementi formano un <b>sotto-array ordinato</b>.
</p>

<p>
Il passo consiste nel prendere l'elemento successivo, in posizione \(k\) ed inserirlo nella posizione corretta relativamente al sotto-array iniziale.
</p>

<p>
Per farlo, si scansiona il sotto-array <b>da destra verso sinistra</b>, scambiando di volta in volta ogni elemento con il successivo, finchè si arriva ad un elemento minore di quello da inserire.
</p>

<p>
A questo punto, oltre ad aver trovato la posizione finale dell'elemento, si è anche realizzato lo shift verso destra di tutte le posizioni successive e basta copiare l'elemento da inserire nella posizione trovata.
</p>

<p>
Abbiamo quindi due cicli:
</p>
<ul class="org-ul">
<li>quello <b>esterno</b>, da <b>sinistra verso destra</b>, che trova l'elemento da inserire nel sotto-array precedente;</li>
<li>quello <b>interno</b>, da <b>destra verso sinistra</b>, che trova la posizione corretta dell'elemento da inserire e shifta gli elementi maggiori.</li>
</ul>

<p>
E' stabile.
</p>
</div>
<ul class="org-ul">
<li><a id="org191ae15"></a>Alternativa<br />
<div class="outline-text-5" id="text-org191ae15">
<p>
Un algoritmo in cui il ciclo interno operasse da sinistra verso destra, darebbe luogo allo stesso risultato ma sarebbe meno efficiente.
</p>

<p>
In questo caso, dopo aver trovato la posizione corretta, ovvero quella appena precedente al primo elemento maggiore incontrato, bisognerebbe effettuare lo shift di tutti gli elementi verso destra, che comporta una nuovo accesso a memoria per ogni elemento.
</p>

<p>
Questa versione effettua tanti accessi a memoria (in lettura) in più quanti sono i confronti che effettua.
</p>

<p>
La versione tradizionale ottimizza questo aspetto effettuando una sola lettura, il cui valore viene utilizzato sia per il confronto che per lo shift.
</p>
</div>
</li>


<li><a id="org0e0d2c0"></a>Analisi<br />
<div class="outline-text-5" id="text-org0e0d2c0">
<p>
\(sum_{k=1}^{k} i\), che per la formula di gauss è \(\frac{(n-1)(n)}{2}\).
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org95391b8" class="outline-4">
<h4 id="org95391b8">BubbleSort</h4>
<div class="outline-text-4" id="text-org95391b8">
<pre class="example" id="orgfbbf45a">
ALGORITMO bubbleSort(Array A[0..n-1)
k &lt;- 1                            //contatore della scansione
scambiato &lt;- false
    DO
        FOR j&lt;-1 TO n-k DO
        IF A[j] &lt; A[j-1] THEN
            scambia(A[j], A[j-1])
            scambiato &lt;- true
    k &lt;- k+1                      //aggiorno il contatore
    WHILE scambiato &amp;&amp; k &lt; n      //mi fermo quando ho effettuato n-1 scansioni
</pre>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #a020f0;">package</span> main

<span style="color: #a020f0;">import</span> <span style="color: #8b2252;">"fmt"</span>

<span style="color: #a020f0;">func</span> <span style="color: #0000ff;">bubbleSort</span>(<span style="color: #a0522d;">A</span> *[]<span style="color: #228b22;">int</span>) {
        <span style="color: #a0522d;">n</span> := <span style="color: #483d8b;">len</span>(*A)
        <span style="color: #a0522d;">k</span> := 1
        <span style="color: #a020f0;">for</span> {
                <span style="color: #a0522d;">scambiato</span> := <span style="color: #008b8b;">false</span>
                <span style="color: #a020f0;">for</span> <span style="color: #a0522d;">j</span>:=1;j&lt;=n-k;j++{
                        <span style="color: #a020f0;">if</span> (*A)[j] &lt; (*A)[j-1] {
                                (*A)[j], (*A)[j-1] = (*A)[j-1], (*A)[j]
                                scambiato = <span style="color: #008b8b;">true</span>
                        }
                }

                <span style="color: #a020f0;">if</span> !scambiato &amp;&amp; k &gt; n-1 {
                        <span style="color: #a020f0;">break</span>
                }

                k++
        }

}

<span style="color: #a020f0;">func</span> <span style="color: #0000ff;">main</span>() {
        <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">A</span> = &amp;[]<span style="color: #228b22;">int</span>{2, 4, 3, 8, 7, 5, 1, 6}
        fmt.<span style="color: #0000ff;">Println</span>(*A)
        <span style="color: #0000ff;">bubbleSort</span>(A)
        fmt.<span style="color: #0000ff;">Println</span>(*A)
}

</pre>
</div>

<pre class="example">
[2 4 3 8 7 5 1 6]
[1 2 3 4 5 6 7 8]
</pre>



<p>
Questo algoritmo esamina ripetutamente gli elementi a coppie, da sinistra verso destra, e scambia gli elementi se non sono nell'ordine giusto.
</p>

<p>
Se durante una scansione non viene scambiata alcuna coppia, l'array è ordinato e l'algoritmo termina.
</p>

<p>
Ogni serie di scambi (ciclo esterno) porta l'elemento maggiore fra quelli non ordinati a raggiungere la sua posizione finale.
Dopo \(k\) serie, gli ultimi \(k\) elementi sono ordinati.
</p>

<p>
Di conseguenza, il ciclo interno può fermarsi alla posizione \(n-k\).
</p>

<p>
Inoltre, alla $n-1$-esima iterazione, gli ultimi \(n-1\) elementi sono ordinati e di conseguenza anche il primo. Posso quindi fermarmi alla $n-1$-esima iterazione, anche se sono stati effettuati scambi in essa.
</p>
</div>

<ul class="org-ul">
<li><a id="orgfb60ad0"></a>Miglioramento<br />
<div class="outline-text-5" id="text-orgfb60ad0">
<pre class="example" id="org9e58791">
ALGORITMO bubbleSort(Array A[0..n-1])
    primoInOrdine &lt;- n
    DO
        ultimoScambio &lt;- 0
        FOR j=1 TO primoInOrdine-1 DO
            IF A[j] &lt; A[j-1] THEN
                scambia A[j-1] con A[j])
                ultimoScambio = j
            primoInOrdine &lt;- t

    WHILE primoInOrdine &gt; 0
</pre>

<p>
Un miglioramento proposto da <b>Knuth</b> affina la scelta dell'estremo destro oltre cui l'array è sicuramente ordinato.
Infatti, una serie di scambi può portare anche più di un un elemento a raggiungere la propria posizione finale.
In particolare, se l'ultimo scambio è stato fra l'elemento in posizione \(j-1\) e quello in posizione \(j\), allora l'elemento che, dopo lo scambio, si trova in posizione \(j\), si trova nella sua posizione finale, infatti:
</p>

<ul class="org-ul">
<li>è impossibile che \(A_{j+1} < A_{j}\), altrimenti sarebbe stato effettuato un nuovo scambio e quello \([j-1 \leftrightarrow j]\) non sarebbe stato l'ultimo;</li>

<li>non può esserci un elemento \(A_{x} < A_{j}\) fra gli elementi ancora successivi, perchè in quel caso \(A_{x}\) sarebbe appena stato spostato indietro e, come prima, ci sarebbe stato uno scambio successivo a \([j-1 \leftrightarrow j]\)</li>
</ul>
</div>
</li>
<li><a id="org5c6598c"></a>Analisi<br />
<div class="outline-text-5" id="text-org5c6598c">
</div>
<ul class="org-ul">
<li><a id="orgaf282f2"></a>Caso peggiore<br />
<div class="outline-text-6" id="text-orgaf282f2">
<p>
Con un minimo alla fine dell'array, nella versione non migliorata da Knuth, ogni iterazione \(k\) del ciclo esterno dà luogo a \(n-k\) confronti. Dato che \(k\) va da \(1\) a \(n-1\), si ottiene
\[ \sum_{k=1}^{n-1} n-k \; =\; \sum_{k=1}^{n-1} n - \sum_{k=1}^{n-1} k \; = \; n(n-1) - \frac{n(n-1)}{2} \; = \; \frac{n(n-1)}{2} \; = \; O(n^{2})\].
</p>
</div>
</li>
<li><a id="org50d02d2"></a>Caso migliore<br />
<div class="outline-text-6" id="text-org50d02d2">
<p>
Array già ordinato, \(n-1\) confronti
</p>
</div>
</li>
<li><a id="orgbcb94a4"></a>Caso peggiore<br />
<div class="outline-text-6" id="text-orgbcb94a4">
<p>
Con un minimo alla fine dell'array, devo effettuare $n-1
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb25e762" class="outline-3">
<h3 id="orgb25e762">Algoritmi avanzati</h3>
<div class="outline-text-3" id="text-orgb25e762">
<p>
I seguenti algoritmi sono eseguiti in un tempo \(O(n\log n)\), che è il limite inferiore di confronti necessari per ordinare un array di interi.
Solo lo HeapSort è in loco, mentre il QuickSort e il MergeSort utilizzano strutture aggiuntive per la ricorsione o per un array aggiuntivo.
</p>
</div>

<div id="outline-container-org719779b" class="outline-4">
<h4 id="org719779b">MergeSort</h4>
<div class="outline-text-4" id="text-org719779b">
<p>
Il MergeSort si basa sullo scomporre il problema dell'ordinamento di un array all'ordinamento delle due metà ed alla loro fusione (<i>merge</i>).
</p>
</div>

<ul class="org-ul">
<li><a id="orgdbb352b"></a>Merge<br />
<div class="outline-text-5" id="text-orgdbb352b">
<p>
Da due array <b>già ordinati</b> \(B\) e \(C\) si vuole ottenere un array \(X\) che contenga tutti gli elementi di \(B\) e \(C\), correttamente ordinati, sfruttando il fatto che i due array iniziali siano già ordinati.
</p>

<p>
Dato che i due array sono già ordinati, ad ogni passo \(k\), il minimo di \(X\) è necessariamente fra quello di \(B\) e quello di \(C\).
Scorro entrambi gli array partendo da sinistra, confrontando i loro minimi e spostando il minore fra essi in posizione \(k-1\) di \(X\).
Svuotato uno degli array, gli elementi dell'altro sono maggiori di ogni altro elemento in \(X\) e vanno quindi posizionati per occupare le posizioni rimanenti.
</p>

<p>
Questa tecnica è usata anche per fondere memorie esterne.
</p>
</div>
<ul class="org-ul">
<li><a id="org092ff12"></a>Analisi<br />
<div class="outline-text-6" id="text-org092ff12">
<p>
Il caso peggiore avviene quando all'iterazione \(n+m-2\) la lunghezza di entrambi gli array è \(1\).
Questo accade quando entrambi gli ultimi elementi sono più grandi di ogni altro elemento dell'altro array, escluso l'ultimo.
Ovvero nelle situazioni di questo tipo:
\[A = [e_{1},\cdots,e_{x},a]\quad b = [f_{1},\cdots,f_{x},b] \quad\quad a>f_{n},\;b>e_{n},\quad 1\leq n\leq x \]
</p>

<p>
Alcuni esempi diversi fra loro sono:
</p>
<ul class="org-ul">
<li>\([1..50]\quad[1..50]\).</li>
<li>\([2,4,6,8]\quad[1,3,5,7]\)</li>
<li>\([1..10]\quad[100]\)</li>
</ul>

<p>
Il numero di confronti in tali casi è \(n-1\), perchè ogni elemento verrà confrontato con quello dell'altro array, finchè non si arriva al punto in cui un array è vuoto e l'altro contiene un solo elemento, che è il massimo e va semplicemente copiato nell'ultima posizione dell'array risultante.
</p>
</div>
</li>
</ul>
</li>
<li><a id="orga976dff"></a>Sort<br />
<div class="outline-text-5" id="text-orga976dff">
<pre class="example" id="org7b48322">
ALGORITMO mergeSort(Array A[0..n-1])
    IF n&gt;1 THEN
        m = n/2
        B &lt;-A[0..m-1]
        C &lt;-A[m..n-1]
        mergeSort(B)
        mergeSort(C)
        A &lt;- merge(B,C)
    
</pre>
<p>
L'ordinamento di un array consiste nel dividere l'array da ordinare in due sottoarray di dimensione \(\lceil \frac{n}{2}\rceil\) e \(\lfloor \frac{n}{2}\rfloor\), ordinarli mediante chiamata ricorsiva e poi unirli con l'algoritmo <code>merge</code>.
</p>
</div>

<ul class="org-ul">
<li><a id="orgee98d66"></a>Analisi tempo<br />
<div class="outline-text-6" id="text-orgee98d66">
<p>
Ogni chiamata ricorsiva dell'algoritmo viene eseguita su un input che è la metà di quello originario.
</p>

<p>
Quando l'input raggiunge la dimensione di \(1\), non viene eseguita alcuna operazione.
</p>

<p>
Il numero di confronti richiesto dal MergeSort su un input \(n\), indicato con \(C(n)\), è quindi
\[C(n) = C(\lfloor\frac {n}{2}\rfloor + C(\lceil\frac{n}{2}\rceil) + n - 1\]
</p>

<p>
Per semplificare i calcoli, supponiamo \(n\) pari ed otteniamo \(C(n) = 2C(\frac {n}{2}) + n - 1\)
</p>

<p>
Usando il metodo di sostituzione:
</p>

<p>
<b><b>Step 1: Dividi entrambi i lati per \(n\)</b></b>
</p>

<p>
\[ \dfrac{C(n)}{n} = \dfrac{2C\left(\dfrac{n}{2}\right)}{n} + \dfrac{n-1}{n} \]
</p>

<p>
<b><b>Step 2: Muovi il \(2\) al denominatore</b></b>
</p>

<p>
\[ \dfrac{C(n)}{n} = \dfrac{C\left(\dfrac{n}{2}\right)}{\dfrac{n}{2}} + 1 - \dfrac{1}{n} \]
</p>

<p>
<b><b>Step 3: Sostituisci con una nuova funzione</b></b>
</p>

<p>
\[ f(n) = \dfrac{C(n)}{n} \]
</p>

<p>
Quindi la nuova equazione diventa:
</p>

<p>
\[ f(n) = f\left(\dfrac{n}{2}\right) + 1 - \dfrac{1}{n} \]
</p>

<p>
<b><b>Step 4: Espandi ricorsivamente</b></b>
</p>

\begin{align*}
f(n) &= f\left(\dfrac{n}{2}\right) + 1 - \dfrac{1}{n} \\
&= \left[f\left(\dfrac{n}{4}\right) + 1 - \dfrac{2}{n}\right] + 1 - \dfrac{1}{n} \\
&= f\left(\dfrac{n}{4}\right) + 2 - \dfrac{3}{n} \\
&= f\left(\dfrac{n}{2^i}\right) + i - \frac{\sum_{k=0}^{i}2^{k}}{n}
\end{align*}


<p>
Notare che \(\sum_{k=0}^{i}2^{k} = \dfrac{2^i-1}{n}\)
</p>

<p>
<b><b>Step 5: Trova il caso in cui la ricorsione si ferma</b></b>
</p>

<p>
Quando \[ \dfrac{n}{2^i} = 1 \]
Allora \[ n = 2^i \]
Quindi \[ i = \log_2 n \]
</p>

<p>
<b><b>Step 6: Sostituisci il valore trovato</b></b>
</p>

<p>
\[ f(n) = f(1) + \log_2 n - \dfrac{n-1}{n} \]
</p>

<p>
<b><b>Step 7: Risolvi per C(n)</b></b>
</p>

<p>
Dato che \[ f(n) = \dfrac{C(n)}{n} \]
</p>

<p>
Moltiplica entrambi i lati per \(n\):
</p>

<p>
\[ C(n) = n \cdot f(1) + n\log_2 n - (n-1) \]
\[ C(n) = n\log_2 n + O(n) \]
</p>

<p>
Infine:
</p>

<p>
\[ C(n) = O(n\log n) \]
</p>

<p>
Con i miei calcoli, arrivo a nlg(n) - n + 1. Usando le proprietà di prima, considero l'N maggiore dell n in binario, e poi considero il 2 n maggiore dell'altro 2 n. Mi esce fuori un numero più alto dell'altro, ma sempre nell'ordine di n log n.
</p>
</div>
<ul class="org-ul">
<li><a id="orgd3eb1a9"></a>Nota<br />
<div class="outline-text-7" id="text-orgd3eb1a9">
<p>
Perchè divido per \(n\) e muovo il \(2\) al denominatore?
</p>


<blockquote>
<p>
Dividing by n in the recurrence relation is not strictly necessary, but it's a helpful technique for several intuitive reasons:
</p>

<ol class="org-ol">
<li><b><b>Pattern Recognition:</b></b>
When we divide by n, we get:
\[ \frac{C(n)}{n} = \frac{C(n/2)}{n/2} + 1 - \frac{1}{n} \]
This transformation helps us see a clearer pattern. By defining f(n) = C(n)/n, we get:
\[ f(n) = f(n/2) + 1 - \frac{1}{n} \]
This is much simpler to work with than the original equation.</li>

<li><b><b>Telescoping Series:</b></b>
The division by n transforms the recurrence into a form that resembles a telescoping series. When we expand it:
\[ f(n) = f(n/2) + 1 - \frac{1}{n} \]
\[ f(n/2) = f(n/4) + 1 - \frac{2}{n} \]
\[ f(n/4) = f(n/8) + 1 - \frac{4}{n} \]
Each step adds a constant term (1) and a decreasing fraction, making the pattern easier to spot and sum.</li>

<li><b><b>Normalization:</b></b>
By dividing by n, we're essentially "normalizing" the cost at each level relative to the input size. This helps us see how the cost per element changes as we go deeper in the recursion.</li>

<li><b><b>Mathematical Intuition:</b></b>
Without division by n, we would need to track larger terms and their relationships. The division helps reduce the complexity of each term, making the mathematical manipulation more manageable.</li>
</ol>
</blockquote>
</div>
</li>
<li><a id="org03531ce"></a><span class="todo TODO">TODO</span> Riempire con equazione sulle slides<br /></li>
</ul>
</li>

<li><a id="org1041f39"></a>Analizi spazio<br />
<div class="outline-text-6" id="text-org1041f39">
<p>
Sia \(H(n)\) l'altezza massima dello stack di ricorsione, ovvero quanti record di attivazione possono esistere allo stesso momento, in funzione di \(n\)?
Se \(n=1\), \(H(n)=1\), ovvero l'unica chiamata che termina subito con il caso base.
Se \(n>1\), allora avrò una chiamata iniziale, più \(\max (H(\lfloor\frac {n}{2}\rfloor), H(\lceil\frac{n}{2}\rceil)\) chiamate nello stesso momento.
Per \(n\) potenza di \(2\), si ottiene \(H(n)=1+\log_{2} n\). In generale, \(H(n) = \Theta(\log n)\).
</p>
</div>
</li>
<li><a id="org65417a9"></a>Implementazione quasi in loco<br />
<div class="outline-text-6" id="text-org65417a9">
<p>
L'implementazione precedente occupa tanto spazio inutile. Ogni chiamata ricorsiva che rimane aperta, mantiene in memoria il contenuto dell'array in cui quella precedente viene divisa.
Se si riesce a ottimizzare quella parte, si potrebbe risparmiare una gran parte di memoria.
Si ovvierà a questo problema giocando con gli indici.
Otterrò una procedura che prende in input non soltanto l'array, ma gli indici di partenza ed arrivo.
La lunghezza dell'array diventa uguale alla differenza fra l'indice di arrivo e quello di partenza, e dividendo per due si ottiene l'indice di mezzo (al netto della parte decimale).
Una volta fissato <code>m</code>, non ho più bisogno di copiare il contenuto degli array parziali in una nuova porzione di memoria, quindi salto i due assegnamenti e passo direttamente alla chiamata ricorsiva.
La prima chiamata opera sull'array da <code>i</code> a <code>m</code>, mentre la seconda da <code>m</code> a <code>f</code>.
L'algoritmo che viene chiamato all'inizio è un "wrapper" in cui gli indici sono quello iniziale e finale.
Dopodichè, va modificato anche l'algoritmo di <code>merge</code> per operare su uno stesso array.
Prima lavorava su due array diversi, salvando il contenuto ordinato in un nuovo array.
Adesso continuo ad avere un array ulteriore di supporto in cui ordinare gli elementi, ma ricopierò poi il contenuto di questi elementi nell'array originale.
Notare che l'array di supporto per il <code>merge</code> viene dichiarato in precedenza, nella funzione wrapper. Per una questione di chiarezza, sarebbe meglio non fare così, cosicchè non sarebbe necessario passare l'array ogni volta. Nonostante ciò, è più efficiente dichiararlo all'esterno, al posto di istanziarne uno nuovo ad ogni chiamata di <code>merge</code>.
L'analisi del tempo è assolutamente la stessa.
</p>
</div>
<ul class="org-ul">
<li><a id="org1c194d1"></a>Analisi spazio<br />
<div class="outline-text-7" id="text-org1c194d1">
<p>
Adesso utilizzo un array dimensionato su quello iniziale, quindi \(\Theta(n)\).
L'altezza dello stack di ricorsione è la stessa di prima, ma la dimensione dei record è costante. L'occupazione di memoria è quindi \(\Theta(\log n)\). Fra i due prevale \(\Theta(n)\).
</p>
</div>
</li>
</ul>
</li>
<li><a id="org482bb3a"></a>Stabilità<br />
<div class="outline-text-6" id="text-org482bb3a">
<p>
Nel <code>merge</code> mi capita di confrontare elementi uguali. Eppure, viene usato il \(\leq\), quindi nel caso in cui l'elemento del primo array sia uguale, viene scelto quello. Nel caso in cui togliessi l'uguale e usassi il semplice \(<\), perderebbe la stabilità.
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org62433cd" class="outline-4">
<h4 id="org62433cd">QuickSort</h4>
<div class="outline-text-4" id="text-org62433cd">
<p>
Nel caso peggiore esegue in theta(n<sup>2</sup>), ma dimostreremo che tale caso avviene molto raramente e il caso medio è molto conveniente.
</p>
</div>
<ul class="org-ul">
<li><a id="org2ee21f7"></a>QuickSort<br />
<div class="outline-text-5" id="text-org2ee21f7">
<p>
Il criterio è di partizionare il mio vettore rispetto a un elemento arbitrario, <b>perno</b> o <b>pivot</b>.
Dopodichè, metto i numeri più piccoli prima, quelli più grandi dopo, e poi ordino ricorsivamente le due partizioni.
</p>
<pre class="example" id="org5b1ddcc">
ALGORITMO quickSort(Array A)
IF lunghezza A&gt;1 THEN
    scegli un elemento x di A
    B &lt;- {y \in A} | y &lt; x}
    C &lt;- {y \in A} | y &gt; x}
    quickSort(B)
    quickSort(C)
    A &lt;- concatenazione di B,x,C
</pre>
</div>
<ul class="org-ul">
<li><a id="org0ddf47a"></a>Partizionamento<br />
<div class="outline-text-6" id="text-org0ddf47a">
<p>
Il partizionamento va fatto "spendendo poco", ovvero facendo pochi confronti e senza usare memoria aggiuntiva. Se non avessi alcun <i>constraint</i>, mi basterebbe usare memoria aggiuntiva arbitraria per dividere gli elementi.
Per far sì che operi in loco, il mio algoritmo <code>partiziona</code>, dovrebbe partizionare A[i..f-1] rispetto a un elemento, in modo che prima del perno ci siano gli elementi minori e dopo quelli maggiori. Alla fine, l'algoritmo deve restituire la posizione del perno, in quanto dovrò operare soltanto sulle partizioni alla sua destra e alla sinistra. Infatti, il perno si trova nella sua posizione definitiva. <sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
Scelgo il primo elemento come perno.
Scansiono da destra fino a trovare un elemento minore del perno, che non può stare a destra.
Scansiono da sinistra fino a trovare un elemento maggiore del perno.
Scambio i due elementi. Al momento dello scambio, sono sicuro che gli elementi scansionati da destra e gli elementi scansionati da sinistra siano al posto giusto.
Termino quando gli indici di scansione si incontrano, poi scambio il perno con l'elemento al punto in cui si sono incontrati.
Inoltre, parto con gli indici fuori di 1, perchè questo mi permette di fare meno confronti.
</p>
<pre class="example" id="org09f9ca5">
ALGORITMO partiziona(Array A, indice i, indice f) -&gt; indice
perno &lt;- A[i]
dx &lt;- f
sx &lt;- i
WHILE sx &lt; dx DO
   DO dx &lt;- dx - 1 WHILE A[dx] &gt;  perno               ;; in questo caso non posso sforare, perchè prima o poi raggiungerò il perno
   DO sx &lt;- sx + 1 WHILE A[sx] &lt;= perno AND sx &lt; dx   ;; in questo caso posso sforare, quindi devo anche fare un controllo
   IF sx &lt; dx THEN
      scambia A[sx] con A[dx]
scambia A[i] con A[dx]
</pre>
<p>
Notare che controllo 3 volte sx&lt;dx, in modo da evitare confronti inutili.
In un array già ordinato, dx si sposta fino a sbattere contro il perno. Sx farà un salto a sinistra. Scambio il perno con sè stesso e al quickSort passerò un array che è intero, eccetto il perno, e l'altro che è vuoto.
</p>
</div>

<ul class="org-ul">
<li><a id="org636720c"></a><span class="todo TODO">TODO</span> Controllare perchè presumo che l'ultimo elemento sia minore del perno.<br />
<div class="outline-text-7" id="text-org636720c">
<p>
A un certo punto dx arriverà sul perno, che non è maggiore di sè stesso e quindi la condizione si annullerà.
</p>
</div>
</li>

<li><a id="orge823269"></a><span class="todo TODO">TODO</span> Controllare in che modo il controllo triplice eviti confronti inutili.<br />
<div class="outline-text-7" id="text-orge823269">
<p>
Sposto e poi controllo perchè così sono sicuro che l'elemento sia stato valutato una volta che vado avanti (?).
Quando scambio gli elementi ai due indici, sono già sicuro che entrambi si trovino nella posizione corretta. Non mi serve fare il controllo di nuovo. Posso quindi skippare il controllo dell'elemento appena scambiato. Spostare prima del controllo mi garantisce questo.
Credo che lo stesso valga nel caso in cui sposti l'elemento precedente.
</p>
</div>
</li>

<li><a id="orgca0ca5f"></a><span class="todo TODO">TODO</span> Non è uguale scambiare sx al posto di dx, perchè sx a volte scavalca. Controllare perchè<br /></li>
</ul>
</li>
<li><a id="org5de816e"></a>Unione<br />
<div class="outline-text-6" id="text-org5de816e">
<pre class="example" id="org56a5050">
PROCEDURA quickSort_inner(Array A, indice i, indice f)
IF f-i&gt;1 THEN
    m &lt;- partiziona(A,i,f)
    quickSort(A,i,m)
    quickSort(A, m+1, f)   // il perno è già apposto, quindi non ci interessa

ALGORITMO quickSort(Array A[0..n-1])
quickSort_inner(A,0,n)
</pre>
</div>
</li>
<li><a id="org1bd28bd"></a>Analisi tempo<br />
<div class="outline-text-6" id="text-org1bd28bd">
<p>
Negli altri algoritmi, quando divido conosco sempre la grandezza delle parti ottenute. Adesso questa dipende da dove va a finire il perno.
sia \(C(n)\) il numero di confronti su un array di lunghezza \(n\).
Il caso base è facile: \(0\) confronti se \(n \leq 1\).
Nel caso ricorrente, \(C_{part}(n) + C(k)  + C(n-k-1))\), dove \(k\) è il numero di elementi in una partizione e il termine successivo nell'altra.
</p>
</div>
<ul class="org-ul">
<li><a id="orga70c55d"></a>Caso peggiore<br />
<div class="outline-text-7" id="text-orga70c55d">
<p>
Il caso peggiore è quello in cui la somma fra i due termini massimizzano il risultato.
Si può dimostrare che il massimo si ottiene quando la partizione è sbilanciata. Intuizione: sto usando divide et impera. Se divido il problema in uno di dimensione \(1\) e l'altro di dimensione \(n-1\), allora ho guadagnato molto poco.
Infatti, otterrei nel caso ricorrente \(n+\max (C_{w}(k)+C_{w}(n-k-1)|k=0..n-1)\)
Quindi risolvendo l'equazione di ricorrenza otterrei \(\sum_{i=2}^{n} i = \frac{n(n+1)}{2} -1 = \Theta(n^{2})\), molto sconveniente, perchè il codice è molto complicato, mentre il risultato è lo stesso degli algoritmi elementari, con in più lo stack di ricorrenza. Inoltre, su un array già parzialmente ordinato, fa tanti confronti.
Un numero quasi preciso è \(\approx \frac{n^{2}}{2}\)
</p>
</div>
</li>
<li><a id="org02662b9"></a>Caso migliore<br />
<div class="outline-text-7" id="text-org02662b9">
<p>
Voglio trovare la coppia che minimizza la somma, quindi \(\min (C_{w}(k)+C_{w}(n-k-1)|k=0..n-1)\).
Infatti, in questo caso otterrei \(c_{b}(n) = n+2C_{b}(\frac{n}{2}\), che è dimostrabile sia \(\approx n \log_{2} n\). Notare che questo è un numero preciso e non una stima.
</p>
</div>
<ul class="org-ul">
<li><a id="org91e05b2"></a>Il risultato della somma della coppia è una combinazione non lineare (quadratica). Questo significa che il vantaggio ottenuto dal bilanciamento è esponenziale. Ovvero, diminuire uno dei fattori mi da un vantaggio maggiore che aumentare l'altro della stessa quantità. Si può immaginare come una parabola in cui seleziono due punti sui due lati.<br /></li>
</ul>
</li>
<li><a id="orgdaa4ff2"></a>Caso medio<br />
<div class="outline-text-7" id="text-orgdaa4ff2">
<p>
Prendo la somma dei tempi di tutti i casi possibili e poi la divido per il numero di casi, ovvero una semplice media.
\(C(n) = 0\) se \(n\leq 1\)
\(C(n) =\frac{\sum_{n=0}^{n-1} (n + C(k) + C(n-k-1)}{n}\)
Divido la frazione nei fattori del numeratore, e ottengo che la sommatoria su n è uguale ad \(n\), e gli altri due fattori sono uguali.
Otteniamo una certa equazione, che non dimostriamo come è ottenuta, ma dimostriamo per induzione che sia corretta.
Dimostriamo che \(C(n) \leq 2n \log n\), per \(n\geq 1\)
Caso base \(n=1\): C(1) = 0, sostituisco ed è giusto
Induzione: \(C(n) = n + \frac{2}{n} sum_{i=2}^{n-1}C(i)\leq n + \frac{2}{n} sum_{i=2}^{n-1}C(i) 21\log i\)
</p>

<p>
Alla fine ottengo che il caso medio è minore di \(2n \log n\), che è uguale a \(1.39 n\log_{2} n\). Quindi il caso medio è molto vicino al caso migliore. Questo vuol dire che il caso peggiore succede molto raramente.
Una tecnica che viene usata per aumentare il caso medio, è quella che prima di partizionare randomizza l'ordine. Infatti, il caso peggiore è quello in cui l'array sia già ordinato e il primo elemento sia il minore. Così facendo, diminuisce la probabilità che lo sia.
Altrimenti scegliamo come perno un elemento a caso, lo scambiamo con il primo e poi operiamo l'array.n
</p>
</div>
<ul class="org-ul">
<li><a id="org8fb4737"></a><span class="todo TODO">TODO</span> Continuare dimostrazione<br /></li>
</ul>
</li>
<li><a id="orgcd3cf2c"></a>Osservazioni<br />
<div class="outline-text-7" id="text-orgcd3cf2c">
<p>
Non è stabile, esiste una versione che lo renda stabile ma aumentando la costante
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgea4ae84"></a>Analisi spazio<br />
<div class="outline-text-6" id="text-orgea4ae84">
<p>
Nel caso di una suddivisione bilanciata, ottengo un'altezza \(\approx \log_{2} n\), simile al mergesort. Infatti, uno dei lati conterrà la metà dell'input, che a sua volta chiamerà metà dell'input, e così via.
Nel caso di una suddivisione sbilanciata, apro una chiamata ricorsiva per ogni elemento, quindi avrò un'altezza lineare.
</p>
</div>
</li>
<li><a id="org46a6d19"></a>Ottimizzazioni<br />
<div class="outline-text-6" id="text-org46a6d19">
<p>
Notare che la seconda chiamata ricorsiva è in coda. Posso, dunque ottimizzare questa parte. Cancello la seconda chiamata ricorsiva, trasformo l'IF in un WHILE.
In questo caso mi libero di una delle parti in cui lo stack di attivazione cresce. Trasformando la chiamata ricorsiva destra in un iterazione, risolvo i casi in cui il perno è il minore ( o maggiore? ), perchè in quel caso la parte sinistra non cresceva, mentre la destra sì.
Dato che posso invertire l'ordine delle chiamate ricorsive, posso fare la stessa cosa al contrario, ovvero ricorrere sulla parte destra.
Ognuna ha un caso critico. Posso scrivere una procedura che scelga quale delle due usare secondo un criterio.
</p>
<pre class="example" id="orgae3b03a">
PROCEDURA quickSort(Array A, indice i, indice f)
WHILE f-i&gt;1 DO
    m &lt;- partiziona(A,i,f)
    IF  m-i &lt; f-m THEN
        quickSort(A,i,m)
        i &lt;- m+1
    ELSE
        quickSort(A,m+1,f)
        f&lt;- m
</pre>
<p>
Il criterio è che io so che la chiamata ricorsiva che crescerà di più è quella più lunga. Quindi faccio la chiamata ricorsiva su quella più breve.
Di quanto migliora? Prima la lunghezza arrivava ad \(n\), perchè nel caso peggiore facevo chiamate sull'intero array ogni volta, ovvero eliminavo un caso da ogni chiamata ricorsiva e mi calcolavo gli altri n-1.
Adesso, sono sicuro che ogni volta faccio ricorsione sulla parte minore. Nel caso in cui il perno sia perfettamente centrato, lavoro su chiamate ricorsive sulla metà degli elementi, quindi con un altezza logaritmica. Entrambe le scelte avrebbero lo stesso risultato, ovvero uguale all'algoritmo senza opportunistica.
Nel caso in cui le partizioni siano sbilanciate, sceglierò sempre quella minore, quindi la ricorsione sarà sempre minore di quella del caso precedente. Quindi lo spazio occupato da questa versione rispetto alla precedente, rimane uguale nel caso migliore e diminuisce nel caso peggiore. (Il vantaggio è ridotto per il fatto che il caso peggiore avviene raramente, ma è comunque un vantaggio).
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org833d49d" class="outline-4">
<h4 id="org833d49d">Heapsort</h4>
<div class="outline-text-4" id="text-org833d49d">
<p>
to be filled
</p>
</div>
</div>
</div>
<div id="outline-container-org0f2b90a" class="outline-3">
<h3 id="org0f2b90a">Algoritmi senza confronti</h3>
<div class="outline-text-3" id="text-org0f2b90a">
<p>
Fill !
</p>
</div>
</div>
</div>
<div id="outline-container-org3182bc2" class="outline-2">
<h2 id="org3182bc2">Ragionamenti su binari</h2>
<div class="outline-text-2" id="text-org3182bc2">
<p>
Sommatoria da i=0 a k-1 di 2<sup>i</sup>. Penso alla codifica binaria. Quella sommatoria è uguale a tutti 1. Prendo il binario successivo, che ha una cifra in più, con la più grande settata a uno e tutte le successive 0. Quel numero è 2<sup>k</sup>. Poi sottraggo uno.
Il doppio di un binario è uno shift verso sinistra.
\(\forall n \in \mathbb{Z}, \; \exists N : N = 2^{k}, k\in\mathbb{Z}, \; t.c. \; n\leq N\l<2n\), ovvero, c'è sempre una potenza di due che è uguale al numero o minore del doppio.
</p>
</div>
<div id="outline-container-org0e4def5" class="outline-3">
<h3 id="org0e4def5"><span class="todo TODO">TODO</span> Ragionare su questo, cosa c'entra il log e come esplicitare attraverso gli esponenti</h3>
</div>
</div>
<div id="outline-container-orgce23eaa" class="outline-2">
<h2 id="orgce23eaa">Trovare limite superiore per somma</h2>
<div class="outline-text-2" id="text-orgce23eaa">
<p>
Si utilizza una proprietà in base a cui il valore di una sommatoria è sicuramente inferiore dell'integrale sullo stesso intervallo (quindi quello che termina al numero successivo a quello in cui termina la somma). Il calcolo dell'integrale mi da una stima superiore.
</p>
</div>
</div>
<div id="outline-container-org89018da" class="outline-2">
<h2 id="org89018da">Riassunto ordinamento basato su confronti</h2>
<div class="outline-text-2" id="text-org89018da">
<p>
Nel selectionSort, la prima parte contiene degli elementi già ordinati e ogni volta cerchiamo il minimo della seconda parte e lo mettiamo al posto giusto. Il tempo e \(\Theta n^{2}\) sempre, mentre lo spazio è costante.
L'insertionSort ha \(\Theta n^{2}\) nel caso peggiore, ma \(n-1\) nel caso di array già ordinato
Bubblesort fa passate successive, scambiando elementi adiacenti finchè non ne fa un completa senza fare scambi. Il caso peggiore è \(\Theta n^{2}\), ma se l'array è già ordinato fa una sola passata senza fare scambi e si ferma, quindi \(n-1\).
Tutti questi algoritmi, detti elementari, operano in loco e fra essi solo il selection non è stabile.
Nel mergeSort uso il divide et impera e divido per poi mergiare in un modo sensibile, fino ad arrivare all'array con un solo elemento. Usa tanto, spazio ovvero dell'ordine di n. Perchè serve uno spazio theta di n per l'array ausiliario e di log n per lo stack ricorsivo.
Nel quicksort il caso peggiore è \(n^{2}\), circa \(n log n\) nel caso migliore. Anche lui è divide et impera, ma quello che costa tanto è la divisione e infatti il caso migliore è quando viene diviso in due parti di lunghezza simile. In media, impiega \(1.39 n log n\). Quindi il caso peggiore contribuisce molto poco alla media e avviene poco frequentemente. L'algoritmo in sè è in loco, tuttavia c'è lo stack ricorsivo; quindi, nella versione base è su theta di n, ma in quella migliorata del log n
In heapsort il numero di confronti è \(\Theta(n\log n)\), opera in loco e non è stabile.
</p>
</div>
</div>
<div id="outline-container-orgdf9025c" class="outline-2">
<h2 id="orgdf9025c">Limite inferiore ai metodi basati sui confronti</h2>
<div class="outline-text-2" id="text-orgdf9025c">
<p>
Vogliamo rispondere alla domanda: "è possibile ordinare array di \(n\) elementi utilizzando un numero di confronti tra chiavi che cresca meno di \(n\log n\)? No.
Consideriamo un albero di decisione, ovvero un albero in cui i nodi interni sono delle domande con delle risposte binarie. Per alcune domande, questo albero risulta essere abbastanza bilanciato, mentre in altri casi cresce solo da una parte, ad esempio l'albero di ricerca di un array se le domande fossero "è maggiore della metà" o "è questo o no?".
Applichiamo questo concetto  all'ordinamento, iniziando a chiederci se il primo elemento sia minore del secondo. Se rispondessimo sì, dovremmo poi chiederci se il secondo è minore del terzo, e in quel caso avremmo finito, altrimenti rimarebbe da chiederci se il primo è minore del terzo prima che le risposte identifichino univocamente l'ordine. Possiamo fare lo stesso discorso anche nel caso in cui la prima risposta fosse no.
Ogni sequenza diversa di domande termina in una ed una sola foglia, con un valore diverso. Le foglie sono chiaramente \(n!\), perchè corrispondono ad ogni permutazione.
Adesso, io so che l'altezza dell'albero binario è necessariamente maggiore uguale del log2 del numero di nodi (perchè se uno dei lati è minore dell'altezza, l'altro dev'essere maggiore), che è necessariamente maggiore uguale del log2 del numero di foglie (controllare perchè).
Dato che i nodi sono i confronti e le foglie sono le permutazioni, il numero di confronti dev'essere maggiore uguale del log2 di n!.
Ora consideriamo che n! può essere approssimato come \(\sqrt{2\pi n}(\frac{n}{e})^{n}\) (formula di Stirling), e quindi devo calcolare il logaritmo di quella. Considero che il logaritmo di un prodotto è la somma di logaritmi e che il logaritmo di un esponente è l'esponente per il logaritmo. Esce fuori che questa funzione cresce come \(n log n\). Ne segue che ogni algoritmo basato su confronti deve fare un numero di confronti che cresca almeno come questa funzione.
Attenzione al fatto che parliamo del numero di confronti e non del tempo in generale. Il tempo è questo nel caso in cui i confronti richiedano tempo costante.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
C'è una somiglianza in questo concetto fra l'insert nell'insertionSort e lo step partiziona del quickSort. In entrambi, viene selezionato un elemento che viene piazzato nella sua posizione finale, rispetto ad un vettore. Nel primo, la posizione finale è relativa al sotto-vettore degli elementi già ordinati. Nel quickSort, la posizione è sul vettore totale.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2024-11-21 Thu 19:36</p>
</div>
</body>
</html>
