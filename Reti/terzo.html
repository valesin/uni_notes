<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-01-28 Tue 20:16 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Network layer</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Network layer</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org94a2c4e">Network layer</a>
<ul>
<li><a href="#org94292b8">IPv4</a>
<ul>
<li><a href="#orga983849">Formato pacchetto</a></li>
<li><a href="#org261abbd">Frammentazione e ricombinazione</a></li>
<li><a href="#orgaa161a2">Indirizzamento</a>
<ul>
<li><a href="#orge9918b5">Class based</a>
<ul>
<li><a href="#org3233242">Sottoreti</a></li>
</ul>
</li>
<li><a href="#org914c5c4">CIDR (classless)</a></li>
<li><a href="#org92f444d">NAT</a>
<ul>
<li><a href="#orgafe9973">L'ultima questione da risolvere è quella di un server dietro NAT, dato che nessuno conosce la porta che mi porta ad esso.</a>
<ul>
<li><a href="#orga222771">Un modo banale è quello di assegnargli un IP pubblico, ma perdendo i vantaggi dovuti all'utilizzo del NAT.</a></li>
<li><a href="#org650b61c">Un secondo modo è quello di aprire la porta specifica del server. In questo modo, tutte le richieste verso quella porta vengono routate al server in questione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org94a2c4e" class="outline-2">
<h2 id="org94a2c4e">Network layer</h2>
<div class="outline-text-2" id="text-org94a2c4e">
<p>
Questo livello si occupa di <b>indirizzamento</b> e <b>instradamento</b> fra LAN situate in luoghi diversi.
</p>

<p>
A questo livello vi sono varie entità, fra cui <b>IP</b> e il suo sottomodulo <b>OSPF</b> per il routing, e <b>ARP</b> per <b>risolvere</b> l'IP globale nel MAC del datalink.
</p>
</div>
<div id="outline-container-org94292b8" class="outline-3">
<h3 id="org94292b8">IPv4</h3>
<div class="outline-text-3" id="text-org94292b8">
</div>
<div id="outline-container-orga983849" class="outline-4">
<h4 id="orga983849">Formato pacchetto</h4>
<div class="outline-text-4" id="text-orga983849">
<p>
L'intestazione di un pacchetto IPv4 è di 5 parole da 32 bit, più un numero variabile di parole opzionali, fino ad un totale di 15 parole in tutto.
</p>

<p>
Lo header ha questa struttura:
</p>
<ul class="org-ul">
<li>Versione, 4 bit, specifica se è usato IPv4 o 6;</li>
<li>IHL (Intermediate Header Length, 4 bit, contiene il numero di parole nello header;</li>
<li>TOS (Type of Service), 8 bit, contiene il tipo di servizio richiesto per un pacchetto, ad esempio per lo streaming viene fatto in modo di processarlo prima;</li>
<li>Total Length, 16 bit, usato per la ricomposizione dei pacchetti frammentati;</li>
<li>ID pacchetto, 16 bit, per capire quali frammenti appartengono allo stesso pacchetto;</li>
<li>Bit flag, 3 bit, gli ultimi due son <b>non frammentare</b>, quando si vuole trasferire l'intero pacchetto insieme, e <b>più frammenti</b>, usato per capire che quello in arrivo è un frammento e va attaccato agli altri;</li>
<li>Fragment offset, 13 bit, utilizzato per indicare la posizione del primo byte del frammento all'interno del pacchetto originale;</li>
<li>Time to live, 8 bit, il numero di hop rimanenti prima che il pacchetto venga scartato, per evitare continui a girare in un loop infinito;</li>
<li>Protocol selector, 8 bit, per indicare il protocollo di livello 4 a cui va passato il pacchetto;</li>
<li>Header checksum, 16 bit, per scartare i pacchetti invalidi perchè corrotti</li>
</ul>

<p>
Alla quarta e quinta parola ci sono source e destination address, di 32 bit.
</p>
</div>
</div>
<div id="outline-container-org261abbd" class="outline-4">
<h4 id="org261abbd">Frammentazione e ricombinazione</h4>
<div class="outline-text-4" id="text-org261abbd">
<p>
Quando un datagram IP deve viaggiare attraverso una rete la cui <b>MTU (Maximum Transfer Unit)</b> sia minore della dimensione del pacchetto, i router IP devono frammentarlo.
</p>

<p>
Un pacchetto, incluso il suo header, viene diviso in frammenti quanto più grandi possibili.
</p>

<p>
Ogni frammento conterrà <b>lo stesso id</b>, la <b>lunghezza</b> del pacchetto <b>intero</b>, il bit <b>M</b> (More Fragments) settato a \(1\) per tutti i frammenti eccetto l'ultimo in cui è \(0\) e il <b>fragment offset</b> che indica la posizione su \(13 bit\), quindi <b>in multipli di \(8\).</b>
</p>

<p>
La ricombinazione avviene <b>soltanto</b> dagli end system, quindi questi frammenti possono essere divisi ulteriormente per attraversare nuove reti.
</p>

<p>
La frammentazione eccessiva aumenta le probabilità che uno dei frammenti venga perso, innescando la ritrasmissione dell'intero pacchetto, quindi si cerca di evitare il problema limitando la dimensione dei blocchi del TCP.
</p>
</div>
</div>
<div id="outline-container-orgaa161a2" class="outline-4">
<h4 id="orgaa161a2">Indirizzamento</h4>
<div class="outline-text-4" id="text-orgaa161a2">
<p>
Gli indirizzi IP sono composti da un <b>netid</b>, che identifica una rete, e uno <b>hostid</b>, che identifica uno specifico host.
</p>

<p>
I <b>gateway</b> e i <b>router</b> posseggono una <b>netid</b> diversa per ogni interfaccia.
</p>

<p>
Sono state utilizzate 5 diverse strategie per l'assegnamento degli indirizzi.
</p>
</div>
<div id="outline-container-orge9918b5" class="outline-5">
<h5 id="orge9918b5">Class based</h5>
<div class="outline-text-5" id="text-orge9918b5">
<p>
Vi sono 3 classi per l'unicast, ovvero comunicazioni punto-punto, 1 per il multicast e una riservata.
</p>

<p>
Sono differenziate facilmente dalla <b>posizione del primo zero</b> nei primi quattro bit.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Classe</td>
<td class="org-right">Primi bit</td>
<td class="org-right">Netid</td>
<td class="org-right">Hostid</td>
</tr>

<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-right">7</td>
<td class="org-right">24</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">10</td>
<td class="org-right">14</td>
<td class="org-right">16</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-right">110</td>
<td class="org-right">21</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-right">1110</td>
<td class="org-right">28(m.cast)</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">E</td>
<td class="org-right">1111</td>
<td class="org-right">Riservato</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Tutti i bit settati a \(0\) o \(1\) hanno un significato particolare:
</p>
<ul class="org-ul">
<li>hostid a 0 si riferisce alla rete nella parte netid, senza fare riferimento a nessun host</li>
<li>netid a soli 0 indica la rete stessa come origine</li>
<li>entrambi a 1 indicano broadcast sulla rete di origine</li>
<li>hostid a 1 indica broadcast sulla rete di netid</li>
<li>netid a 1 è usato per i test e si chiama *indirizzo di loopback</li>
</ul>

<p>
Quando un router capisce che la netid non è la propria, non passa alla lettura dello hostid ma instrada immediatamente il pacchetto.
</p>

<p>
Questo sistema soffre di <b>frammentazione interna</b>. Molti hostid sotto un certo netid sono <b>inutilizzati</b>.
</p>
</div>
<div id="outline-container-org3233242" class="outline-6">
<h6 id="org3233242">Sottoreti</h6>
<div class="outline-text-6" id="text-org3233242">
<p>
Secondo il sistema originario, ad ogni router dovrebbe essere associato un netid e dovrebbe partecipare all'instradamento in Internet, rendendolo meno efficiente.
</p>

<p>
Inoltre, il gateway non ha modo di inviare un pacchetto verso l'host in modo efficiente, ma può solo affidarlo alla rete interna.
</p>

<p>
Viene quindi utilizzata la tecnica del <b>subnetting</b>, che consiste nel riservare una parte dello hostid per definire delle <b>reti interne</b>.
</p>

<p>
I router interni, chiamati <b>router di sottorete</b>, sono separati da ciò che si trova oltre il gateway.
</p>

<p>
Quando il gateway riceve un pacchetto, applica una <b>address mask</b> che contiene \(1\) nelle posizioni che contengono netid e subnetid e \(0\) nella parte dello hostid.
</p>

<p>
In questo modo, recupera l'indirizzo del router d'accesso per la specifica subnet, che poi si occuperà di smistare il pacchetto allo host desiderato.
</p>
</div>
</div>
</div>
<div id="outline-container-org914c5c4" class="outline-5">
<h5 id="org914c5c4">CIDR (classless)</h5>
<div class="outline-text-5" id="text-org914c5c4">
<p>
Questo sistema è simile al sistema delle subnets.
</p>

<p>
Ad ogni rete, parte di una rete più grande, viene assegnato un <b>blocco di indirizzi</b> grande \(2^n\).
</p>

<p>
Quindi, gli ultimi \(n\) bit rappresentano lo <b>hostid</b>, mentre i primi \(32-n\) il <b>netid</b>.
</p>

<p>
La mask ha i bit corrispondenti alla <b>netid</b> settati a \(1\) e il resto a \(0\).
</p>

<p>
Ogni router contiene una tabella <b>mask-netid</b>.
</p>

<p>
Quando arriva un pacchetto, effettua l'AND logico fra l'indirizzo di destinazione del pacchetto e ognuna delle mask. Se il risultato è esattamente il netid associato, instrada verso tale rete.
</p>

<p>
CONTROLLARE CASI DI COLLISIONE PER RETE MINORE, ES 6.4
</p>
</div>
</div>
<div id="outline-container-org92f444d" class="outline-5">
<h5 id="org92f444d">NAT</h5>
<div class="outline-text-5" id="text-org92f444d">
<p>
Per introdurre un rimedio temporaneo alla carenza di indirizzi IP, viene introdotto questo nuovo sistema.
</p>

<p>
Il <b>Network Address Translation</b> è un metodo per mappare uno spazio di indirizzi IP in un altro.
</p>

<p>
In particolare, ad ogni rete di un organizzazione viene associato <b>un solo IP</b>, con un gateway d'accesso che cattura tutte le richieste in entrata e le smista agli host.
</p>

<p>
Gli host degli IP validi <b>soltanto all'interno</b> della rete e sono i seguenti:
</p>
<ul class="org-ul">
<li>\(10.0.0.0/8\)</li>
<li>\(172.16.0.0/12\)</li>
<li>\(192.168.0.0/16\)</li>
</ul>

<p>
Gli host spediscono i pacchetti in modo standard. Il gateway, attraverso cui devono necessariamente passare, <b>traduce</b> gli header sia IP che TCP così che nel pacchetto appaia il gateway stesso come origine e stessa destinazione.
</p>

<p>
Inoltre, il gateway <b>salva</b> l'associazione <b>IP-PortaTCP di Origine/IP-PortaTCP di destinazione</b> all'interno della <b>tabella NAT</b>.
</p>

<p>
La porta TCP del gateway è generata in modo da essere <b>univoca</b> per ogni processo.
</p>

<p>
Quando il server risponde, egli indirizza il pacchetto al gateway, che controlla a quale host interno fosse associata la coppia IP-Tcp del server e vi instraderà il pacchetto ricevuto.
</p>

<p>
Questa organizzazione fa crollare la separazione gerarchica, in quanto i gateway d'accesso devono modificare non solo lo header di terzo livello, ma anche di quarto.
</p>

<p>
Il NAT offre garanzie in termini di sicurezza, facendo anche da firewall.
</p>

<p>
VEDERE COSA FARE QUANDO UN SERVER é DIETRO NAT
</p>
</div>
<div id="outline-container-orgafe9973" class="outline-6">
<h6 id="orgafe9973">L'ultima questione da risolvere è quella di un server dietro NAT, dato che nessuno conosce la porta che mi porta ad esso.</h6>
<div class="outline-text-6" id="text-orgafe9973">
</div>
<div id="outline-container-orga222771" class="outline-7">
<h7 id="orga222771">Un modo banale è quello di assegnargli un IP pubblico, ma perdendo i vantaggi dovuti all'utilizzo del NAT.</h7>
</div>
<div id="outline-container-org650b61c" class="outline-7">
<h7 id="org650b61c">Un secondo modo è quello di aprire la porta specifica del server. In questo modo, tutte le richieste verso quella porta vengono routate al server in questione.</h7>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-01-28 Tue 20:16</p>
</div>
</body>
</html>
