<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-20 Wed 19:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retibozza</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Retibozza</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd5285cb">References</a></li>
<li><a href="#org505c367">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org86d3446">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgaa55ef9">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org2e2d662">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org03a93e0">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org18de7f9">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgfe811fe">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org66ccbb2">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org6b7b1a2">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.</a>
<ul>
<li><a href="#org0724389">Il vantaggio è pulizia del codice&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org9a27072">I protocolli dal livello 4 in su, sono end-to-end.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org4e43282">Il livello 2 si occupa di mandare i bit direttamente al livello 1, che poi manderà al cavo</a>
<ul>
<li><a href="#org861da22">Bisogna far capire al livello fisico quale sequenza di bit, ovvero quali tensioni (Volt), fanno parte di uno specifico pacchetto e non dello stato di IDLE, stessa cosa per la fine.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org36df067">Il livello 2 può essere progettato in modo affidabile, sebbene nelle reti moderne non sia il caso.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9e053ab">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org24f4723">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.</a>
<ul>
<li><a href="#org7fb712a">In una LAN (local a.. network) la rete è broadcast, ovvero c'è un dispositivo che comunica a tutti gli altri, compreso quello da cui ha ricevuto il segnale in entrata. Ovvero un HUB, chiamato anche <b>centro stella passivo</b></a></li>
<li><a href="#orgb79283a">Un terzo modo, che è come ethernet era fatto inizialmente, si ha una struttura a bus lineare, in cui tutti i dispositivi sono collegati in serie. Sia questa che la seconda sono chiamate <b>broadcast</b>.</a></li>
<li><a href="#orgffb34c6">Il problema delle strutture broadcast è innanzitutto quello di creare l'equivalente semantico di una comunicazione fra due soli dispositivi, e si fa utilizzando header di mittente e destinatario, così che nel secondo driver di IO capiscono se salvano o buttano via i dati.</a></li>
<li><a href="#orgeb2c5f4">Un altro problema è che trasmettere sull'hub o su bus lineare è critico e va quindi garantita la mutua esclusività per l'accesso a canale condiviso: non tutti i dispositivi possono trasmettere nello stesso momento.</a>
<ul>
<li><a href="#org76665c1">Si può sfruttare un token unico e condiviso dalle stazioni. La struttura è fatta ad anello e chi lo riceve, lo estrae e trasmette. Una volta che la trasmissione torna al primo dispositivo, vuol dire che la comunicazione è arrivata a tutti e cede il token ad un altro.</a></li>
<li><a href="#org811dcba">Ethernet utilizza, invece, una soluzione <b>non deterministica</b>, fuzzy, in cui c'entra molto la probabilità ed in cui le collisioni sono ammesse, chiamato CSMA-CD.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6f4dd19">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0</a>
<ul>
<li><a href="#org671ccc2">Con ethernet, però, abbiamo vari problemi. Uno è quello di disambiguare sequenze di bit uguali, un'altra è quella di far arrivare il valore in modo chiaro al ricevitore.</a>
<ul>
<li><a href="#orged8f1fe">Ethernet utilizza quindi la codifica Manchester, che a differenza del solito, legge nel momento centrale del bit, che è il punto meno soggetto a distorsione.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge4878c5">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)</a>
<ul>
<li><a href="#org9b3727e">Si dimostra che al tendere delle stazioni K all'infinito, 1/A tende a "e".</a></li>
<li><a href="#orge6ad084">Inoltre, si ricorda che abbiamo definito tx come dimFrame/velBanda e tp come Lunghezza/velCavo.</a>
<ul>
<li><a href="#org9c7c372">Allora divido tutto per tx e ottengo \(\frac{1}{1+2 \frac{BL}{CF}e }\). Quindi, all'aumentare della banda e della lunghezza, l'utilizzo diminuisce di tanto.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfc4186c">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.</a>
<ul>
<li><a href="#orgbc30a05">Una soluzione immediata sarebbe quella di usare 4 fili e dividere un bit in ognuno. In realtà, se ne usano solo 3 per la trasmissione, perchè il 2 è quello usato per CarrierSense e CollisionDetection.</a></li>
<li><a href="#org3107956">Come si raggiungono 1000Mbit, con solo 3 fili da 25Mbps? Si usa una codifica diversa, ternaria non binaria, chiamata 8B6T, ovvero "mappo 8 bit Binari su 6 Ternari".</a>
<ul>
<li><a href="#org0b0e82f">A questo punto abbiamo 100 * 10<sup>6</sup> Mbit *6/8 diviso i 3 fili, ottengo 25 bit ternari per filo, che corrispondono a 33 binari.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdd26f6b">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.</a>
<ul>
<li><a href="#org162561e">flading, broadcast ma senza restituire alla porta da cui è arrivato.</a></li>
<li><a href="#orgc8dee6e">Un problema è che se un dispositivo, con un certo MAC address, si sposta da un dominio all'altro, la tabella non è più valida. Ogni entrata deve quindi avere un timer, Il flading è quindi parte integrante dell'apparato</a></li>
</ul>
</li>
<li><a href="#org1beaf19">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.</a></li>
<li><a href="#org5203be9">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.</a>
<ul>
<li><a href="#org6690313">E' stato deciso, in sede di standard, ogni tratta deve essere grande al massimo 200 metri, quindi 800 metri in tutto al massimo ( per andare sulle 2 tratte e tornare sulle stesse).</a>
<ul>
<li><a href="#orgb183472">Su 800 metri, il tempo andata e ritorno è circa 4ms. Con 1Gbit, esce fuori 4000bit, ovvero 500bit, arrotondati a 512B.</a></li>
<li><a href="#orgf72fa74">Se si fosse lasciato il tempo di 51.2 microsecondi, avremmo dovuto mandare 51200 bit per ogni minimo frame e sarebbe stato poco efficiente. Viene quindi ridotto il diametro, e anche la dimensione dei frame.</a></li>
<li><a href="#org98d800d">Per evitare di cambiare anche la porta MAC, che fa il padding di solo 64Byte, il padding viene fatto a livello fisico.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgba50667">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.</a>
<ul>
<li><a href="#org24c85c6">C'è, però, anche un'interfaccia aggiuntiva, posizionata appena sopra il MAC, ma sempre a livello 2, chiamata <b>Logical Link Control</b>.</a></li>
<li><a href="#orgd6b7334">Quello che facciamo con questo sottolivello serve a creare dei canali logici punto-punto fra sè e le altre stazioni.</a>
<ul>
<li><a href="#org0153319">Quindi, a livello MAC gestisco la situazione Broadcast, e nel Logical Link Control, creo una sovrastruttura logica che modella i collegamenti come punto-punto. In questo modo, dal Logical Link Control in sù, ignoro qualunque ragionamento riguardo il MAC e le sue operazioni.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org79ea486">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.</a>
<ul>
<li><a href="#org9025242">Stazioni che fanno parte di VLAN diverse, non possono comunicare fra loro, anche se fanno parte dello stesso hub. Serve uno switching intelligente per attivare questa funzione, perchè di base le comunicazioni sullo stesso hub girano liberamente</a></li>
<li><a href="#orgcaa54d6">Per permettere a macchine appartenenti a VLAN diversi, è necessario utilizzare il routing di livello 3, perchè la separazione introdotta, sebbene logica, è finale.</a>
<ul>
<li><a href="#org9fd1819">Gli switch avanzati posseggono una funzione di routing incorporata</a></li>
</ul>
</li>
<li><a href="#org7e00152">Le informazioni riguardo le VLAN sono contenute nello switch, che <b>tagga</b> le porte e le frame a esse corrispondenti</a>
<ul>
<li><a href="#org8ff5ee4">Quindi, le stazioni mandano i soliti frame 802.3, e lo switch si occupa di taggarli e smistarli secondo un nuovo standard, chiamato 802.1Q</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org20f461f">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.</a>
<ul>
<li><a href="#org5eb7194">Convergence sublayer e Physical-medium dependent layer per il physical layer, il cui primo serve per separare ulteriormente il livello fisico finale, che è fortemente dipendente dall'architettura</a></li>
<li><a href="#org1cbd3f2">LLC(Logical Link Control) e MAC(Multiple Access Control), il cui primo si occupa di rendere trasparente la gestione complicata del CSMA-CD da parte del MAC, gestendo apparentemente le connessioni come punto-punto.</a></li>
</ul>
</li>
<li><a href="#orgc696cca">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.</a>
<ul>
<li><a href="#org9570606">Chiaramente, il MAC address smette di avere valore, su questa scala, e viene introdotto l'IP, che identifica univocamente qualunque stazione appartenente a qualunque LAN.</a></li>
<li><a href="#org9994e9c">Nell'andare da una stazione ad un altra, quindi da un livello Application all'altro, attraversiamo un numero indefinito di macchine che operano al massimo a livello 3. Ognuna di esse deve occuparsi dell'Addressing, ovvero come gestire l'univocità dell'IP, ed il routing, ovvero come trovare una strada fra le stazioni in modo efficiente.</a></li>
<li><a href="#orgf13356c">Nel livello 3 non c'è solo un entità, ma 5, di cui analizzeremo due e IP in particolare, con il suo sottomodulo OSPF, per il routing. L'altro è ARP, con cui si mappa/risolve l'IP globale nel MAC.</a></li>
</ul>
</li>
<li><a href="#orgde12ffb">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.</a>
<ul>
<li><a href="#org5d57a51">Il formato di un pacchetto IP è formato da 5 parole (ovvero 4 byte, 32 bit) ed un ultimo spazio opzionale, utilizzato ad esempio per il source routing.</a>
<ul>
<li><a href="#orgbe11548">Il primo campo è quello versione, che occupa i primi 4 bit e indica la versione del protocollo, di cui ne esistono due, la v4 e la v6.</a></li>
<li><a href="#orgd95f6f7">Dopodichè c'è la header length, che occupa altri 4 bit e specifica quanti byte è lungo l'header. Serve nel caso in cui il campo option venga utilizzato, perchè ha lunghezza variabile.</a></li>
<li><a href="#org13613c0">Gli 8 bit successivi sono occupati dal Type Of Service (TOS),</a></li>
<li><a href="#org4d627bf">I successivi 16 bit che completano la parola riguardano la Total Length, che quindi può arrivare a \(2^{16}\).</a></li>
<li><a href="#orgfe9e274">Nella prossima parola, si inizia con 16 bit per l'ID, seguito da 3 bit, di cui il primo vuoto per futuro uso e due bit chiamati D (Do not fragment) e M (More fragment)</a></li>
<li><a href="#orga320c37">Poi ci sono i restanti 13 bit della parola, che si chiama Fragment Offset</a></li>
<li><a href="#orgef09eed">Nella terza parola, i primi 8 bit sono un timestamp, TTL (Time to live).</a></li>
<li><a href="#orga023225">Il secondo campo di 8 bit si chiama Protocol selector.</a></li>
<li><a href="#orgb6bfaee">I restanti 16 sono di Header Checksum</a></li>
<li><a href="#orge2cc1a2">Nella quarta e quinta parola troviamo rispettivamente il Source e il Destination address, che quindi sono di 32 bit ognuno.</a></li>
</ul>
</li>
<li><a href="#orge6baf63">Immaginiamo di avere due stazioni che comunicano, passando attraverso vari gateway, che collegano stazioni attraverso tecnologie diverse.</a>
<ul>
<li><a href="#org320fcd3">Ad esempio, immaginiamo che la source esca con un ring, con un limite di 4000 byte per frame, passi per due gateway, di cui il secondo è collegato ethernet, con un limite di 1500 byte per frame alla stazione di arrivo.</a></li>
</ul>
</li>
<li><a href="#org60fa352">L'indirizzamento avviene attraverso l'IP address, che consiste in 4 sequenze di 8 bit, di cui viene rappresentato il valore decimale.</a>
<ul>
<li><a href="#org47b83cd">L'indirizzo IP è unico a livello globale. Esiste un organismo internazionale, chiamato ICANN, ovvero "&#x2026; for Name and Numbers" e se voglio assegnare un nome al mio dispositivo, devo chiedere a loro.</a></li>
<li><a href="#orgcb7a260">Abbiamo 5 modalità di addressing:</a></li>
<li><a href="#org84ca1be">Nel CLASS based, esistono 3 classi diverse, che gestiscono trasmissioni Unicast, ovvero punto-punto.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7d46abf">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.</a>
<ul>
<li><a href="#org77a453e">Gli altri metodi, CIDR e NAT, sono usati per superare il problema della frammentazione interna degli IP e aumentare la longevità di IPv4.</a>
<ul>
<li><a href="#org64e0d24">Prima o poi, gli indirizzi a 32 bit di v4 finiranno, e saremmo costretti a utilizzare i 128 bit del IPv6.</a></li>
<li><a href="#org37c50a5">CIDR sta per Classless Inter Domain Routing e invece di dividere in classi, lo fa in blocchi autonomi e indipendenti, geografici (europeo, nord-americano, asiatico, ecc.).</a></li>
<li><a href="#org5c01f94">Il NAT estende ulteriormente la vita di IPv4.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org86ec868">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.</a>
<ul>
<li><a href="#org64da834">A livello 2, in una rete CSMA-CD l'indirizzo è il MAC</a></li>
<li><a href="#orgd1694b2">A livello 3, l'indirizzo è quello IP, con tutte le considerazioni fatte in precedenza.</a></li>
<li><a href="#org0c93ff9">Un problema che dobbiamo risolvere è quello di mappare l'IP al corrispondente MAC.</a>
<ul>
<li><a href="#org0a872c3">Infatti, finora non c'è nessun modo per far arrivare un pacchetto a destinazione.</a></li>
</ul>
</li>
<li><a href="#org4bac8d9">Immaginiamo che A e B siano sulla stessa rete locale.</a>
<ul>
<li><a href="#orga7c7b65">Se la macchina A manda un pacchetto al modulo B, chiede ad ARP di risolvere l'IP in un MAC address, così che possa mandarglielo attraverso il livello 2</a></li>
<li><a href="#orgdf71b8f">In pratica l'ARP, per conto di IP, manda ai livelli sottostanti una richiesta, ARPRequest, così che il dispositivo in questione risponda con un ARPReply, rispondendo con il proprio MAC, che ARP fornirà al livello IP della macchina sorgente.</a></li>
</ul>
</li>
<li><a href="#org29c3c47">Immaginiamo adesso che siano su macchine diverse.</a>
<ul>
<li><a href="#org89cea23">A manda richiesta a Z, su un'altra rete.</a></li>
<li><a href="#orgb048fb4">Il site access gateway leggerà il NETID e vedrà che non appartiene alla rete locale e che quindi va cercato al di fuori. Prenderà lui in carico l'operazione.</a></li>
<li><a href="#org1ae2431">A questo punto, risponderà con il proprio MAC, in modo che A mandi le richieste al gateway.</a></li>
<li><a href="#org582c90d">Il gateway aspetterà autonomamente per la ARPReply della macchina remota e salverà il risultato.</a></li>
<li><a href="#org7a59f9d">Questo servizio si chiama ProxyARP.</a></li>
</ul>
</li>
<li><a href="#org592e167">ARP in ogni dispositivo terrà una ARP Cache, in cui salverà tutte le associazioni IP-MAC, così che le volte successive non servirà una nuova richiesta.</a></li>
<li><a href="#org5bfd65a">Quindi uso ARP per fare una discovery delle macchine che sono raggiungibili in rete.</a></li>
<li><a href="#orgdf1f7ae">Anche in questo caso, abbiamo un livello 3 che per funzionare (anzi, il suo obiettivo) è di livello 2. Deve infatti andare a toccare il MAC, indirizzo di livello 2, ma in questo caso almeno fa una richiesta</a></li>
<li><a href="#org4a298e9">Notiamo che nello header di livello 3, il campo type è usato anche per identificare se la richiesta sia IPv4 o ARP</a></li>
</ul>
</li>
<li><a href="#orge00ce99">Introduciamo il DHCP</a>
<ul>
<li><a href="#org5686374">Abbiamo tante macchine collegate ad una LAN, che possono essere nostre oppure di ospiti che arrivano transitoriamente. Come assegniamo l'IP privato alle macchine?</a>
<ul>
<li><a href="#orga935691">La LAN potrebbe essere Wireless, collegata tramite un Access Point ad una Lan fisica, che tramite il suo Access Gateway è collegata alla rete fisica.</a></li>
</ul>
</li>
<li><a href="#org85cb77f">Il Gateway riesce a fare Address Resolution e quindi è anche un NAT. Ovvero, riesce a mascherare un indirizzo interno.</a>
<ul>
<li><a href="#orgd0ca839">Ci presenta con un IP pubblico alla rete, ma poi smista alle macchine singole con gli indirizzi privati.</a></li>
</ul>
</li>
<li><a href="#org2c39652">Questi indirizzi potrebbero esere statici, ma questo è scomodo. (Perchè?).</a></li>
<li><a href="#orge84963a">E' più comodo se al momento della prima connessione alla rete, venga assegnato un IP dinamico al dispositivo, che rimanga fino allo spegnimento.</a></li>
<li><a href="#org052b5f2">Per assegnare l'IP dinamico, usiamo il server DHCP (eventualmente molteplici)</a>
<ul>
<li><a href="#orgcd8b6a0">Appena una macchina cliente viene bootata, fa un operazione di Request DHCP al server, che farà a sua volta una Reply.</a></li>
<li><a href="#org58d3602">La reply assegna un IP privato, valido per tutto il tempo necessario.</a></li>
<li><a href="#org4dc09d3">La RequestForComment che lo definisce è la 2131.</a></li>
<li><a href="#org958e736">Il client triggera la richiesta, che nello specifico si chiama DHCP Discover.</a></li>
<li><a href="#org9c9bed0">Il server riceve la richiesta e reagisce con una DHCP Offer.</a></li>
<li><a href="#orgeddf2be">A questo punto il client ha <b>apparentemente</b> risolto il suo problema.</a></li>
<li><a href="#orgf4b09fb">Diventa necessaria un ulteriore fase, una commit, chiamata DHCP Request.</a></li>
<li><a href="#org0084fdb">A questo punto, si chiude il commitment con una DHCP Ack, che è una validazione della request. Anche questo è mandato in broadcast secondo IP.</a></li>
<li><a href="#org04cf0aa">Questo protocollo è un protocollo a 4 vie, a causa della necessità di selezionare fra i vari server.</a></li>
<li><a href="#org1b9f7fd">Servono inoltre dei check per verificare la validità degli IP, anche dal punto di vista del client.</a></li>
<li><a href="#org14c8bf8">Esistono dei meccanismi di ricovero, per gestire i casi in cui i messaggi vengano persi. Si utilizza ad esempio un timer T, che viene eseguito massimo K volte (numero di retry). Una volta aver provato K volte, si ritorna alle origini e si ricomincia da capo.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3ecd6eb">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).</a></li>
<li><a href="#org6630d15">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente</a>
<ul>
<li><a href="#orgdfb60be">Immaginiamo di avere due macchine con porte I/O e un forwarder in mezzo, che contiene una tabella e fa un lookup per capire su quale porta trasmettere il messaggio entrato.</a>
<ul>
<li><a href="#org9187319">A livello 2, questo è fatto dal bridge, che popola e spopola le tabelle periodicamente per lasciar spostare le macchine.</a></li>
<li><a href="#org5ad9879">Se saliamo di un piano, quello che cambia radicalmente è che non è più vero che la macchina destinazione sia attaccata al link. La validità di un forwarding livello 2, a livello 3 non è più sufficiente.</a></li>
</ul>
</li>
<li><a href="#orgacb8cb7">A livello 3, la tabella viene popolata da un secondo processo, che chiamiamo <b>router</b>, che lavora con i suoi pacchetti di controllo, utili soltanto a lui, tramite i quali impara la topologia della rete e popola la tabella in modo da permettere di raggiungere ogni host in un modo efficiente, possibilmente il cammino minimo.</a>
<ul>
<li><a href="#org08337b9">La cosa interessante è che abbiamo una separazione netta fra tutto ciò che è gestione dei dati utente e la gestione di controllo di tutto ciò che serve alla rete autonomamente perchè funzioni.</a></li>
<li><a href="#org8d4620f">Con il routing questa diventa chiara.</a></li>
</ul>
</li>
<li><a href="#org5b2d892">Il router opera attraverso 3 tecniche:</a>
<ul>
<li><a href="#orgd3973a2">Il protocollo con Distance vector opera assegnando due etichette con numero del link e corrispondente peso su ogni arco bidirezionale.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org72f623e">TO BE FILLED WITH 3 LESSONS</a></li>
<li><a href="#orgf65a208">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).</a>
<ul>
<li><a href="#org69a7402">Offre dei servizi che abbiamo già visto nel data-link.</a></li>
<li><a href="#orgf830bd3">Varie funzionalità possono essere attivate o disattivate.</a></li>
<li><a href="#org23e9d7b">TCP e UDP sono ortogonali fra loro. La prima offre disponibilità, mentre la seconda è best-effort e non aggiunge nulla ai livelli superiori.</a></li>
<li><a href="#orga3237f3">A livello data-link, tra due porte di rete abbiamo una trasmissione può essere affidabile, avere controllo degli errori ecc.</a>
<ul>
<li><a href="#org69798e2">Quello che non è considerato a livello data-link è se qualcosa va perso a livello network.</a></li>
</ul>
</li>
<li><a href="#org628bbd1">In Transport viene riimplementata l'affidabilità in modo che quando un segmento venga perso, venga gestita la ritrasmissione.</a>
<ul>
<li><a href="#org2957d96">La trasmissione su cavo è molto affidabile e quindi l'affidabilità a livello data link è passata in secondo piano e diventa più importante quella su tratte più lunghe, con tutta la rete in mezzo, che coinvolgono i router di livello 3.</a></li>
</ul>
</li>
<li><a href="#org820d2ca">Le unità base di comunicazione a livello 4 sono chiamate <b>messaggi</b> o <b>segmenti</b>.</a></li>
<li><a href="#org6aee2bc">Il livello di trasporto ha anche un suo indirizzamento (naming) utilizzando le porte, che servono per identificare l'applicazione che sta utilizzando il collegamento di livello 4.</a>
<ul>
<li><a href="#org38a0477">Mentre l'indirizzo IP serve per identificare l'host di rete</a></li>
<li><a href="#org9fd84cf">Immaginiamo di avere un client ed un server con TCP o UDP a livello 4, IP sotto e poi una rete completamente trasparente.</a></li>
<li><a href="#orgf149b7b">A livello di Trasporto si usano le socket.</a></li>
<li><a href="#orgd4bd902">Il TCP garantisce che la comunicazione sia <b>affidabile</b> e <b>ordinata</b>.</a></li>
<li><a href="#orgcdb1ac6">Lo header TCP è rappresentato in pagine larghe 32 bit.</a></li>
<li><a href="#orge718e2f">Come si diceva, TCP è orientato alla connessione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd5285cb" class="outline-2">
<h2 id="orgd5285cb">References</h2>
<div class="outline-text-2" id="text-orgd5285cb">
<p>
<a href="https://computer.howstuffworks.com/ethernet.htm">How Ethernet works</a>
<a href="https://intronetworks.cs.luc.edu/1/html/index.html">Exercises from Chicago University</a>
</p>
</div>
</div>
<div id="outline-container-org505c367" class="outline-2">
<h2 id="org505c367">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org86d3446" class="outline-2">
<h2 id="org86d3446">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-orgaa55ef9" class="outline-2">
<h2 id="orgaa55ef9">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org2e2d662" class="outline-2">
<h2 id="org2e2d662">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org03a93e0" class="outline-2">
<h2 id="org03a93e0">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org18de7f9" class="outline-2">
<h2 id="org18de7f9">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgfe811fe" class="outline-2">
<h2 id="orgfe811fe">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org66ccbb2" class="outline-2">
<h2 id="org66ccbb2">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org6b7b1a2" class="outline-2">
<h2 id="org6b7b1a2">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.</h2>
<div class="outline-text-2" id="text-org6b7b1a2">
</div>
<div id="outline-container-org0724389" class="outline-3">
<h3 id="org0724389">Il vantaggio è pulizia del codice&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h3>
</div>
<div id="outline-container-org9a27072" class="outline-3">
<h3 id="org9a27072">I protocolli dal livello 4 in su, sono end-to-end.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h3>
</div>
<div id="outline-container-org4e43282" class="outline-3">
<h3 id="org4e43282">Il livello 2 si occupa di mandare i bit direttamente al livello 1, che poi manderà al cavo</h3>
<div class="outline-text-3" id="text-org4e43282">
</div>
<div id="outline-container-org861da22" class="outline-4">
<h4 id="org861da22">Bisogna far capire al livello fisico quale sequenza di bit, ovvero quali tensioni (Volt), fanno parte di uno specifico pacchetto e non dello stato di IDLE, stessa cosa per la fine.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h4>
</div>
<div id="outline-container-org36df067" class="outline-4">
<h4 id="org36df067">Il livello 2 può essere progettato in modo affidabile, sebbene nelle reti moderne non sia il caso.</h4>
<div class="outline-text-4" id="text-org36df067">
</div>
<ul class="org-ul">
<li><a id="org189d9d7"></a>Ricordiamo che in una rete affidabile, voglio garantire che la comunicazione sia avvenuta e sia stata ricevuta.<br />
<ul class="org-ul">
<li><a id="org7cfdf54"></a>Per farlo, utilizzo un ACK di risposta che spiega che il ricevitore abbia ricevuto il frame.<br />
<ul class="org-ul">
<li><a id="orge29748b"></a>Dopo un tempo t, dimensionato in base al delay di trasmissione e di "creazione", si assume che il frame non sia stato ricevuto e si rimanda.<br /></li>
</ul>
</li>
<li><a id="orga67cc61"></a>Esistono due casi in cui la comunicazione non può essere considerata affidabile, ovvero se il frame sia perso, oppure se l'ACK sia perso.<br />
<ul class="org-ul">
<li><a id="org360bf6b"></a>Nel primo caso, banalmente lo rimando e il problema è risolto<br /></li>
<li><a id="org02770c7"></a>Nel secondo il sender manda due volte il pacchetto e il receiver dovrà capire che quello è un duplicato e non va mandato a livello 3 ma discardato<br /></li>
<li><a id="org8cab06a"></a>Per rendere il livello 2 affidabile, sfrutto due variabili, variabile send e variabile receive, che vengono incrementate ad ogni trasmissione ricevuta dall'altro lato che rispetta certi criteri.<br />
<ul class="org-ul">
<li><a id="org4046926"></a>Quando il sender non riceve l'ACK, rimanda il frame senza aggiornare la variabile, che era però già stata incrementata dal receiver.<br />
<ul class="org-ul">
<li><a id="org3326669"></a>Il receiver riceverà un ACK outdated e dovrà quindi ignorare il pacchetto ricevuto, rispedendo la validazione con il suo attuale numero di variabile (maggiore di uno rispetto al sender), che il sender eventualmente riceverà, procedendo nella trasmissione.<br /></li>
</ul>
</li>
<li><a id="orgf911615"></a>Se l'ACK arriva, ma in ritardo rispetto al tempo massimo previsto, la variabile sender si aggiornerebbe, ma il nuovo frame sarebbe già partito. Il receiver lo butta e rimanda l'ACK. Il sender riceve l'ACK e lo butta, perchè l'aveva già ricevuto.<br /></li>
<li><a id="orgfe549e1"></a>Il criterio secondo cui aggiorno è che il sender vuole ricevere l'ACK dello stesso suo livello e il receiver vuole ricevere un frame dello stesso suo livello.<br />
<ul class="org-ul">
<li><a id="org209c1c4"></a>Se l'ACK che torna è di un livello superiore, allora il receiver aveva già ricevuto il pacchetto e non mi serve<br /></li>
<li><a id="org56015bf"></a>Se il frame che arriva al receiver è di livello inferiore al proprio, quel pacchetto è stato già ricevuto e non serve<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="orgacc3cd7"></a>Questo modello è affidabile e si basa sul fatto che entrambi i nodi in comunicazione posseggano istanze della stessa macchina a stati con lo stesso funzionamento, in modo che possano essere sincronizzate.<br /></li>
</ul>
</li>
<li><a id="orgb698796"></a>Questo sistema è inefficiente, perchè aspetta un tempo T per ogni pacchetto.<br />
<ul class="org-ul">
<li><a id="org3ede5d4"></a>Riguardo la definizione, tx è il tempo necessario per la porta I/O per immettere la sequenza sul filo. Durante il tempo tx, la nostra macchina non riesce a ottimizzare.<br /></li>
<li><a id="org86b1f09"></a>Quello su cui possiamo lavorare è il tempo tp.<br /></li>
<li><a id="org1a218c4"></a>Potrei mandare una serie di frame ogni tx, anche se il ricevitore non abbia ancora avuto modo di ricevere il pacchetto di precedente, nè di mandarmi l'ACK.<br />
<ul class="org-ul">
<li><a id="org8dc6d6d"></a>Infatti, immaginiamo di avere un canale a 1Mbps su un cavo di 2km con frame di 1000 bit.<br />
<ul class="org-ul">
<li><a id="orgece98df"></a>Allora tx, ovvero il tempo necessario all'IO per immettere il frame è di 1000 su 1000000 ovvero 1 msec<br /></li>
<li><a id="orgedc6ca4"></a>Tp invece, è lunghezza su velocità, che assumendo il cavo sia di rame, viene 10microsec<br /></li>
</ul>
</li>
<li><a id="org6308e03"></a>Il tempo di propagazione è di due ordini di grandezza minore di quello di trasmissione<br /></li>
<li><a id="org6c99537"></a>Definiamo l'utilizzo U di un canale come \(\frac{tx}{tx+2tp}\), ovvero il tempo che serve all'io per trasmettere rispetto al tempo totale che il frame impiega per arrivare ed essere confermato tramite ACK.<br /></li>
<li><a id="org4248704"></a>Allora, nell'esempio superiore, l'utilizzo è di circa 98%.<br /></li>
<li><a id="org5c3cab5"></a>Se invece la distanza diventasse 200km, l'utilizzo diventerebbe del 30%, ovvero molto efficiente.<br /></li>
</ul>
</li>
<li><a id="org63d2bc3"></a>Introduciamo i protocolli a finestra, che definiscono un numero di frame da inviare nella finestra temporale che va dall'invio del primo frame alla ricezione dell'ACK.<br /></li>
<li><a id="org1ed5a4d"></a>L'utilizzo del canale aumenta secondo un fattore di K, dove K è il numero di frame in una finestra.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9e053ab" class="outline-2">
<h2 id="org9e053ab">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org24f4723" class="outline-2">
<h2 id="org24f4723">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.</h2>
<div class="outline-text-2" id="text-org24f4723">
</div>
<div id="outline-container-org7fb712a" class="outline-3">
<h3 id="org7fb712a">In una LAN (local a.. network) la rete è broadcast, ovvero c'è un dispositivo che comunica a tutti gli altri, compreso quello da cui ha ricevuto il segnale in entrata. Ovvero un HUB, chiamato anche <b>centro stella passivo</b></h3>
</div>
<div id="outline-container-orgb79283a" class="outline-3">
<h3 id="orgb79283a">Un terzo modo, che è come ethernet era fatto inizialmente, si ha una struttura a bus lineare, in cui tutti i dispositivi sono collegati in serie. Sia questa che la seconda sono chiamate <b>broadcast</b>.</h3>
</div>
<div id="outline-container-orgffb34c6" class="outline-3">
<h3 id="orgffb34c6">Il problema delle strutture broadcast è innanzitutto quello di creare l'equivalente semantico di una comunicazione fra due soli dispositivi, e si fa utilizzando header di mittente e destinatario, così che nel secondo driver di IO capiscono se salvano o buttano via i dati.</h3>
</div>
<div id="outline-container-orgeb2c5f4" class="outline-3">
<h3 id="orgeb2c5f4">Un altro problema è che trasmettere sull'hub o su bus lineare è critico e va quindi garantita la mutua esclusività per l'accesso a canale condiviso: non tutti i dispositivi possono trasmettere nello stesso momento.</h3>
<div class="outline-text-3" id="text-orgeb2c5f4">
</div>
<div id="outline-container-org76665c1" class="outline-4">
<h4 id="org76665c1">Si può sfruttare un token unico e condiviso dalle stazioni. La struttura è fatta ad anello e chi lo riceve, lo estrae e trasmette. Una volta che la trasmissione torna al primo dispositivo, vuol dire che la comunicazione è arrivata a tutti e cede il token ad un altro.</h4>
<div class="outline-text-4" id="text-org76665c1">
</div>
<ul class="org-ul">
<li><a id="org4e80f34"></a>Da notare che bisogna fidarsi che il dispositivo ceda il token. Potrebbe non farlo, ed in quel caso nessun altro parlerebbe<br /></li>
<li><a id="orgbaa47cb"></a>Questa è una soluzione deterministica, perchè in ogni momento so esattamente chi sta parlando.<br /></li>
<li><a id="org616f6c2"></a>Questo approccio comporta dei problemi:<br />
<div class="outline-text-5" id="text-org616f6c2">
<ul class="org-ul">
<li>il token deve fare il giro di tutto l'anello, ma quest'ultimo ha una dimensione variabile, potenzialmente molto grande.</li>
<li>quando una stazione si aggiunge, bisogna inserirla, sincronizzando gli altri nodi per notificarli dell'inserimento. Questo non può che essere fatto da una stazione master, da cui dipende tutto il sistema.</li>
<li>la stazione master serve anche per generare il token e garantire che sia unico</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org811dcba" class="outline-4">
<h4 id="org811dcba">Ethernet utilizza, invece, una soluzione <b>non deterministica</b>, fuzzy, in cui c'entra molto la probabilità ed in cui le collisioni sono ammesse, chiamato CSMA-CD.</h4>
<div class="outline-text-4" id="text-org811dcba">
</div>
<ul class="org-ul">
<li><a id="orgbf5be14"></a>Un primo modo, chiamato ALOHA, precedente a quello finale, prevede che nel caso in cui ci sia una collisione, entrambi i mittenti non ricevono alcun ACK e ritrasmettono. Se avessero T uguale, ritrasmetterebbero nello stesso momento, generando una nuova collisione. Viene quindi introdotto un ritardo casuale. Questo diminuisce le probabilità di collisione.<br />
<ul class="org-ul">
<li><a id="org76fcc61"></a>Questa soluzione è vincente rispetto la precedente. Questo è un sistema distribuito, in cui un nuovo dispositivo può inserirsi immediatamente e trasmettere in una nuova rete.<br />
<ul class="org-ul">
<li><a id="org023bae5"></a>La prima volta nella storia in cui un approccio probabilistico vince con uno deterministico.<br /></li>
</ul>
</li>
<li><a id="orgbf96fa1"></a>Questa soluzione ha un'efficienza minima, intorno al 18%.<br /></li>
</ul>
</li>
<li><a id="org95935c6"></a>L'innovazione adottata per il protocollo di Ethernet è l'operazione di ascolto, chiamata CS, ovvero Carrier Sense. Vedo se il canale è libero e solo in quel caso immette il proprio pacchetto.<br />
<ul class="org-ul">
<li><a id="org108dcab"></a>Il rischio di collisione avviene nel caso in cui due stazioni facciano Carrier Sense nello stesso momento. Scopriranno che il Carrier si è liberato nello stesso momento e immetteranno i pacchetti.<br />
<ul class="org-ul">
<li><a id="orgedfe3ad"></a>Una soluzione per ridurre la probabilità di collisioni di questo tipo, potrebbe essere quella di introdurre un ritardo dal momento in cui viene notata la fine del pacchetto attraverso il Carrier Sense. Dato che la probabilità di questo tipo di collisione è considerata bassa in Ethernet, non viene introdotto un ulteriore ritardo. Si scommette che non avvenga di frequenza.<br />
<ul class="org-ul">
<li><a id="org3abd896"></a>Applicare il ritardo comporterebbe un protocollo Non-Persistent, ovvero le stazioni non sono competitive.<br /></li>
<li><a id="org58d12ec"></a>La nostra scelta è 1Persistent, ovvero i pacchetti trasmettono con probabilità 1.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="orgf6ff6d7"></a>La collisione viene gestita, però, in modo molto più rapido: se una stazione riceve qualcosa di diverso da quello che sta immettendo, c'è una collisione e blocca istantaneamente la trasmissione. Solo a quel punto inizia il timer random<br />
<ul class="org-ul">
<li><a id="orga04b17f"></a>BEB (binary exponential backoff) è un modo per calcolare il tempo di ritardo dopo una collisione<br />
<ul class="org-ul">
<li><a id="org6115a86"></a>Ad ogni i-esima collisione, genero un ritardo randomicamente scelto fra 0 e 2<sup>i</sup>-1 * unità di tempo<br />
<ul class="org-ul">
<li><a id="org22b4b26"></a>Quindi la prima volta il ritardo può essere di 0 o 1 unità, la seconda 0,1,2,3, la terza tra 0 d e 7 è così via<br /></li>
<li><a id="org579ddaf"></a>Il prof dice che 2<sup>i</sup>-1 è l'estremo dell'intervallo e non il numero di scelte.<br /></li>
</ul>
</li>
<li><a id="orgae9394a"></a><span class="todo TODO">TODO</span> controllare cos'è<br /></li>
<li><a id="orgd385615"></a>L'unità di tempo viene dallo standard IEEE 802.3 che specifica il CSMA-CD 1Persistente.<br />
<ul class="org-ul">
<li><a id="org8801212"></a>Abbiamo un cavo di 2500 mt, diviso in 5 sezioni di 500mt da 4 repeater. Lunghezza per indice del rame, mi da un tempo di 12.5 microsecondi.<br /></li>
<li><a id="org4c5f25a"></a>Devo garantire che questo tempo, ovvero 2tp = 25 microsecondi, non pesi troppo rispetto al tx.<br /></li>
<li><a id="org1f84c41"></a>Immaginiamo ci siano A e B, B alla fine del cavo di cui prima. Prima di 25microsecondi, se B facesse Carrier Sense, troverebbe la rete libera e colliderebbe. Lo stesso vale perchè A riconosca la presenza di bit corrotti e quindi la collisione.<br /></li>
<li><a id="org5ca8ed7"></a>In una rete di questo tipo, per garantire la collision detection, è necessario che il primo trasmettitore trasmetta per un tempo almeno maggiore di 2tp, ovvero il tempo che la trasmissione arrivi a tutti gli altri, e la trasmissione di tutti gli altri ritorni.<br /></li>
<li><a id="org1aa928b"></a>Si è quindi deciso di settare il parametro 2tp in 51,2 ms, che è il tempo richiesto ad ogni stazione per continuare a trasmettere, in modo da rilevare la collisione, questo diventa il tempo minimo di trasmissione in rete.<br />
<ul class="org-ul">
<li><a id="orgff4b099"></a>Se la rete lavora con un clock a 10Mbit, in 51.2microsecondi trasmetto 512 bit, ovvero 64byte<br /></li>
<li><a id="org1b81bc2"></a>Questo parametro di 51,2 è l'unita di tempo fondamentale, che viene applicata anche per il BEB.<br /></li>
</ul>
</li>
<li><a id="orgddd6619"></a>Lo IEEE 802.11 è lo standard WiFi.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org9a1ba7b"></a>Nel MAC, che è un layer di livello 2, multiple access control, che sarebbe lo stesso standard IEEE802.3, viene definito anche il formato del pacchetto, in cui si usa un header e un padding, che serve per raggiungere la dimensione minima.<br /></li>
<li><a id="org15b06fb"></a>Il nome è Carrier Sense, Multiple Access, Collision Detection.<br /></li>
<li><a id="orgeae3f00"></a>La curva d'efficienza la ottiene nello sweet spot di stazioni ed è intorno al 95%.<br /></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6f4dd19" class="outline-2">
<h2 id="org6f4dd19">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0</h2>
<div class="outline-text-2" id="text-org6f4dd19">
</div>
<div id="outline-container-org671ccc2" class="outline-3">
<h3 id="org671ccc2">Con ethernet, però, abbiamo vari problemi. Uno è quello di disambiguare sequenze di bit uguali, un'altra è quella di far arrivare il valore in modo chiaro al ricevitore.</h3>
<div class="outline-text-3" id="text-org671ccc2">
</div>
<div id="outline-container-orged8f1fe" class="outline-4">
<h4 id="orged8f1fe">Ethernet utilizza quindi la codifica Manchester, che a differenza del solito, legge nel momento centrale del bit, che è il punto meno soggetto a distorsione.</h4>
<div class="outline-text-4" id="text-orged8f1fe">
</div>
<ul class="org-ul">
<li><a id="org7b5961d"></a>Ciò che viene letto, però, non è il valore assoluto ma la transizione. Se vede che c'è una transizione verso l'alto, abbiamo un uno, altrimenti zero.<br />
<ul class="org-ul">
<li><a id="orgf667d9b"></a>Questo comporta che in caso di valori uguali consecutivi, bisogna cambiare la tensione appena si capisce che il prossimo bit è uguale, e poi nel momento centrale (quello letto), effettuare la transizione.<br /></li>
<li><a id="orgfe1fc51"></a>Questo comporta anche che la trasmissione sia shiftata di mezzo ciclo di clock.<br /></li>
</ul>
</li>
<li><a id="org9816248"></a>Essendo un sistema a stato IDLE pre-trasmissione, prima che questa inizi, il ricevitore non conosce il clock di trasmissione, perchè i bit in entrata sono tutti uguali.<br />
<ul class="org-ul">
<li><a id="org04ffbc8"></a>La sfida è quella di tenere il clock del ricevitore sincronizzato, magari non fornendgli un clock indipendente, ma incorporando univocamente questa informazione nei dati<br />
<ul class="org-ul">
<li><a id="org8841b0b"></a>Un primo problema è che il ricevitore non può a priori sapere se una transizione allo scattare del clock (quindi quella di preparazione), non sia una transizione valida "trasmittiva", ovvero quella mid-clock<br /></li>
</ul>
</li>
<li><a id="org0cb67ab"></a>Introduciamo un preambolo, formato da 7 byte in cui i bit 0 e 1 si alternano, ed un ottavo byte così costituito [1010101011], che il ricevitore riceve per sincronizzarsi. Gli ultimi due uno, o in particolare l'ultimo, che prevede una doppia transizione, segnala l'inizio del vero frame.<br /></li>
</ul>
</li>
<li><a id="org8cac454"></a>(non serve guardare la codifica Manchester differenziale)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge4878c5" class="outline-2">
<h2 id="orge4878c5">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)</h2>
<div class="outline-text-2" id="text-orge4878c5">
</div>
<div id="outline-container-org9b3727e" class="outline-3">
<h3 id="org9b3727e">Si dimostra che al tendere delle stazioni K all'infinito, 1/A tende a "e".</h3>
</div>
<div id="outline-container-orge6ad084" class="outline-3">
<h3 id="orge6ad084">Inoltre, si ricorda che abbiamo definito tx come dimFrame/velBanda e tp come Lunghezza/velCavo.</h3>
<div class="outline-text-3" id="text-orge6ad084">
</div>
<div id="outline-container-org9c7c372" class="outline-4">
<h4 id="org9c7c372">Allora divido tutto per tx e ottengo \(\frac{1}{1+2 \frac{BL}{CF}e }\). Quindi, all'aumentare della banda e della lunghezza, l'utilizzo diminuisce di tanto.</h4>
<div class="outline-text-4" id="text-org9c7c372">
</div>
<ul class="org-ul">
<li><a id="orgf95d588"></a>Sembra inutile aumentare la banda, perchè diminuirebbe l'utilizzo.<br /></li>
<li><a id="org8fcb061"></a>Diventa quindi necessario gestire il problema dell'aumento banda<br />
<ul class="org-ul">
<li><a id="orgf784785"></a>Ricordiamo che nelle reti moderne, la struttura è a centro stella passivo, con un hub a cui fanno riferimento vari dispositivi, in una struttura complessa ad albero, in cui i vari hub sono collegati fra loro.<br />
<ul class="org-ul">
<li><a id="org7aa6b86"></a>Questa struttura causa problemi quando il numero di dispositivi diventa eccessivo<br /></li>
<li><a id="orga35afa5"></a>Misurando il tasso di collisione di ritrasmissione, ci si rende conto che la rete è overcrowded<br /></li>
<li><a id="org6beeb15"></a>Per ovviare al problema, si fa uso dei <b>bridge</b>.<br />
<ul class="org-ul">
<li><a id="org0d49125"></a>Immaginiamo di avere una rete locale composta da 6 stazioni, 3 per hub, su 2 hub collegati.<br />
<ul class="org-ul">
<li><a id="org515ab10"></a>Gli hub sono passivi e ogni stazione può trasmettere agli altri, e può anche collidere con essi.<br />
<ul class="org-ul">
<li><a id="org2480c37"></a>Hub collegati comportano che tutte le stazioni facciano parte dello stesso dominio di collisione, ovvero lo spazio di rete in cui le stazioni competono per l'accesso al canale condiviso di trasmissione<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="org0de0d26"></a>Il bridge non è totalmente passivo, ovvero che opera a livello soltanto fisico, ma un apparato intelligente che possiede un buffer e trasmette se utile e necessario secondo certi criteri.<br />
<ul class="org-ul">
<li><a id="org1812e16"></a>Se il bridge riceve una trasmissione da parte di una stazione, verso la stazione nello stesso dominio, la scarta, perchè sa che è già arrivata a destinazione<br /></li>
<li><a id="org72779cc"></a>Se invece riceve una trasmissione verso un altro dominio a esso collegato, la inoltra verso il nuovo dominio.<br /></li>
<li><a id="org617a7fb"></a>Queste operazioni prendono il nome di Store-and-Forward.<br /></li>
<li><a id="orgfb95c03"></a>Un bridge è fatto da tante schede Ethernet (Livelli MAC) quante sono le LAN a esso collegate, con corrispondenti MAC Address per entrambe.<br />
<ul class="org-ul">
<li><a id="orgd638091"></a>Quindi si comporta esattamente come una stazione<br /></li>
</ul>
</li>
<li><a id="org7305736"></a>Chiaramente, deve contenere anche una tabella con le stazioni e la corrispondente porta attraverso cui è collegato con esse.<br />
<ul class="org-ul">
<li><a id="orgaa579b9"></a>Per riempire la tabella, si fa in modo che il bridge impari poco alla volta dove si trovano le stazioni. Quando riceve un frame da una porta, salva la stazione nella tabella<br /></li>
<li><a id="orgf558657"></a>Se una frame è destinata ad una stazione a cui non è collegata una porta, si fa broadcast.<br />
<ul class="org-ul">
<li><a id="org414a795"></a>DOMANDA: Quindi ogni volta che trasmetto verso una porta non registrata, occupo tutti i domini di collisione? Se ho un bridge con tante porte, dovrò occuparle tutte, per raggiungerne una sola. E se la porta di destinazione non spedisse mai?<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orge82ab6f"></a>Il bridge è il primo strumento di CSMA-CD che opera a <b>livello 2</b><br /></li>
</ul>
</li>
<li><a id="org99a4b2b"></a>Un altro dispositivo è lo <b>switch</b>.<br />
<ul class="org-ul">
<li><a id="orgddaf37e"></a>E' simile all'hub, ma siamo a livello 2 e contiene una tabella di store e forward.<br /></li>
<li><a id="org180875c"></a>La differenza con il bridge è che le connessioni fra le stazioni e lo switch sono punto-punto, e quindi il CSMA-CD non è necessario. Lo switch smista le comunicazioni in modo intelligente.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfc4186c" class="outline-2">
<h2 id="orgfc4186c">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.</h2>
<div class="outline-text-2" id="text-orgfc4186c">
</div>
<div id="outline-container-orgbc30a05" class="outline-3">
<h3 id="orgbc30a05">Una soluzione immediata sarebbe quella di usare 4 fili e dividere un bit in ognuno. In realtà, se ne usano solo 3 per la trasmissione, perchè il 2 è quello usato per CarrierSense e CollisionDetection.</h3>
</div>
<div id="outline-container-org3107956" class="outline-3">
<h3 id="org3107956">Come si raggiungono 1000Mbit, con solo 3 fili da 25Mbps? Si usa una codifica diversa, ternaria non binaria, chiamata 8B6T, ovvero "mappo 8 bit Binari su 6 Ternari".</h3>
<div class="outline-text-3" id="text-org3107956">
</div>
<div id="outline-container-org0b0e82f" class="outline-4">
<h4 id="org0b0e82f">A questo punto abbiamo 100 * 10<sup>6</sup> Mbit *6/8 diviso i 3 fili, ottengo 25 bit ternari per filo, che corrispondono a 33 binari.</h4>
</div>
</div>
</div>
<div id="outline-container-orgdd26f6b" class="outline-2">
<h2 id="orgdd26f6b">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.</h2>
<div class="outline-text-2" id="text-orgdd26f6b">
</div>
<div id="outline-container-org162561e" class="outline-3">
<h3 id="org162561e">flading, broadcast ma senza restituire alla porta da cui è arrivato.</h3>
</div>
<div id="outline-container-orgc8dee6e" class="outline-3">
<h3 id="orgc8dee6e">Un problema è che se un dispositivo, con un certo MAC address, si sposta da un dominio all'altro, la tabella non è più valida. Ogni entrata deve quindi avere un timer, Il flading è quindi parte integrante dell'apparato</h3>
</div>
</div>
<div id="outline-container-org1beaf19" class="outline-2">
<h2 id="org1beaf19">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.</h2>
</div>
<div id="outline-container-org5203be9" class="outline-2">
<h2 id="org5203be9">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.</h2>
<div class="outline-text-2" id="text-org5203be9">
</div>
<div id="outline-container-org6690313" class="outline-3">
<h3 id="org6690313">E' stato deciso, in sede di standard, ogni tratta deve essere grande al massimo 200 metri, quindi 800 metri in tutto al massimo ( per andare sulle 2 tratte e tornare sulle stesse).</h3>
<div class="outline-text-3" id="text-org6690313">
</div>
<div id="outline-container-orgb183472" class="outline-4">
<h4 id="orgb183472">Su 800 metri, il tempo andata e ritorno è circa 4ms. Con 1Gbit, esce fuori 4000bit, ovvero 500bit, arrotondati a 512B.</h4>
</div>
<div id="outline-container-orgf72fa74" class="outline-4">
<h4 id="orgf72fa74">Se si fosse lasciato il tempo di 51.2 microsecondi, avremmo dovuto mandare 51200 bit per ogni minimo frame e sarebbe stato poco efficiente. Viene quindi ridotto il diametro, e anche la dimensione dei frame.</h4>
</div>
<div id="outline-container-org98d800d" class="outline-4">
<h4 id="org98d800d">Per evitare di cambiare anche la porta MAC, che fa il padding di solo 64Byte, il padding viene fatto a livello fisico.</h4>
<div class="outline-text-4" id="text-org98d800d">
</div>
<ul class="org-ul">
<li><a id="org23e24d7"></a>In ogni caso, il padding è eccessivo ed è il motivo per cui spopolano gli switch e il Gbit ethernet non ha fatto presa.<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgba50667" class="outline-2">
<h2 id="orgba50667">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.</h2>
<div class="outline-text-2" id="text-orgba50667">
</div>
<div id="outline-container-org24c85c6" class="outline-3">
<h3 id="org24c85c6">C'è, però, anche un'interfaccia aggiuntiva, posizionata appena sopra il MAC, ma sempre a livello 2, chiamata <b>Logical Link Control</b>.</h3>
</div>
<div id="outline-container-orgd6b7334" class="outline-3">
<h3 id="orgd6b7334">Quello che facciamo con questo sottolivello serve a creare dei canali logici punto-punto fra sè e le altre stazioni.</h3>
<div class="outline-text-3" id="text-orgd6b7334">
</div>
<div id="outline-container-org0153319" class="outline-4">
<h4 id="org0153319">Quindi, a livello MAC gestisco la situazione Broadcast, e nel Logical Link Control, creo una sovrastruttura logica che modella i collegamenti come punto-punto. In questo modo, dal Logical Link Control in sù, ignoro qualunque ragionamento riguardo il MAC e le sue operazioni.</h4>
<div class="outline-text-4" id="text-org0153319">
</div>
<ul class="org-ul">
<li><a id="org471542e"></a>Questi collegamenti logici, possono essere sia best-effort che affidabili, esattamente come fossimo su una rete magliata.<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org79ea486" class="outline-2">
<h2 id="org79ea486">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.</h2>
<div class="outline-text-2" id="text-org79ea486">
</div>
<div id="outline-container-org9025242" class="outline-3">
<h3 id="org9025242">Stazioni che fanno parte di VLAN diverse, non possono comunicare fra loro, anche se fanno parte dello stesso hub. Serve uno switching intelligente per attivare questa funzione, perchè di base le comunicazioni sullo stesso hub girano liberamente</h3>
</div>
<div id="outline-container-orgcaa54d6" class="outline-3">
<h3 id="orgcaa54d6">Per permettere a macchine appartenenti a VLAN diversi, è necessario utilizzare il routing di livello 3, perchè la separazione introdotta, sebbene logica, è finale.</h3>
<div class="outline-text-3" id="text-orgcaa54d6">
</div>
<div id="outline-container-org9fd1819" class="outline-4">
<h4 id="org9fd1819">Gli switch avanzati posseggono una funzione di routing incorporata</h4>
</div>
</div>
<div id="outline-container-org7e00152" class="outline-3">
<h3 id="org7e00152">Le informazioni riguardo le VLAN sono contenute nello switch, che <b>tagga</b> le porte e le frame a esse corrispondenti</h3>
<div class="outline-text-3" id="text-org7e00152">
</div>
<div id="outline-container-org8ff5ee4" class="outline-4">
<h4 id="org8ff5ee4">Quindi, le stazioni mandano i soliti frame 802.3, e lo switch si occupa di taggarli e smistarli secondo un nuovo standard, chiamato 802.1Q</h4>
<div class="outline-text-4" id="text-org8ff5ee4">
</div>
<ul class="org-ul">
<li><a id="org3dcaa22"></a>Entrambi i formati, posseggono il DestinationAddress come primo campo. L'1Q, rimpiazza il campo della lunghezza con quello del protocol ID. Quindi, in quel campo, posso aspettarmi sia una lunghezza che l'ID, ed il secondo viene distinto dal fatto che contiene 8100H in hex, ovvero u numero maggiore di 1500 che è la lunghezza massima.<br /></li>
<li><a id="org71735bc"></a>Nei due byte successivi, si trovano info legate alle VLAN e, in particolare, 12 bit di VLAN identifier.<br /></li>
<li><a id="orgb563c0d"></a>Il cavo fra switch, su cui circolano soltanto frame <b>tagged</b>, si chiama <b>trunk</b><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org20f461f" class="outline-2">
<h2 id="org20f461f">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.</h2>
<div class="outline-text-2" id="text-org20f461f">
</div>
<div id="outline-container-org5eb7194" class="outline-3">
<h3 id="org5eb7194">Convergence sublayer e Physical-medium dependent layer per il physical layer, il cui primo serve per separare ulteriormente il livello fisico finale, che è fortemente dipendente dall'architettura</h3>
</div>
<div id="outline-container-org1cbd3f2" class="outline-3">
<h3 id="org1cbd3f2">LLC(Logical Link Control) e MAC(Multiple Access Control), il cui primo si occupa di rendere trasparente la gestione complicata del CSMA-CD da parte del MAC, gestendo apparentemente le connessioni come punto-punto.</h3>
</div>
</div>
<div id="outline-container-orgc696cca" class="outline-2">
<h2 id="orgc696cca">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.</h2>
<div class="outline-text-2" id="text-orgc696cca">
</div>
<div id="outline-container-org9570606" class="outline-3">
<h3 id="org9570606">Chiaramente, il MAC address smette di avere valore, su questa scala, e viene introdotto l'IP, che identifica univocamente qualunque stazione appartenente a qualunque LAN.</h3>
</div>
<div id="outline-container-org9994e9c" class="outline-3">
<h3 id="org9994e9c">Nell'andare da una stazione ad un altra, quindi da un livello Application all'altro, attraversiamo un numero indefinito di macchine che operano al massimo a livello 3. Ognuna di esse deve occuparsi dell'Addressing, ovvero come gestire l'univocità dell'IP, ed il routing, ovvero come trovare una strada fra le stazioni in modo efficiente.</h3>
</div>
<div id="outline-container-orgf13356c" class="outline-3">
<h3 id="orgf13356c">Nel livello 3 non c'è solo un entità, ma 5, di cui analizzeremo due e IP in particolare, con il suo sottomodulo OSPF, per il routing. L'altro è ARP, con cui si mappa/risolve l'IP globale nel MAC.</h3>
</div>
</div>
<div id="outline-container-orgde12ffb" class="outline-2">
<h2 id="orgde12ffb">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.</h2>
<div class="outline-text-2" id="text-orgde12ffb">
</div>
<div id="outline-container-org5d57a51" class="outline-3">
<h3 id="org5d57a51">Il formato di un pacchetto IP è formato da 5 parole (ovvero 4 byte, 32 bit) ed un ultimo spazio opzionale, utilizzato ad esempio per il source routing.</h3>
<div class="outline-text-3" id="text-org5d57a51">
</div>
<div id="outline-container-orgbe11548" class="outline-4">
<h4 id="orgbe11548">Il primo campo è quello versione, che occupa i primi 4 bit e indica la versione del protocollo, di cui ne esistono due, la v4 e la v6.</h4>
</div>
<div id="outline-container-orgd95f6f7" class="outline-4">
<h4 id="orgd95f6f7">Dopodichè c'è la header length, che occupa altri 4 bit e specifica quanti byte è lungo l'header. Serve nel caso in cui il campo option venga utilizzato, perchè ha lunghezza variabile.</h4>
</div>
<div id="outline-container-org13613c0" class="outline-4">
<h4 id="org13613c0">Gli 8 bit successivi sono occupati dal Type Of Service (TOS),</h4>
<div class="outline-text-4" id="text-org13613c0">
</div>
<ul class="org-ul">
<li><a id="org3a13bd5"></a>E' importantissimo soprattutto oggi, dato che viaggia traffico di tipo diverso (best-effort, audio, video, real time) ed ognuno richiede un servizio diverso.<br />
<ul class="org-ul">
<li><a id="org8772530"></a>Se arriva un flusso di contenuti real-time, in cui il gitter è importante, questo verrà processato per primo. Lo scheduler sceglie la coda d'uscita in cui imbucare in base a questo parametro, e chi lo decide è il livello superiore.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org4d627bf" class="outline-4">
<h4 id="org4d627bf">I successivi 16 bit che completano la parola riguardano la Total Length, che quindi può arrivare a \(2^{16}\).</h4>
</div>
<div id="outline-container-orgfe9e274" class="outline-4">
<h4 id="orgfe9e274">Nella prossima parola, si inizia con 16 bit per l'ID, seguito da 3 bit, di cui il primo vuoto per futuro uso e due bit chiamati D (Do not fragment) e M (More fragment)</h4>
</div>
<div id="outline-container-orga320c37" class="outline-4">
<h4 id="orga320c37">Poi ci sono i restanti 13 bit della parola, che si chiama Fragment Offset</h4>
<div class="outline-text-4" id="text-orga320c37">
</div>
<ul class="org-ul">
<li><a id="orged121f8"></a>Gestisce la frammentazione all'interno del livello 3. Un'unità dati utente non può passare sulla rete nella sua interezza e va frammentata per essere trasmessa. Di solito questa è una funzionalità di livello 4. Questo è un altro tipo di frammentazione.<br />
<ul class="org-ul">
<li><a id="org95b5534"></a>Un dato viene prodotto a livello 7 e frammentato in <b>segmenti</b> dal livello 4, che vengono poi singolarmente mandati al livello 3 attraverso il relativo servizio, che lo manda alla rete, che non è un concetto astratto ma una rete di qualche tipo, ad esempio Ethernet, la cui grandezza massima è 512 o ~1500 byte. Quindi il livello 3 deve frammentare a sua volta, che comunica direttamente con il livello 2 per capire la lunghezza massima e predispone sequenze da essa dipendenti.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgef09eed" class="outline-4">
<h4 id="orgef09eed">Nella terza parola, i primi 8 bit sono un timestamp, TTL (Time to live).</h4>
<div class="outline-text-4" id="text-orgef09eed">
</div>
<ul class="org-ul">
<li><a id="orgcdf351b"></a>Ogni pacchetto parte dalla sorgente, che decide quanto tempo può vivere il pacchetto in rete e se arriva alla destinazione con un valore nullo, verrà discardato. Sebbene si parli di Time, di fatto la misura è l'Hop, ovvero quanti step effettua. Se ne effettua troppi, potrebbe essersi trovato in un lungo loop.<br /></li>
</ul>
</div>
<div id="outline-container-orga023225" class="outline-4">
<h4 id="orga023225">Il secondo campo di 8 bit si chiama Protocol selector.</h4>
<div class="outline-text-4" id="text-orga023225">
</div>
<ul class="org-ul">
<li><a id="org3c0e741"></a>A livello 4 esistono diversi protocolli, ad esempio TCP ed UDP. Il pacchetto destinazione deve avere un modo per capire quale protocollo la sorgente abbia utilizzato per inviare il pacchetto.<br /></li>
</ul>
</div>
<div id="outline-container-orgb6bfaee" class="outline-4">
<h4 id="orgb6bfaee">I restanti 16 sono di Header Checksum</h4>
<div class="outline-text-4" id="text-orgb6bfaee">
</div>
<ul class="org-ul">
<li><a id="orgce705b3"></a>Internet è, per definizione, una rete best-effort. Non c'è nessun tipo di affidabilità implementata prima del livello 4. Sull'header, però, si utilizza una checksum in modo da controllare, limitatamente all'header, la validità, in modo da scartare i pacchetti non validi.<br /></li>
</ul>
</div>
<div id="outline-container-orge2cc1a2" class="outline-4">
<h4 id="orge2cc1a2">Nella quarta e quinta parola troviamo rispettivamente il Source e il Destination address, che quindi sono di 32 bit ognuno.</h4>
</div>
</div>
<div id="outline-container-orge6baf63" class="outline-3">
<h3 id="orge6baf63">Immaginiamo di avere due stazioni che comunicano, passando attraverso vari gateway, che collegano stazioni attraverso tecnologie diverse.</h3>
<div class="outline-text-3" id="text-orge6baf63">
</div>
<div id="outline-container-org320fcd3" class="outline-4">
<h4 id="org320fcd3">Ad esempio, immaginiamo che la source esca con un ring, con un limite di 4000 byte per frame, passi per due gateway, di cui il secondo è collegato ethernet, con un limite di 1500 byte per frame alla stazione di arrivo.</h4>
<div class="outline-text-4" id="text-org320fcd3">
</div>
<ul class="org-ul">
<li><a id="org820bdfb"></a>In questo caso, devo splittare il pacchetto in un certo modo all'uscita, sfruttando i campi che abbiamo visto prima, ovvero l'ID del pacchetto e il fragment offset (che è un array a scorrimento con info riguardo la posizione del pacchetto mandato).<br /></li>
<li><a id="org0427be4"></a>Innanzitutto, non posso utilizzare tutti i 4000, perchè 20 servono per l'header.<br /></li>
<li><a id="org36d46c0"></a>Inoltre, la dimensione massima è a 16 bit, ma l'indice di fragment offset è su 13. Come si potrebbe indicare l'indice successivo a un pacchetto che già occupava la dimensione massima su 16 bit?<br /></li>
<li><a id="org2328a72"></a>Si decide di utilizzare ogni bit per indicare un ottetto. Questo comporta che ogni frammento deve avere una dimensione in byte che sia un multiplo di 8.<br /></li>
<li><a id="orgb81aa7a"></a>Il primo frammento sarebbe quindi di una dimensione uguale al multiplo di 8 appena minore dello spazio rimasto oltre i byte.<br />
<ul class="org-ul">
<li><a id="orgb925b14"></a>L'ID è assegnato, la lunghezza totale pure. Nel primo frammento il fragment offset sarà a 0, e il bit More fragments a 1. Nel secondo pacchetto, invece, il fragment offset sarà uguale al numero di byte spediti in quello precedente, diviso 8. Così indico la posizione che il nuovo frammento occupa rispetto a quello precedente. Alla fine, il bit M verrà settato a 0 e si passerà al prossimo.<br /></li>
</ul>
</li>
<li><a id="org5aa330f"></a>Il riassemblamento viene effettuato soltanto dagli end system, quindi i pacchetti non vengono riassemblati per poi essere di nuovo frammentati per rispettare i nuovi protocolli, ma si lavora sui frammenti già presenti.<br /></li>
<li><a id="orge7c7a2e"></a>In ogni tratta mi occupo di soddifare i requisiti della rete fisica di cui mi sto occupando, ma non ricompongo mai, scompongo soltanto ulteriormente.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org60fa352" class="outline-3">
<h3 id="org60fa352">L'indirizzamento avviene attraverso l'IP address, che consiste in 4 sequenze di 8 bit, di cui viene rappresentato il valore decimale.</h3>
<div class="outline-text-3" id="text-org60fa352">
</div>
<div id="outline-container-org47b83cd" class="outline-4">
<h4 id="org47b83cd">L'indirizzo IP è unico a livello globale. Esiste un organismo internazionale, chiamato ICANN, ovvero "&#x2026; for Name and Numbers" e se voglio assegnare un nome al mio dispositivo, devo chiedere a loro.</h4>
</div>
<div id="outline-container-orgcb7a260" class="outline-4">
<h4 id="orgcb7a260">Abbiamo 5 modalità di addressing:</h4>
<div class="outline-text-4" id="text-orgcb7a260">
<ul class="org-ul">
<li>CLASS based</li>
<li>Subnetting</li>
<li>CIDR (Classless &#x2026;), molto usato</li>
<li>NAT, diffusissimo</li>
<li>IPv6, che riguarda un tipo diverso ai precedenti, ma che usa comunque il NAT ed il subnetting</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org38cbce3"></a>Tutte queste soluzioni sono rivolte a garantire l'unicità degli indirizzi IP<br /></li>
</ul>
</div>
<div id="outline-container-org84ca1be" class="outline-4">
<h4 id="org84ca1be">Nel CLASS based, esistono 3 classi diverse, che gestiscono trasmissioni Unicast, ovvero punto-punto.</h4>
<div class="outline-text-4" id="text-org84ca1be">
</div>
<ul class="org-ul">
<li><a id="orgaa08856"></a>Esistono anche una classe per Multicast e una Reserved.<br /></li>
<li><a id="orga75a165"></a>La classe A è caratterizzata dal primo bit settato a quindi il valore del primo byte è da 0 a 127<br /></li>
<li><a id="orga0f0495"></a>La classe B ha il primo bit settato ad 1, quindi da 128 a 191<br /></li>
<li><a id="org5f93f23"></a>La classe C ha i primi due bit, quindi da 192 a 255<br /></li>
<li><a id="orgcfc8bd5"></a>In ogni classe, una prima sezione riguarda l'ID della rete, mentre la seconda riguarda il singolo Host<br />
<ul class="org-ul">
<li><a id="org96b8dcf"></a>Se un router vede che la sezione iniziale è di passaggio, non si preoccupa neanche di controllare l'HostID.<br /></li>
<li><a id="orgb5138a2"></a>Più alta è la classe, meno reti univoche esistono, ma hanno più spazio per host.<br /></li>
</ul>
</li>
<li><a id="org203b6f8"></a>C'è un problema di frammentazione interna: è praticamente impossibile che un certo network ID utilizzi tutti gli Host ID ad esso associati<br /></li>
<li><a id="org6318c5e"></a>Il subnetting riserva, a partire dalla divisione in classi precedente, una parte dell'HostID per creare delle subnet, utili all'amministratore per gestire ed organizzare logicamente le reti.<br />
<ul class="org-ul">
<li><a id="org45364aa"></a>Prendiamo un indirizzo del tipo 130.50.15.6.<br />
<ul class="org-ul">
<li><a id="orgba49cd3"></a>Ignoriamo i primi 16 bit, che sono quelli del NetID, abbiamo 15.6, ovvero 00001111 00000110.<br /></li>
<li><a id="orgc5ca7d7"></a>Come fa il router a selezionare i 6 bit della subnet e i 10 bit dell'host?<br />
<ul class="org-ul">
<li><a id="orgc546d94"></a>Bisogna in qualche modo istruire il router in modo che capisca che questo il modo in cui vanno letti e non quello originario, in cui tutti i bit sono Host.<br /></li>
<li><a id="org09ce0bf"></a>Viene quindi introdotta una subnet mask, che filtri via i 6 bit della subnet e lasci tutto il resto, venendo sovrapposta con un AND, dove i 6 bit della subnet, e tutti i bit precedenti, quelli del NetID sono settati a 1, in modo da lasciarli intatti, e il resto a 0, in modo da cancellare il restanti 10 bit dell'host.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7d46abf" class="outline-2">
<h2 id="org7d46abf">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.</h2>
<div class="outline-text-2" id="text-org7d46abf">
</div>
<div id="outline-container-org77a453e" class="outline-3">
<h3 id="org77a453e">Gli altri metodi, CIDR e NAT, sono usati per superare il problema della frammentazione interna degli IP e aumentare la longevità di IPv4.</h3>
<div class="outline-text-3" id="text-org77a453e">
</div>
<div id="outline-container-org64e0d24" class="outline-4">
<h4 id="org64e0d24">Prima o poi, gli indirizzi a 32 bit di v4 finiranno, e saremmo costretti a utilizzare i 128 bit del IPv6.</h4>
</div>
<div id="outline-container-org37c50a5" class="outline-4">
<h4 id="org37c50a5">CIDR sta per Classless Inter Domain Routing e invece di dividere in classi, lo fa in blocchi autonomi e indipendenti, geografici (europeo, nord-americano, asiatico, ecc.).</h4>
<div class="outline-text-4" id="text-org37c50a5">
</div>
<ul class="org-ul">
<li><a id="org583dd82"></a>Per esempio, in Europa gli indirizzi vanno da 194.0.0.0 a 194.255.255.255 e lo stesso per 195. Quindi abbiamo 3 sequenze da 8 bit, quindi ognuna da 256 indirizzi, con un totale di 16,777,216. Questo numero è per ogni sequenza iniziale di bit, quindi, moltiplicata per 2, ci porta ad un totale di 33,554,432 indirizzi per l'europa.<br /></li>
<li><a id="orge86544c"></a>Il vantaggio è che ogni operatore può scegliere un numero di subnet o host che preferisce.<br />
<ul class="org-ul">
<li><a id="orgfd085eb"></a>Fra paginazione e segmentazione, il vantaggio è che la seconda fa perdere frammentazione interna, ma può creare quella esterna.<br />
<ul class="org-ul">
<li><a id="org7b318ee"></a>Infatti, nel momento in cui ogni spazio è occupato e uno degli spazi viene deallocato, bisogna trovare qualcuno che abbia bisogno di un numero massimo uguale a quello lasciato, altrimenti non trova posto e quello spazio rimane inallocato.<br /></li>
</ul>
</li>
<li><a id="org2836e6a"></a>Supponiamo che un organizzazione di Milano richieda 2048 indirizzi e gli viene assegnato l'indirizzo 194.24.0.___, fino a quello 194.24.7.___. L'ultima parte è interna e quindi non serve indicarla.<br />
<ul class="org-ul">
<li><a id="org3a1f6ce"></a>All'organizzazione viene assegnato l'indirizzo base, ovvero i primi 3 byte. Bisogna però dare al router un altro strumento di filtro, per evitare che vada ad utilizzare indirizzi fuori da questo slot.<br /></li>
</ul>
</li>
<li><a id="org81b36ba"></a>Una di roma chiede 2046 indirizzi, servono quindi 16 pagine da 256 indirizzi, allora 4 bit saranno cancellati<br /></li>
<li><a id="orgc04bc31"></a>Ogni router deve quindi far girare tutte le maschere che conosce in AND con l'indirizzo ricevuto, finchè non trova la base dello spazio di indirizzi che è stato assegnato.<br /></li>
<li><a id="org3fed13a"></a>Questa soluzione allunga la vita a IPV4, ma non risolve completamente il problema. Fra l'altro, il numero massimo di IP è 30 milioni, molto minore della popolazione europea.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org5c01f94" class="outline-4">
<h4 id="org5c01f94">Il NAT estende ulteriormente la vita di IPv4.</h4>
<div class="outline-text-4" id="text-org5c01f94">
</div>
<ul class="org-ul">
<li><a id="org2bc3566"></a>Ogni rete privata ha un NAT, che è un router, che fa da "firewall" fra il mondo di indirizzamento pubblico e quello di indirizzamento privato.<br /></li>
<li><a id="org297e1ba"></a>Vengono riservati gli ip che iniziano con 10, 172 e 192 alle reti private.<br /></li>
<li><a id="orgc35bf8f"></a>Ogni organizzazione viene raggiunta da un IP unico a livello globale, che poi smisterà il pacchetto agli IP, univoci solo a livello di organizzazione, degli host singoli.<br /></li>
<li><a id="org4d324b4"></a>Ovviamente, è necessario che i pacchetti salvino sia l'IP globale che quello locale.<br /></li>
<li><a id="orgc1f1aa0"></a>Bisogna gestire il caso delle requeste da parte degli host locali: questi ultimi sanno dove passare per raggiungere il server, ovvero attraverso il NAT. Il server, invece, riceve una request soltanto dal NAT e risponderà ad esso, ma non ha informazione dell'host locale originario.<br />
<ul class="org-ul">
<li><a id="org440c511"></a>Abbiamo bisogno di qualcosa di nuovo per salvare questa informazione, in modo che il NAT riesca ad associare i pacchetti in arrivo con gli specifici host.<br /></li>
<li><a id="org07c9c1b"></a>Un metodo per risolvere questo problema è attraverso il concetto di porta: il TCP è un identificatore numerico che vale solo nel sistema operativo, che associa all'interno della macchina il processo alla specifica entità TCP.<br />
<ul class="org-ul">
<li><a id="orgd98c6ff"></a>Il numero della porta è restituito all'apertura di una socket, come per i file descriptor al momento della open o write in un SO.<br /></li>
<li><a id="orgd8a1ff7"></a>I server web di tutto il mondo parlano sulla porta 80, well-known-port.<br /></li>
<li><a id="org01b226e"></a>I server client hanno, invece, un numero di porta effimero assegnato mediante chiamata a primitiva socket e consistente durante la vita della socket.<br /></li>
<li><a id="orge3bcbc1"></a>Immaginiamo ora che la host machine dietro NAT usi la porta 1500 ed il server la porta 80. Allora, ogni pacchetto conterrà, oltre ai 3 ip coinvolti (host, NAT, server), anche la porta sorgente e quella destinazione, così che la comunicazione avverrà tra le due porte in questione e il NAT avrà modo di associare il pacchetto in arrivo all'host originario.<br /></li>
<li><a id="orgb9d7bfe"></a>A questo punto, la gerarchia ben definita secondo cui ogni livello pensa solo a sè stesso, crolla.<br />
<ul class="org-ul">
<li><a id="org57987f4"></a>Infatti, IP porta in giro lo header di TCP, che sta a livello 4 e quindi dovrebbe essere completamente ignorato a livello 3.<br /></li>
<li><a id="orgbe8e496"></a>Invece, il router NAT a livello 3, per compiere le sue tipiche funzioni di instradamento nell'inviare il pacchetto alla sua macchina host, deve andare a leggere lo header TCP, in particolare la porta che quello ha assegnato all'host. Lo stesso vale per le comunicazioni in uscita.<br /></li>
<li><a id="orgbb38f43"></a>Insomma, lo svolgimento del livello 3 quando è coinvolto un NAT, è basato su risultati creati a livello 4.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="org5995be1"></a>Questa soluzione porta ad un problema successivo: cosa accade se a due processi differenti, viene assegnato lo stesso numero di porta dalle primitive socket?<br /></li>
<li><a id="org3bfc817"></a>L'unico modo diventa quello di rendere le porte univoche, ed il NAT lo fa utilizzando una numerazione propria e diversa per ogni processo.<br />
<ul class="org-ul">
<li><a id="org2feba4b"></a>Il NAT, quindi, accede allo header di livello 4 non soltanto per leggere, ma anche per sostituire la porta locale con quella NAT.<br /></li>
<li><a id="orgd35a8b9"></a>Ovviamente, modifica anche l'IP.<br /></li>
<li><a id="org8ec906f"></a>Di conseguenza, le reply arriveranno all'IP del NAT e alla specifica porta NAT, che quest'ultimo trasformerà nella porta host corretta.<br /></li>
<li><a id="org080d69b"></a>A cosa serve quindi tenere la porta originale? BHO<br /></li>
</ul>
</li>
<li><a id="org591c5e9"></a>Il NAT offre grandi garanzie in termini di sicurezza, perchè le macchine dietro di lui sono assolutamente invisibili ed inaccessibili dall'esterno, infatti fa anche da firewall.<br /></li>
<li><a id="org0ec4b96"></a>L'ultima questione da risolvere è quella di un server dietro NAT, dato che nessuno conosce la porta che mi porta ad esso.<br />
<ul class="org-ul">
<li><a id="orga878156"></a>Un modo banale è quello di assegnargli un IP pubblico, ma perdendo i vantaggi dovuti all'utilizzo del NAT.<br /></li>
<li><a id="orgf35d4d7"></a>Un secondo modo è quello di aprire la porta specifica del server. In questo modo, tutte le richieste verso quella porta vengono routate al server in questione.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org86ec868" class="outline-2">
<h2 id="org86ec868">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.</h2>
<div class="outline-text-2" id="text-org86ec868">
</div>
<div id="outline-container-org64da834" class="outline-3">
<h3 id="org64da834">A livello 2, in una rete CSMA-CD l'indirizzo è il MAC</h3>
</div>
<div id="outline-container-orgd1694b2" class="outline-3">
<h3 id="orgd1694b2">A livello 3, l'indirizzo è quello IP, con tutte le considerazioni fatte in precedenza.</h3>
</div>
<div id="outline-container-org0c93ff9" class="outline-3">
<h3 id="org0c93ff9">Un problema che dobbiamo risolvere è quello di mappare l'IP al corrispondente MAC.</h3>
<div class="outline-text-3" id="text-org0c93ff9">
</div>
<div id="outline-container-org0a872c3" class="outline-4">
<h4 id="org0a872c3">Infatti, finora non c'è nessun modo per far arrivare un pacchetto a destinazione.</h4>
</div>
</div>
<div id="outline-container-org4bac8d9" class="outline-3">
<h3 id="org4bac8d9">Immaginiamo che A e B siano sulla stessa rete locale.</h3>
<div class="outline-text-3" id="text-org4bac8d9">
</div>
<div id="outline-container-orga7c7b65" class="outline-4">
<h4 id="orga7c7b65">Se la macchina A manda un pacchetto al modulo B, chiede ad ARP di risolvere l'IP in un MAC address, così che possa mandarglielo attraverso il livello 2</h4>
</div>
<div id="outline-container-orgdf71b8f" class="outline-4">
<h4 id="orgdf71b8f">In pratica l'ARP, per conto di IP, manda ai livelli sottostanti una richiesta, ARPRequest, così che il dispositivo in questione risponda con un ARPReply, rispondendo con il proprio MAC, che ARP fornirà al livello IP della macchina sorgente.</h4>
<div class="outline-text-4" id="text-orgdf71b8f">
</div>
<ul class="org-ul">
<li><a id="org2761455"></a>Le due macchine, nell'esempio, si trovano nella stessa rete. Ovviamente, nella richiesta non si sa chi sia l'host destinazione, quindi è necessario fare una richiesta broadcast. La risposta sarà, invece, punto-punto.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org29c3c47" class="outline-3">
<h3 id="org29c3c47">Immaginiamo adesso che siano su macchine diverse.</h3>
<div class="outline-text-3" id="text-org29c3c47">
</div>
<div id="outline-container-org89cea23" class="outline-4">
<h4 id="org89cea23">A manda richiesta a Z, su un'altra rete.</h4>
</div>
<div id="outline-container-orgb048fb4" class="outline-4">
<h4 id="orgb048fb4">Il site access gateway leggerà il NETID e vedrà che non appartiene alla rete locale e che quindi va cercato al di fuori. Prenderà lui in carico l'operazione.</h4>
</div>
<div id="outline-container-org1ae2431" class="outline-4">
<h4 id="org1ae2431">A questo punto, risponderà con il proprio MAC, in modo che A mandi le richieste al gateway.</h4>
</div>
<div id="outline-container-org582c90d" class="outline-4">
<h4 id="org582c90d">Il gateway aspetterà autonomamente per la ARPReply della macchina remota e salverà il risultato.</h4>
</div>
<div id="outline-container-org7a59f9d" class="outline-4">
<h4 id="org7a59f9d">Questo servizio si chiama ProxyARP.</h4>
</div>
</div>
<div id="outline-container-org592e167" class="outline-3">
<h3 id="org592e167">ARP in ogni dispositivo terrà una ARP Cache, in cui salverà tutte le associazioni IP-MAC, così che le volte successive non servirà una nuova richiesta.</h3>
</div>
<div id="outline-container-org5bfd65a" class="outline-3">
<h3 id="org5bfd65a">Quindi uso ARP per fare una discovery delle macchine che sono raggiungibili in rete.</h3>
</div>
<div id="outline-container-orgdf1f7ae" class="outline-3">
<h3 id="orgdf1f7ae">Anche in questo caso, abbiamo un livello 3 che per funzionare (anzi, il suo obiettivo) è di livello 2. Deve infatti andare a toccare il MAC, indirizzo di livello 2, ma in questo caso almeno fa una richiesta</h3>
</div>
<div id="outline-container-org4a298e9" class="outline-3">
<h3 id="org4a298e9">Notiamo che nello header di livello 3, il campo type è usato anche per identificare se la richiesta sia IPv4 o ARP</h3>
</div>
</div>
<div id="outline-container-orge00ce99" class="outline-2">
<h2 id="orge00ce99">Introduciamo il DHCP</h2>
<div class="outline-text-2" id="text-orge00ce99">
</div>
<div id="outline-container-org5686374" class="outline-3">
<h3 id="org5686374">Abbiamo tante macchine collegate ad una LAN, che possono essere nostre oppure di ospiti che arrivano transitoriamente. Come assegniamo l'IP privato alle macchine?</h3>
<div class="outline-text-3" id="text-org5686374">
</div>
<div id="outline-container-orga935691" class="outline-4">
<h4 id="orga935691">La LAN potrebbe essere Wireless, collegata tramite un Access Point ad una Lan fisica, che tramite il suo Access Gateway è collegata alla rete fisica.</h4>
</div>
</div>
<div id="outline-container-org85cb77f" class="outline-3">
<h3 id="org85cb77f">Il Gateway riesce a fare Address Resolution e quindi è anche un NAT. Ovvero, riesce a mascherare un indirizzo interno.</h3>
<div class="outline-text-3" id="text-org85cb77f">
</div>
<div id="outline-container-orgd0ca839" class="outline-4">
<h4 id="orgd0ca839">Ci presenta con un IP pubblico alla rete, ma poi smista alle macchine singole con gli indirizzi privati.</h4>
</div>
</div>
<div id="outline-container-org2c39652" class="outline-3">
<h3 id="org2c39652">Questi indirizzi potrebbero esere statici, ma questo è scomodo. (Perchè?).</h3>
</div>
<div id="outline-container-orge84963a" class="outline-3">
<h3 id="orge84963a">E' più comodo se al momento della prima connessione alla rete, venga assegnato un IP dinamico al dispositivo, che rimanga fino allo spegnimento.</h3>
</div>
<div id="outline-container-org052b5f2" class="outline-3">
<h3 id="org052b5f2">Per assegnare l'IP dinamico, usiamo il server DHCP (eventualmente molteplici)</h3>
<div class="outline-text-3" id="text-org052b5f2">
</div>
<div id="outline-container-orgcd8b6a0" class="outline-4">
<h4 id="orgcd8b6a0">Appena una macchina cliente viene bootata, fa un operazione di Request DHCP al server, che farà a sua volta una Reply.</h4>
</div>
<div id="outline-container-org58d3602" class="outline-4">
<h4 id="org58d3602">La reply assegna un IP privato, valido per tutto il tempo necessario.</h4>
<div class="outline-text-4" id="text-org58d3602">
</div>
<ul class="org-ul">
<li><a id="org9a6c52f"></a>Addirittura, un DHCP address ha un TimeToLeave, poi viene buttato e refreshato.<br /></li>
<li><a id="org8da39fa"></a>Al punto che quando arriva un ospite (abilitato ad accedere alla rete), loro parlano con DHCP e diventano a tutti gli effetti parte della rete.<br /></li>
</ul>
</div>
<div id="outline-container-org4dc09d3" class="outline-4">
<h4 id="org4dc09d3">La RequestForComment che lo definisce è la 2131.</h4>
</div>
<div id="outline-container-org958e736" class="outline-4">
<h4 id="org958e736">Il client triggera la richiesta, che nello specifico si chiama DHCP Discover.</h4>
<div class="outline-text-4" id="text-org958e736">
</div>
<ul class="org-ul">
<li><a id="orgca28b94"></a>Questa discover è un pacchetto IP che viaggia con sorgente 0.0.0.0, perchè non so scriverlo ed è proprio per questo che mando la richiesta.<br /></li>
<li><a id="org7361c58"></a>La destinazione è 255.255.255.255. Un pacchetto broadcast all'interno della LAN. Non va direttamente al server DHCP. Il motivo è che se io voglio un assegnamento dinamico per ogni macchina, anche non appartenenti alla mia rete, non posso assumere che questi sappiano l'indirizzo del server DHCP.<br /></li>
<li><a id="org6c77fa9"></a>Inoltre, se io mettessi un singolo IP, perderei la possiblità di avere molteplici DHCP server, utilizi banalmente per ridondanza.<br /></li>
<li><a id="org147a005"></a>Poi c'è un campo Time To Live,  con un Transaction ID, che viene associato all'indirizzo della macchina.<br />
<ul class="org-ul">
<li><a id="orgfe90684"></a>Questo serve per associare le request alle response<br /></li>
<li><a id="orgeea13a1"></a>Per identificare questo Time To Live con il client della richiesta, non può essere utilizzato l'IP, ma necessariamente il MAC di livello 2.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org9c9bed0" class="outline-4">
<h4 id="org9c9bed0">Il server riceve la richiesta e reagisce con una DHCP Offer.</h4>
<div class="outline-text-4" id="text-org9c9bed0">
</div>
<ul class="org-ul">
<li><a id="org33d67b3"></a>Quello che offre il DHCP server è l'IP address.<br /></li>
<li><a id="org27d729d"></a>Sarà sempre un pacchetto con sorgente IP del Server, broadcast e lo stesso transactionID della richiesta.<br />
<ul class="org-ul">
<li><a id="org6540948"></a>Deve necessariamente essere broadcast.<br /></li>
</ul>
</li>
<li><a id="org4314b0c"></a>Prima di fare la offer, il server fa un check. Il check dell'IP prevede che tramite ICMP il server sia in grado di verificare se per caso quell'IP non sia stato già assegnato a qualcuno per errore.<br />
<ul class="org-ul">
<li><a id="org5bc50bc"></a>In pratica fa un ping, che prevede un echo se la stazione è raggiungibile. Se l'echo è assente, l'IP non è stato associato a nessuno. Altrimenti l'IP va aggiornato.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgeddf2be" class="outline-4">
<h4 id="orgeddf2be">A questo punto il client ha <b>apparentemente</b> risolto il suo problema.</h4>
<div class="outline-text-4" id="text-orgeddf2be">
</div>
<ul class="org-ul">
<li><a id="orga15f07c"></a>Si può immaginare che il client abbia un timeout in modo che non trascorra troppo prima dell'arrivo di una offer. (Stesso principio dell'ACK).<br /></li>
<li><a id="org8d2a3fd"></a>Il problema è che un algoritmo di questo tipo funzionerebbe se e solo se ammettesse uno e un solo server DHCP operativo per ogni rete, ma il protocollo è fatto per funzionare con un numero arbitrario di server.<br />
<ul class="org-ul">
<li><a id="orgd491232"></a>Infatti, la discover è in broadcast e arriva a tutti i server, che si adopereranno tutti per offrire un IP.<br /></li>
</ul>
</li>
<li><a id="orgc123f35"></a>Bisogna garantire che venga accettata l'offerta di un solo server.<br /></li>
</ul>
</div>
<div id="outline-container-orgf4b09fb" class="outline-4">
<h4 id="orgf4b09fb">Diventa necessaria un ulteriore fase, una commit, chiamata DHCP Request.</h4>
<div class="outline-text-4" id="text-orgf4b09fb">
</div>
<ul class="org-ul">
<li><a id="org104033c"></a>Questa viaggia con stesse sorgente e destinazione della discover (0 e 1Broadcast), ma con un ulteriore campo scelta, che contiene un ID del server la cui offerta è stata accettata.<br /></li>
</ul>
</div>
<div id="outline-container-org0084fdb" class="outline-4">
<h4 id="org0084fdb">A questo punto, si chiude il commitment con una DHCP Ack, che è una validazione della request. Anche questo è mandato in broadcast secondo IP.</h4>
<div class="outline-text-4" id="text-org0084fdb">
</div>
<ul class="org-ul">
<li><a id="orgbf1d943"></a>Ricordare che tutte queste comunicazioni di risposta da parte del server, utilizzano il MAC di livello 2 e sono quindi Unicast.<br /></li>
</ul>
</div>
<div id="outline-container-org04cf0aa" class="outline-4">
<h4 id="org04cf0aa">Questo protocollo è un protocollo a 4 vie, a causa della necessità di selezionare fra i vari server.</h4>
</div>
<div id="outline-container-org1b9f7fd" class="outline-4">
<h4 id="org1b9f7fd">Servono inoltre dei check per verificare la validità degli IP, anche dal punto di vista del client.</h4>
<div class="outline-text-4" id="text-org1b9f7fd">
</div>
<ul class="org-ul">
<li><a id="org177b1c5"></a>Viene utilizzato ARP, che è perfetto per questo lavoro, ovvero risolvere un IP in un MAC.<br />
<ul class="org-ul">
<li><a id="org3174052"></a>Facendo una ARP request con l'IP appena assegnato al server, in caso di risposta positiva si capisce che l'IP è già assegnato.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org14c8bf8" class="outline-4">
<h4 id="org14c8bf8">Esistono dei meccanismi di ricovero, per gestire i casi in cui i messaggi vengano persi. Si utilizza ad esempio un timer T, che viene eseguito massimo K volte (numero di retry). Una volta aver provato K volte, si ritorna alle origini e si ricomincia da capo.</h4>
</div>
</div>
</div>
<div id="outline-container-org3ecd6eb" class="outline-2">
<h2 id="org3ecd6eb">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).</h2>
</div>
<div id="outline-container-org6630d15" class="outline-2">
<h2 id="org6630d15">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente</h2>
<div class="outline-text-2" id="text-org6630d15">
</div>
<div id="outline-container-orgdfb60be" class="outline-3">
<h3 id="orgdfb60be">Immaginiamo di avere due macchine con porte I/O e un forwarder in mezzo, che contiene una tabella e fa un lookup per capire su quale porta trasmettere il messaggio entrato.</h3>
<div class="outline-text-3" id="text-orgdfb60be">
</div>
<div id="outline-container-org9187319" class="outline-4">
<h4 id="org9187319">A livello 2, questo è fatto dal bridge, che popola e spopola le tabelle periodicamente per lasciar spostare le macchine.</h4>
</div>
<div id="outline-container-org5ad9879" class="outline-4">
<h4 id="org5ad9879">Se saliamo di un piano, quello che cambia radicalmente è che non è più vero che la macchina destinazione sia attaccata al link. La validità di un forwarding livello 2, a livello 3 non è più sufficiente.</h4>
<div class="outline-text-4" id="text-org5ad9879">
</div>
<ul class="org-ul">
<li><a id="org45ed43b"></a>Il forwarding deve avere la capacità di scegliere la porta che conduce alla destinazione in futuro, e in un modo oscuro alla singola macchina.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgacb8cb7" class="outline-3">
<h3 id="orgacb8cb7">A livello 3, la tabella viene popolata da un secondo processo, che chiamiamo <b>router</b>, che lavora con i suoi pacchetti di controllo, utili soltanto a lui, tramite i quali impara la topologia della rete e popola la tabella in modo da permettere di raggiungere ogni host in un modo efficiente, possibilmente il cammino minimo.</h3>
<div class="outline-text-3" id="text-orgacb8cb7">
</div>
<div id="outline-container-org08337b9" class="outline-4">
<h4 id="org08337b9">La cosa interessante è che abbiamo una separazione netta fra tutto ciò che è gestione dei dati utente e la gestione di controllo di tutto ciò che serve alla rete autonomamente perchè funzioni.</h4>
</div>
<div id="outline-container-org8d4620f" class="outline-4">
<h4 id="org8d4620f">Con il routing questa diventa chiara.</h4>
<div class="outline-text-4" id="text-org8d4620f">
</div>
<ul class="org-ul">
<li><a id="orgb5aa6b1"></a>Finora i messaggi di controllo e i dati erano mescolati, anche fisicamente.<br /></li>
<li><a id="org366b08b"></a>Adesso, il router lavora in modo assolutamente autonomo.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5b2d892" class="outline-3">
<h3 id="org5b2d892">Il router opera attraverso 3 tecniche:</h3>
<div class="outline-text-3" id="text-org5b2d892">
<ul class="org-ul">
<li>Distance vector - RIP, vecchio e residuale</li>
<li>OSPF, link state, più diffuso</li>
<li>BGP, Border Gateway Protocol, evoluzione del distance vector, utilizzato per la comunicazione ad alto livello, intercontinentale</li>
</ul>
</div>
<div id="outline-container-orgd3973a2" class="outline-4">
<h4 id="orgd3973a2">Il protocollo con Distance vector opera assegnando due etichette con numero del link e corrispondente peso su ogni arco bidirezionale.</h4>
<div class="outline-text-4" id="text-orgd3973a2">
</div>
<ul class="org-ul">
<li><a id="orge77ab59"></a>Ogni nodo produce la tabella delle adiacenze. Questa contiene Router, Link e Cost.<br />
<ul class="org-ul">
<li><a id="orgc861018"></a>Sè stesso è raggiungibile da sè stesso (no link) con costo 0.<br /></li>
<li><a id="org73c5ced"></a>Ogni altro router, è raggiungibile attraverso un certo link, con un costo uguale alla somma delle etichette dei pesi di tutti gli archi che vengono attraversati.<br /></li>
</ul>
</li>
<li><a id="org7fe6075"></a>Con queste costruiamo la conoscenza locale, ovvero tutti i router appena adiacenti attraverso soltanto un filo, insieme al loro costo.<br />
<ul class="org-ul">
<li><a id="org185ef9b"></a>Ancora non abbiamo una visione topologica della rete. Abbiamo solo una visione delle adiacenze.<br />
<ul class="org-ul">
<li><a id="org5c3e95a"></a>Un singolo nodo nono ha idea di quali nodi possa raggiungere oltre le adiacenze.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="orge7bb44d"></a>Il modo per passare da una conoscenza locale a quella globale sfrutta la comunicazione fra nodi.<br /></li>
<li><a id="orgbdb2ac0"></a>Periodicamente viene trasferito agli altri il distance vector, ovvero l'associazione Router-Costo<br />
<ul class="org-ul">
<li><a id="org3a7969e"></a>Ogni router ha un proprio timer, alla scadenza del quale trasferisce il vettore delle distanze ai suoi vicini.<br /></li>
</ul>
</li>
<li><a id="org2118509"></a>Quando un nodo riceve il vettore delle distanze del vicino, aggiorna il proprio vettore con i nuovi nodi raggiungibili attraverso il vicino, la cui distanza è la somma fra il primo nodo è quello appena collegato e quest'ultimo con il nuovo.<br /></li>
<li><a id="org031cf52"></a>Ogni vettore delle distanze nuovo che arriva, un router calcola anche tutte le nuove distanze per le destinazioni che già conosce, in modo da aggiornare nuove distanze minime.<br /></li>
<li><a id="org0932afd"></a>Il tempo necessario per conoscere tutta la rete è lineare con il suo diametro.<br /></li>
<li><a id="orgb843b30"></a>Viene inoltre utilizzato il trigger update con cui i nodi vicini possono richiedere informazioni alla variazione dello stato. Ad esempio usano il trigger update i router appena accesi così chiamano velocemente informazioni nuove.<br /></li>
<li><a id="org303418d"></a>Il problema di questo protocollo è che non c'è modo di aggiornare in caso di peggioramenti e questo causa un malfunzionamento abbastanza grave.<br />
<ul class="org-ul">
<li><a id="org66334d5"></a>Immaginiamo che un link su un certo nodo si guasti.<br />
<ul class="org-ul">
<li><a id="org5b2118f"></a>Il nodo stesso lo riconosce subito e aggiorna la propria tabella con valore <b>infinito</b> per il nodo dietro quel link.<br /></li>
<li><a id="org026e68a"></a>Gli altri nodi però non lo sanno e continuano a mandare su quel link, se la loro tabella dice che è quella la strada minore.<br /></li>
<li><a id="orgbe863fa"></a>Questa situazione finisce soltanto nel momento in cui B propaga il suo distance vector con costo infinito.<br /></li>
<li><a id="org8732e66"></a>Cosa succede se però nel frattempo un altro nodo, non ancora informato del guasto, manda il proprio distance vector al nodo che ha appena notato il guasto?<br />
<ul class="org-ul">
<li><a id="orgb65d955"></a>Siano A, B e C i nodi, con A che vuole raggiungere C attraverso B, e il collegamento fra B e C guasto.<br />
<ul class="org-ul">
<li><a id="org77b1491"></a>Allora la distanza fra A e C è uguale alla distanza fra A e B più quella fra B e C<br /></li>
<li><a id="org9e60d1c"></a>Il problema è che adesso la distanza fra B e C è infinita, ma quella fra A e C considera ancora il valore da B e C precedente.<br /></li>
<li><a id="org3deb81e"></a>Allora B aggiorna la sua stessa distanza fra B e C come quella suggerita da A, che però già contiene la distanza B-C non aggiornata, più la distanza fra A e B.<br />
<ul class="org-ul">
<li><a id="orgc110f82"></a>In pratica, B rimpiazza l'infinito con la distanza B-A più A-B più B-C vecchia.<br /></li>
<li><a id="org86643ac"></a>Alla update successiva, A vede che B ha aumentato la propria distanza di un valore uguale alla distanza A-B e aggiorna il suo valore a quella distanza, più B-A<br />
<ul class="org-ul">
<li><a id="org29491ec"></a>Quindi A rimpiazza A-B + old(B-C) con A<br /></li>
<li><a id="org0721cb3"></a>Quello che succede è questo (indico la distanza fra i nodi A o B e C):<br />
<div class="outline-text-11" id="text-org0721cb3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">stato</td>
</tr>

<tr>
<td class="org-left">[A-B]+[B-C]</td>
<td class="org-left">[B-C]</td>
<td class="org-left">Iniziale</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">Inf</td>
<td class="org-left">Collegamento rotto e DVB viene perso</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">[B-A]+[A-B]+[B-C]</td>
<td class="org-left">B acquisisce la distanza da A</td>
</tr>

<tr>
<td class="org-left">[A-B]+[B-A]+[A-B]+[B-C]</td>
<td class="org-left">//</td>
<td class="org-left">A acquisisce da B</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">[B-A]+"same as top left"</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
<li><a id="org336ad3d"></a>Si inizierà un <b>count to infinity</b> in cui ad ogni step la distanza verso quel collegamento aumenta della distanza fra i due nodi in questione.<br /></li>
<li><a id="orgfa3108e"></a>Questo accade perchè le distanze di sia A che B verso quello guasto C contengono al loro interno la distanza A-B. Ovvero, B raggiunge C tramite A (o almeno crede di fare così) e A raggiunge C tramite B.Il sistema è innescato da B, che normalmente non dovrebbe aggiornare la propria distanza per includere quella di A, perchè il collegamento diretto con C è banalmente più breve di quello che compie un ciclo tramite A e poi ripercorre il collegamento diretto.<br />
<ul class="org-ul">
<li><a id="org63dec01"></a>Quando però il link con C è danneggiato, accade che il ciclo attraverso A più la vecchia distanza B-C è sicuramente più breve dell'infinito e B aggiorna, senza sapere che A fa affidamento su di lui.<br /></li>
<li><a id="org6fb9331"></a>A aggiorna, senza sapere che B fa affidamento su di lui.<br /></li>
<li><a id="org005b403"></a>MAIN<br />
<div class="outline-text-11" id="text-org005b403">
<p>
Maybe the solution is that the distance vector also contains the link that leads to a node.
If a new value comes from a distance vector, and that value is HIGHER than the one a node already had, but it is on the same link, the node updates it.
</p>

<p>
Yes, exactly! That's the key insight that explains why count to infinity actually occurs. The distance vector protocol also keeps track of the next hop (the link or neighbor through which a destination is reached), not just the distances.
</p>

<p>
So in the A-B-C scenario:
</p>

<p>
Initially A reaches C through B (next hop = B)
When B-C link fails:
    B sets its distance to C as infinity
    When A receives B's update, even though it's a larger value, A MUST accept it because B is its next hop to C
    A can't keep its old shorter value because that path was dependent on going through B
</p>

<p>
This is why it's crucial that nodes update their routes when they receive updates from their next hop neighbor, even if the new distance is larger. The node must trust its next hop's information about destinations reached through that path.
</p>

<p>
This is also why solutions like split horizon work - they prevent nodes from advertising routes back through the path they learned them from, breaking this cycle of increasing distances.
</p>

<p>
Your observation about the importance of the link/next hop information is spot-on and explains the actual mechanism behind count to infinity much more accurately than the oversimplified "only accept shorter paths" explanation.
SPIEGAZIONE DEL PERCHÈ UN NODO ACCETTA UN VALORE PIÙ ALTO
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgafa4790"></a>Le due cause del problema sono il fatto che l'informazione dello specifico nodo utilizzato per raggiungere una destinazione è persa, e che i disstance vector viaggiano in modo asincrono e possono anche essere smarriti.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org0faa0b0"></a>La soluzione al <b>count to infinity</b> è<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org72f623e" class="outline-2">
<h2 id="org72f623e">TO BE FILLED WITH 3 LESSONS</h2>
</div>
<div id="outline-container-orgf65a208" class="outline-2">
<h2 id="orgf65a208">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).</h2>
<div class="outline-text-2" id="text-orgf65a208">
</div>
<div id="outline-container-org69a7402" class="outline-3">
<h3 id="org69a7402">Offre dei servizi che abbiamo già visto nel data-link.</h3>
</div>
<div id="outline-container-orgf830bd3" class="outline-3">
<h3 id="orgf830bd3">Varie funzionalità possono essere attivate o disattivate.</h3>
</div>
<div id="outline-container-org23e9d7b" class="outline-3">
<h3 id="org23e9d7b">TCP e UDP sono ortogonali fra loro. La prima offre disponibilità, mentre la seconda è best-effort e non aggiunge nulla ai livelli superiori.</h3>
</div>
<div id="outline-container-orga3237f3" class="outline-3">
<h3 id="orga3237f3">A livello data-link, tra due porte di rete abbiamo una trasmissione può essere affidabile, avere controllo degli errori ecc.</h3>
<div class="outline-text-3" id="text-orga3237f3">
</div>
<div id="outline-container-org69798e2" class="outline-4">
<h4 id="org69798e2">Quello che non è considerato a livello data-link è se qualcosa va perso a livello network.</h4>
<div class="outline-text-4" id="text-org69798e2">
</div>
<ul class="org-ul">
<li><a id="orgf827c51"></a>Un esempio è che abbiamo il nostro host con il suo livello IP.<br />
<ul class="org-ul">
<li><a id="org1c57938"></a>Poi abbiamo tutti questi router intermedi con i loro livelli IP e un protocollo che li leghi (non ci interessa quale).<br /></li>
<li><a id="orge4d635d"></a>In ogni nodo ci sono delle code di ricezione \(RX\) e di trasmissione \(RT\) che hanno una capacità limitata.<br /></li>
<li><a id="org105214c"></a>Nonostante possiamo dare affidabilità al data-link, a questo livello IP, se il RT è in overflow, scarta un pacchetto e questo viene perso del tutto.<br />
<ul class="org-ul">
<li><a id="org38a8f49"></a>Nonostante ci sia una somma di link affidabili, questa non garantisca che tutta la comunicazione end-to-end sia affidabile.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org628bbd1" class="outline-3">
<h3 id="org628bbd1">In Transport viene riimplementata l'affidabilità in modo che quando un segmento venga perso, venga gestita la ritrasmissione.</h3>
<div class="outline-text-3" id="text-org628bbd1">
</div>
<div id="outline-container-org2957d96" class="outline-4">
<h4 id="org2957d96">La trasmissione su cavo è molto affidabile e quindi l'affidabilità a livello data link è passata in secondo piano e diventa più importante quella su tratte più lunghe, con tutta la rete in mezzo, che coinvolgono i router di livello 3.</h4>
</div>
</div>
<div id="outline-container-org820d2ca" class="outline-3">
<h3 id="org820d2ca">Le unità base di comunicazione a livello 4 sono chiamate <b>messaggi</b> o <b>segmenti</b>.</h3>
</div>
<div id="outline-container-org6aee2bc" class="outline-3">
<h3 id="org6aee2bc">Il livello di trasporto ha anche un suo indirizzamento (naming) utilizzando le porte, che servono per identificare l'applicazione che sta utilizzando il collegamento di livello 4.</h3>
<div class="outline-text-3" id="text-org6aee2bc">
</div>
<div id="outline-container-org38a0477" class="outline-4">
<h4 id="org38a0477">Mentre l'indirizzo IP serve per identificare l'host di rete</h4>
</div>
<div id="outline-container-org9fd84cf" class="outline-4">
<h4 id="org9fd84cf">Immaginiamo di avere un client ed un server con TCP o UDP a livello 4, IP sotto e poi una rete completamente trasparente.</h4>
<div class="outline-text-4" id="text-org9fd84cf">
</div>
<ul class="org-ul">
<li><a id="org19f2964"></a>Abbiamo poi delle applicazioni che comunicano, ad esempio app client e web server con db.<br /></li>
<li><a id="org09736b2"></a>Immaginiamo arrivi un pacchetto IP a livello server.<br />
<ul class="org-ul">
<li><a id="org484692b"></a>Il server legge il suo header e con il suo destination address sa che è destinato a lui.<br /></li>
<li><a id="org7dfed37"></a>Nello campo "protocol" ci sarà scritto se il pacchetto è da mandare ad IP o UDP.<br /></li>
<li><a id="org3d1ad61"></a>Le applicazioni ascoltano su una specifica porta (80 per http ecc.)<br /></li>
<li><a id="org9627db8"></a>TCP si chiede: a quale di queste operazioni appartiene questo segmento? in modo da smistarlo correttamente.<br />
<ul class="org-ul">
<li><a id="orgfd0c1bc"></a>Quindi l'IP address identifica tutto l'host, il PROTOCOL indica il protocollo di transport e la porta(?) indica l'applicazione specifica che usa i dati.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="orgb2bfab6"></a>Anche dal lato client, si parte dall'Application layer e si sceglie il corretto protocollo (TCP/UDP) da utilizzare.<br />
<ul class="org-ul">
<li><a id="orge215212"></a>Quindi l'IP e il protocollo da utilizzare sono informazioni necessarie per aprire la comunicazione.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgf149b7b" class="outline-4">
<h4 id="orgf149b7b">A livello di Trasporto si usano le socket.</h4>
<div class="outline-text-4" id="text-orgf149b7b">
</div>
<ul class="org-ul">
<li><a id="orgbf73e07"></a>Una socket è fatta così (stessa dell'immagine sul libro):<br />
<ul class="org-ul">
<li><a id="orgf326951"></a>Abbiamo un ClientAP e un ServerAP (access point), che noi richiediamo semplicemente e sono offerte dal sistema operativo.<br /></li>
<li><a id="org06f7d2a"></a>Fra i due AP abbiamo una transport entity<br /></li>
<li><a id="org22f285a"></a>Ogni applicazione contiene due buffer che sono RecevingBuffer e SendingBuffer.<br /></li>
<li><a id="org09d606d"></a>Le socket berkeley sono lo standard de facto, di Unix, che non è altro che un descrittore di file su cui si può effettuare scrittura e lettura.<br />
<ul class="org-ul">
<li><a id="orgf86a63b"></a>Una write scrive sull'SB e la read sull'RB<br /></li>
</ul>
</li>
<li><a id="org8fdb3da"></a>Poi abbiamo un istanza del protocollo TCP che se vede che va tutto bene (poi vedremo cosa vuol dire), prende carico dei dati e li trasmette in rete.<br /></li>
<li><a id="orgc5f4379"></a>C'è poi un altro livello di buffer, uno per ingresso e uno per uscita, aree di memoria temporanee che TCP riserva per tenere temporaneamente i pezzi di unità di informazione che devono essere ancora trasmessi.<br />
<ul class="org-ul">
<li><a id="orgc951871"></a>TCP lavora a stream di byte e c'è un ordinamento assoluto di essi e va garantito che il ricevitore le riceva nello stesso ordine.<br /></li>
<li><a id="org20546a7"></a>Immaginiamo ad esempio di inviare 1, 2 e 3 e che 2 venga perso.<br /></li>
<li><a id="orgdb4235e"></a>Dopo aver ricevuto il 3, il TCP lato client si rende conto che manca qualcosa.<br /></li>
<li><a id="org3135f63"></a>Il blocchetto 3 rimane temporaneamente in buffer e quando il blocchetto 2 arriva a destinazione, verrà sbloccato anche il successivo.<br /></li>
<li><a id="orgb6367ea"></a>Il buffer tcp d'uscita serve invece per tenere gli stream da mandare fino alla ricezione di un ACK.<br /></li>
</ul>
</li>
<li><a id="orgaacaee2"></a>Adesso, la velocità di lettura e scrittura sono diverse fra loro, diventa necessario mettere un buffer al centro.<br />
<ul class="org-ul">
<li><a id="org34e9374"></a>Se una macchina genera in modo troppo veloce e l'altra troppo lenta, chiederà di rallentare la trasmissione.<br /></li>
<li><a id="orgc1682f2"></a>Siamo a livello kernel e non abbiamo tanta memoria.<br />
<ul class="org-ul">
<li><a id="orgb46245a"></a>Se non mettessimo un limite alla memoria, i buffer si saturerebbero e non rispetteremmo le specifiche di TCP che ci offre la totale affidabilità nella trasmissione.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgc4fed66"></a>Con le socket si interagisce in questo modo, ovvero le API da utilizzare sono:<br />
<ul class="org-ul">
<li><a id="org298b6cd"></a>Abbiamo ancora i due access point client e server che si interfacciano con il TCP/UDP.<br />
<ul class="org-ul">
<li><a id="orgfe27986"></a>Il livello 7 (application) è implementato nello user space.<br /></li>
<li><a id="org1466ec2"></a>Il livello 4 è implementato nel kernel, quindi nel sistema operativo.<br /></li>
<li><a id="orga651052"></a>Il livello 3 anche<br /></li>
<li><a id="orgbe3f184"></a>Il livello 2 sulla scheda di rete, quindi a livello firmware<br /></li>
<li><a id="org0f34ee5"></a>Il livello 1 è il cavo.<br /></li>
</ul>
</li>
<li><a id="org791c5e5"></a>Nel server, ci sono:<br />
<ul class="org-ul">
<li><a id="org294abbf"></a>Una prima chiamata, bidirezionale, è <code>socket()</code>. Questa restituisce un descrittore di file aperto e bidirezionale, ovvero su cui si può leggere e scrivere.<br /></li>
<li><a id="orga29c601"></a>Poi c'è l'operazione di <code>bind()</code> a cui passiamo un indirizzo IP e una porta, che lega la socket a un indirizzo IP (0.0.0.0 se ascolti su tutti gli IP della macchina). O conosciamo l'IP o utilizziamo un indirizzo DNS e la porta o la sappiamo già o è una porta well-known, come 80 o 8080 per HTTP, 443 e 8443 per HTTPS, ssh sulla 22, DNS sulla 53UDP.<br /></li>
<li><a id="org80415a3"></a>Poi abbiamo <code>listen()</code> che dice alla socket di mettersi in ascolto sull'indirizzo indicato al <code>bind()</code>. Crea inoltre una coda di richieste.<br />
<ul class="org-ul">
<li><a id="org6906bce"></a>Anche qua, questa coda è finita e se arriva un bombardamento di richieste ovviamente il buffer si riempie e le successive richieste non saranno più gestite.<br /></li>
</ul>
</li>
<li><a id="org4ce9b07"></a>L'ultima chiamata è la <code>accept()</code>. Questa si blocca in attesa di una richiesta. Quindi è una richiesta bloccante. Aspetta che qualcuno arrivi per aprire una connessione.<br /></li>
<li><a id="orgb02ee09"></a>A questo punto, TCP non è ancora intervenuto ma ha stabilito tutte le parti necessarie per ottenere una comunicazione<br /></li>
</ul>
</li>
<li><a id="org3e2a012"></a>Nel client ci sono:<br />
<ul class="org-ul">
<li><a id="org862bf7e"></a><code>socket</code> come prima<br /></li>
<li><a id="org32aec14"></a><code>connect()</code>, bloccante, in cui, come nella <code>bind()</code> specifichiamo un IP e una porta per recapitare correttamente un messaggio.<br />
<ul class="org-ul">
<li><a id="orge7dd2bd"></a>Questa connect scatena un'apertura di connessione, (o il recapito di un messaggio in UDP), che sblocca il server attraverso la unlock, fa una <code>fork</code> che da luogo ad una nuova <code>socket()</code>, che effettuerà una nuova <code>bind()</code>.<br /></li>
<li><a id="org78ae44b"></a>Solo a questo punto viene tirata su la struttura del TCP con i 4 buffer.<br /></li>
<li><a id="org2a16b21"></a>Quando viene effettuata la prima chiamata <code>socket</code> nel server, viene creata solo la coda di richieste.<br /></li>
<li><a id="orgfdc6ecd"></a>Solo la seconda chiamata tira su tutto il sistema TCP indicato prima<br /></li>
<li><a id="org39979a8"></a>La porta della sorgente è scelta randomicamente.<br /></li>
</ul>
</li>
<li><a id="org88b9a6d"></a>Alla ricezione dell'ok della socket pronta dall'altra parte, si sblocca anche il client e da lì in poi la comunicazione è aperta e si possono utilizzare le system call tipiche dei file, ovvero <code>send()</code> e <code>receive()</code><br /></li>
</ul>
</li>
<li><a id="org66e186e"></a>Quando voglio chiudere, una delle due chiama una <code>close()</code><br />
<ul class="org-ul">
<li><a id="orgd3aa1a9"></a>Questa chiusura coinvolge anche l'entità TCP, ma finora abbiamo soltanto osservato TCP dall'esterno.<br /></li>
</ul>
</li>
<li><a id="org6f01679"></a>Con la quintupla [protocol, ipsrc, ipdst, portsrc, portdst] posso identificare la singola comunicazione che è stata tirata su dopo la serie di procedure appena indicata.<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgd4bd902" class="outline-4">
<h4 id="orgd4bd902">Il TCP garantisce che la comunicazione sia <b>affidabile</b> e <b>ordinata</b>.</h4>
<div class="outline-text-4" id="text-orgd4bd902">
</div>
<ul class="org-ul">
<li><a id="orgeccb981"></a>Opera inoltre un controllo di flusso, ovvero un controllo orizzontale, con un app sorgente che scrive e una dest che legge, entrambe ad un certo rate, in modo che non ci sia overflow.<br />
<ul class="org-ul">
<li><a id="org196e82d"></a>Questo avviene basandosi sul rate minore.<br /></li>
</ul>
</li>
<li><a id="orgb4b04c7"></a>Opera poi un controllo errori.<br />
<ul class="org-ul">
<li><a id="org491b792"></a>Mentre UDP avverte in caso di errori, TCP si occupa anche di risolverli, gestendo la ritrasmissione.<br /></li>
</ul>
</li>
<li><a id="orgbd9784a"></a>Opera poi un controllo di congestione, questa volta verticale.<br />
<ul class="org-ul">
<li><a id="orgfd0657c"></a>E' vero che TCP nasconde la rete sottostante, ma sa che c'è una rete e sa che questa è potenzialmente inaffidabile.<br /></li>
<li><a id="org0dc4362"></a>Sa che se vengono immessi troppi pacchetti su una rete, questa possa essere congestionata.<br /></li>
<li><a id="org469d9ff"></a>TCP prova ad intuire la congestione della rete e prevenire la perdita di pacchetti della rete, diminuendo il rate di trasmissione di questi ultimi.<br /></li>
</ul>
</li>
<li><a id="org4a4b4f1"></a>Inoltre, è orientata allo stream.<br />
<ul class="org-ul">
<li><a id="orgda924f6"></a>Il concetto su cui lavora è dello stream di byte, che devono arrivare tutti.<br /></li>
</ul>
</li>
<li><a id="orgca11749"></a>Poi, è orientato alla connessione.<br />
<ul class="org-ul">
<li><a id="org13c7610"></a>Prima di utilizzare le socket, leggervi e scrivervi, dobbiamo instaurare una connessione, aprendola, che mantiene un certo stato.<br />
<ul class="org-ul">
<li><a id="org836ca23"></a>Il drawback è che è necessario tenere lo stato e tutte le info per la connessione in memoria nel kernel, e dev'essere occupato durante tutta la comunicazione.<br /></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgcdb1ac6" class="outline-4">
<h4 id="orgcdb1ac6">Lo header TCP è rappresentato in pagine larghe 32 bit.</h4>
<div class="outline-text-4" id="text-orgcdb1ac6">
</div>
<ul class="org-ul">
<li><a id="orgae7f5e9"></a>Alla prima riga abbiamo 16 bit per porta sorgente e 16 per la destinazione<br /></li>
<li><a id="org5b6e5ed"></a>Alla seconda riga abbiamo i 32 bit per il numero di sequenza<br />
<ul class="org-ul">
<li><a id="orga2bcb13"></a>Il numero di sequenza indica il primo byte della lunghezza variabile di byte che compone il segmento.<br /></li>
<li><a id="org4e7463a"></a>Viene inizializzato al momento dell'istanziamento della connessione.<br /></li>
</ul>
</li>
<li><a id="org238dc41"></a>Poi abbiamo il campo ACK number, strettamente legato al precedente.<br />
<ul class="org-ul">
<li><a id="orgc8ba3f5"></a>Identifica il numero di byte che la destinazione di questa connessione ha correttamente ricevuto e qual è l'indice del prossimo byte che mi aspetto.<br /></li>
<li><a id="org219913d"></a>I due campi superiori vengono utilizzati per gestire i casi in cui ci sia una perdita di segmenti e gestire correttamente la trasmissione.<br /></li>
</ul>
</li>
<li><a id="org16334fc"></a>Nella terza pagina abbiamo:<br />
<ul class="org-ul">
<li><a id="org10a6e7f"></a>Poi c'è il campo TCP Header Length da 4 bit<br />
<ul class="org-ul">
<li><a id="org2f20920"></a>La dimensione dell'header è variabile, sebbene esista una lunghezza solitamente usata.<br /></li>
</ul>
</li>
<li><a id="orgfc243a6"></a>Poi 4 bit non utilizzati<br /></li>
<li><a id="orgf90b2c8"></a>Poi c'è una serie di 8 bit di controllo<br />
<ul class="org-ul">
<li><a id="org3e24100"></a>Prima il CWR, Congestion Window Reduced, che serve alla rete congestionata per notificare la situazione<br /></li>
<li><a id="org422cbee"></a>Poi lo ECE, &#x2026;. echo.<br />
<ul class="org-ul">
<li><a id="orgfbef6fc"></a>Solo i due superiori sono presenti sul Tanenbaum ma non sull'Halsall<br /></li>
</ul>
</li>
<li><a id="orgfebdda5"></a>Poi c'è un bit URGent, per indicare che certi dati sono urgenti e devono essere processati ASAP, superando l'ordinamento solito.<br /></li>
<li><a id="org5be73ac"></a>Poi c'è il campo ACK<br /></li>
<li><a id="orgf6ee6c7"></a>Poi PUSH, che serve per mandaare via i dati contenuti nel buffer della socket.<br />
<ul class="org-ul">
<li><a id="orgf2007ab"></a>Ad esempio, immaginiamo che stiamo mandando dei dati e scrivendo nel SendingBuffer.<br /></li>
<li><a id="org56b0e1b"></a>Il TCP riempie un segmento di una certa dimensione e poi lo manda quando ha una certa dimensione.<br /></li>
<li><a id="org04a5007"></a>In alcuni casi, può essere necessario che tutti i dati vengano salvati immediatamente<br /></li>
<li><a id="org95b505d"></a>La differenza con lo urgent è che in questo caso il valore viene mandato da solo ma rispettando l'ordine.<br /></li>
</ul>
</li>
<li><a id="org423f91d"></a>Poi ci sono RST, SYN e FIN che non ho ascoltato. Reset, sincronizzazione e chiudi connessione.<br /></li>
</ul>
</li>
<li><a id="orgfca4da2"></a>I restanti 16 bit di Window Size indicano lo spazio ancora disponibile nel ricevitore.<br />
<ul class="org-ul">
<li><a id="org321788c"></a>Chi sta trasmettendo, leggendo questo campo può capire se l'altra macchina sostiene il rate o deve rallentare.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="org6f8b015"></a>Nella quarta pagina:<br />
<ul class="org-ul">
<li><a id="org4251c67"></a>Un checksum a 16 bit, che poi vedremo come viene calcolato, che ci permette di capire se tutto è corretto e viene collegato sulla base dello pseudoheader e tiene anche conto della conformità del payload (controllo degli errori)<br />
<ul class="org-ul">
<li><a id="orgeca80b9"></a>Lo pseudoheader è una versione ridotta dello header.<br /></li>
</ul>
</li>
<li><a id="org88a840e"></a>Poi uno Urgent Pointer, che viene letto se e solo se il frame urgent è a 1, altrimenti non ce ne frega perchè viene trascurato.<br />
<ul class="org-ul">
<li><a id="org43425d3"></a>Indica l'offset all'interno del campo data oltre il quale i dati sono urgent.<br /></li>
<li><a id="orgdb7171e"></a>Per convenzione, i dati urgent vengono messi alla fine del segmento e quindi non spazio per la fine della parte urgente.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="orgb320454"></a>Dopodichè abbiamo le options, parole di 16 bit di cui può esserci un numero variabile.<br /></li>
<li><a id="orgce3de48"></a>Dopo le n options, c'è il payload.<br /></li>
</ul>
</div>
<div id="outline-container-orge718e2f" class="outline-4">
<h4 id="orge718e2f">Come si diceva, TCP è orientato alla connessione.</h4>
<div class="outline-text-4" id="text-orge718e2f">
</div>
<ul class="org-ul">
<li><a id="org8911b7f"></a>La connessione è bidirezionale, ma noi analizzeremo solo un lato della connessione, perchè analizzare entrambe sarebbe molto confuso.<br />
<ul class="org-ul">
<li><a id="org9dd0300"></a>Ognuno trasmette e riceve in modo di indipendente. Quindi la sequence e lo ACK sono relativi solo ad una direzione della connessione.<br /></li>
</ul>
</li>
<li><a id="org0c7ea48"></a>All'apertura della connessione, da entrambe le macchine viene generato un sequence number ISN casuale, per ragioni di sicurezza<br />
<ul class="org-ul">
<li><a id="org018bdb2"></a>Altrimenti si potrebbe indovinare un numero ed inserirsi nella connessione<br /></li>
<li><a id="org5228d29"></a>I due flussi, e quindi i due numeri di sequenza, sono indipendenti.<br /></li>
</ul>
</li>
<li><a id="orgad02050"></a>A chiede di aprire una connessione e manda un segmento con il frame SYN = 1 e il Seq = X (quello generato casualmente da A).<br /></li>
<li><a id="org8f8d4d3"></a>B riceve il segmento e ne manda uno di risposta in cui SYN = 1, ACK = 1, Seq = Y (quello generato casualmente da B) e Ack = x + 1.<br />
<ul class="org-ul">
<li><a id="org1f85570"></a>Il bit di ACK attivato indica che il valore in Ack è significativo è può essere letto.<br /></li>
<li><a id="org1becca0"></a>Lo ack a x+1 indica che si è pronti ad andare avanti con la trasmissione. Il primo segmento parte da x ed è lungo 1, quindi il prossimo che sono pronto ad ascoltare è il successivo.<br /></li>
</ul>
</li>
<li><a id="orgdc08f70"></a>A riceve il segmento e risponde con ACK=1 e Ack = y+1<br /></li>
<li><a id="orga96c2a3"></a>In tutti i 3 segmenti superiori, il valore del resto dello header e payload non importano.<br /></li>
<li><a id="org388864b"></a>La procedura prende il nome di three-way handshake.<br /></li>
<li><a id="org712da78"></a>Gestione casi delicati<br />
<ul class="org-ul">
<li><a id="org1752cf3"></a>Viene introdotto un Timer, RTO, che gestisce il caso in cui uno fra i primi due segmenti di handshake vengano persi.<br />
<ul class="org-ul">
<li><a id="org7df8fbc"></a>Come nel data link, se il timer scade perchè uno qualunque dei primi frame è scomparso, si prova ad aprire nuovamente la connessione.<br /></li>
</ul>
</li>
<li><a id="orgac96eb9"></a>Il timer gestisce anche i casi in cui l'handshake di risposta ci impieghi troppo ad arrivare ( o si può dire che dopo il tempo \(T\) si assuma che la connessione è persa e bisogna gestire il caso in cui la risposta invece arrivi)<br />
<ul class="org-ul">
<li><a id="orgd66cae4"></a>Ogni nuova riapertura aggiorna il SEQ casuale<br /></li>
<li><a id="org740de66"></a>Se arriva una risposta per un apertura precedente, è facile dal numero di sequenza capire che non sia la risposta corretta<br /></li>
<li><a id="org11f2d10"></a>In tal caso, si manda un messaggio con RST e si chiude la connessione.<br /></li>
</ul>
</li>
</ul>
</li>
<li><a id="org678e8e5"></a>Utilizzando lo stesso concetto di base del port scanning, si può fare SYN FLOOD.<br />
<ul class="org-ul">
<li><a id="org222b833"></a>Mando tanti messaggi di SYN sulle varie porte.<br /></li>
<li><a id="orgf449e69"></a>Il server mi risponde genuinamente e attende per la mia 3 risposta, finale, di handshake.<br /></li>
<li><a id="org7516294"></a>Io non rispondo e il server deve allocare risorse per tanti syn aperti contemporaneamente.<br /></li>
<li><a id="org9877b26"></a>Se invece rispondo con un RST, non effettuo un attacco e non peso sulle risorse, ma analizzo soltanto le porte aperte.<br />
<div class="outline-text-6" id="text-org9877b26">
<p>
lesgoski
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-11-20 Wed 19:49</p>
</div>
</body>
</html>
