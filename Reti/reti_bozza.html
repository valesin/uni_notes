<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-02-04 Tue 18:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retibozza</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Retibozza</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org08bb564">References</a></li>
<li><a href="#org29180fd">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org2228452">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd6cc51b">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org5df9786">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgaf438d0">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org950ccae">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org3605f48">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org763e335">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orge526da8">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org84cbc5f">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org36124a3">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgb0469e7">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgbc3728a">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org1eb8280">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd77b681">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orge6c8b46">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org2af6a5a">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd2c93e7">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org71205b8">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org98d5d71">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd570d63">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org90fd521">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org56b2f6c">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org660452f">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org8527999">Introduciamo il DHCP&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org41d4771">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org41ad2dc">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org728728f">Ci rifacciamo alla stessa struttura riguardante il routing, con un router che contiene un forwarder con porte IO di ingresso ed uscita e che opera su una tabella di routing, facendo un lookup e stabilendo la corretta porta di output. Chi scrive sulla tabella è il router, che ha i propri pacchetti di controllo e opera come un processo totalmente asincrono ed indipendente.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org186bd41">Supponiamo di avere due macchina che ha uno strato applicativo, seguito da TCP, IP ecc&#x2026;, attaccata ad una rete IP.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org51c9001">Al livello 3 c'è un processo chiamato router, autonomo rispetto al forwarder. Questa separazione ci facilita la costruzione e l'implementazione dell'instradamento e la sua messa in cloud.</a>
<ul>
<li><a href="#orgb93c5a2">Il forwarder è un punto delicato per l'efficienza, perchè fa numerose operazioni, facendo lookup di source e address dello header ip per instradare correttamente il pacchetto.</a></li>
<li><a href="#orgb34c0d2">Nell'area 0, ovvero backbone, di un sistema autonomo, i router hanno un carico notevole. Più aumentiamo l'efficienza dei router interni alla backbone area, migliore è il risultato dell'intera rete.</a>
<ul>
<li><a href="#orge7d12a6">Viene usato il Multi-Protocol Label Switching, in cui ogni router contiene una <b>tabella di etichette</b>.</a>
<ul>
<li><a href="#org9c4de35">Il primo router, un area border router, ovvero quello che fa da interfaccia fra il gateway e la backbone, è un router di etichetta, ovvero aggiunge o rimuove un intestazione MPLS a cui tutti i router della backbone fanno riferimento, ignorando lo header IP.</a></li>
<li><a href="#org56f0ae8">In questo modo, il loro lavoro diventa molto più veloce, un po come lo switching del data link.</a></li>
<li><a href="#org477e7c1">Ogni router contiene una tabella <b>per ogni porta</b>, che spiega dove switchare il pacchetto <b>a seconda dell'etichetta</b>, insieme alla politica di accodamento e scheduling (prossime lezioni)</a>
<ul>
<li><a href="#org309454b">Quindi, posso creare dei gruppi di tipi di pacchetto affini, che seguano direzioni diverse a seconda del servizio richiesto (sul libro classi equivalenti di inoltro)</a></li>
<li><a href="#orgf524204">Non solo minimizza il tempo necessario per la commutazione, ma permette anche di effettuare load-balancing.</a></li>
</ul>
</li>
<li><a href="#orgfbf0a04">Lo header di mpls contiene un etichetta a 20 bit, la classe di servizio e il ttl</a></li>
<li><a href="#orgc93b280">Di fatto, come per l'sdn nell'instradamento, cè un entità esterna, il network manager, che ha le funzionalita di segnalazione e segnala ai LSR (label switched router) e LER(stesso ma sulla Edge) informazioni per gestire al meglio la rete</a>
<ul>
<li><a href="#orgb3d05a8">Ad esempio si potrebbe imporre di seguire un percorso più lungo ma meglio distrbuito.</a></li>
</ul>
</li>
<li><a href="#org2dcd48f">Nel campo della Class of Service è inserita una flag dal livello 4 o applicazione, che specifica come gestire quel campo.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org63c9577">Il traffico realtime, come la telefonia su internet o la conferenza su internet, è associato ad una jitter sensitivity ed aldelay associato ad un singolo pacchetto.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org6c58e92">IPV6 è uguale ma con molte meno opzioni</a>
<ul>
<li><a href="#orgacbf0d2">Inoltre il time to live si chiama hop count</a></li>
<li><a href="#org190842a">Type of service si chiama traffic class</a></li>
<li><a href="#orga8fc6a9">c'è il campo next header che è nuovo ed è un puntatore ad un estensione dello header</a>
<ul>
<li><a href="#orgb0d3fd5">La motivazione per cui è usato è che il nuovo header è molto spoglio e non esistono le option</a></li>
<li><a href="#orga48b3af">Quindi è possibile aggiungere nuovi header</a>
<ul>
<li><a href="#orgd63e1fc">Fra i possibili header esistono:</a>
<ul>
<li><a href="#orgf75e90b">hop by hop, usati per i jumbo packets, pacchetti più grandi di 65k</a>
<ul>
<li><a href="#orgec1971f">In distanze lontane, quello che interviene come parametro è il tempo di propagazione</a></li>
<li><a href="#orgb096d71">Più roba riesco a mandare concatenata, più aumento l'utilizzo</a></li>
</ul>
</li>
<li><a href="#orge0c0f09">routing per il source routing</a>
<ul>
<li><a href="#org1a98cf7">il campo bit map avrà tanti bit settati quanti sono gli indirizzi da visitare</a>
<ul>
<li><a href="#org8f3610c">Il valore di questi bit è 0 o 1 a seconda di come si comportano</a>
<ul>
<li><a href="#org74842fd">Con la strict routing impongo che venga visitato un certo router</a></li>
<li><a href="#orgeb1377c">Loose può usare quanti hop vuole in mezzo a due ip selezionati</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9c5ee35">In realtà lo spazio ammesso non è 24 come la bitmap sembrerebbe permettere, ma 23 (per qualche motivo da controllare)</a></li>
</ul>
</li>
<li><a href="#orgdef0770">fragment</a></li>
<li><a href="#org2e70535">authentication</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgec0bf72">Ogni next header viene ins</a></li>
</ul>
</li>
<li><a href="#org133784b">L'indirizzo di ipv6</a>
<ul>
<li><a href="#org23a084f">può inglobare ipv4 con tutti 0 o tutti 0, poi 16 1 e in ogni caso alla fine 32 bit di ipv4</a></li>
<li><a href="#org0f4b50e">è diviso in varie sezioni in modo da snellire le tabelle di routing per ad esempio i router ad alto livello che vogliono smistare velocemente</a></li>
</ul>
</li>
<li><a href="#org11ffd1b">IPV6 coesiste con IPV4, per cui può capitare che ci siano macchine IPV4 e IPV6, che vogliono parlare con lo stesso server.</a>
<ul>
<li><a href="#org9d275ff">Quel server deve avere entrambe le opzioni</a></li>
<li><a href="#org217aba2">Può capitare anche che due macchine ipv6 passino attraverso un router ipv4</a>
<ul>
<li><a href="#org16cdf77">In questo caso si fa tunneling</a></li>
</ul>
</li>
<li><a href="#org7198a79">Quando una macchina IPV6 parla con IPV4, serve che ci sia in mezzo un NAT, diverso da quello che abbiamo studiato, che mappa degli indirizzi 6 su IPv4</a>
<ul>
<li><a href="#org4d340af">Il gateway usa degli indirizzi pubblici dinamici per la rete interna con cui le macchine all'interno comunicano e il gateway si occupa della comunicazione con IPv6 in modo trasparente alla stazione</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcee69f3">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org8d7197d">Quindi siamo arrivati al SYN che uno manda per aprire la connessione, con un numero di sequenza generato in numero casuale. Il canale è bidirezionale e quindi avviene tutto nello stesso modo in entrambi gli host.</a>
<ul>
<li><a href="#org4a35ac4">Il SYN parte a 1, in risposta il SYN è a uno e anche l'ACK, che indica che il campo Ack è significativo e tale campo è numDiSequenza +1, per indicare che quello è il prossimo bit che si è pronti a ricevere.</a>
<ul>
<li><a href="#orgb1b713d">Ovviamente manda anche il proprio numero di sequenza.</a></li>
</ul>
</li>
<li><a href="#org79f9b79">Se tutto va a buon fine, la terza risposta dal sender è uguale alla seconda dal receiver e da lì in poi la connessione è aperta.</a></li>
<li><a href="#orgcc32eac">C'è un timer che garantisce che se l'ACK viene perso, o impiega troppo tempo ad arrivare, venga mandato un messaggio con RESET a 1 che annulla l'handshake, che va rieffettuato</a></li>
<li><a href="#org369f4fe">In ogni header è indicato il Max Segment Size, che indica la dimensione massima di segmento che l'host può gestire senza andare in overflow.</a>
<ul>
<li><a href="#org127bb79">La dimensione Standard, quando il campo è vuoto, il segmento è di 536 byte.</a></li>
</ul>
</li>
<li><a href="#org97bcd2a">L'obiettivo di TCP è trasferire i dati nel miglior modo, garantendo affidabilità, gest.errori, ordine ecc., e anche farlo in modo efficiente, evitando un overhead eccessivo</a></li>
<li><a href="#org7150122">Il motivo per cui viene scelta 536 byte è che siamo sicuri che il livello IP non frammenterà tale segmento in più pacchetti.</a>
<ul>
<li><a href="#org708ecef">Per ogni frammentazione effettuata dall'IP, serve copiare sia header TCP che IP, introducendo overhead.</a></li>
<li><a href="#orgafd2787">Inoltre, essendo la rete best-effort, quanti più sotto-segmenti vengono mandati quanto più è probabile che avvengano dei problemi che dovranno essere poi gestiti</a></li>
</ul>
</li>
<li><a href="#org88522cb">Immaginiamo di avere una connessione A-B in TCP, necessariamente bidirezionale.</a>
<ul>
<li><a href="#orgec68a1b">Dato che noi analizziamo solo i casi "unidirezionali", noi valutiamo solo SendingBuffer e TcpSendingBuffer nel sender, e i corrispondenti ma per il receiver nel receiver.</a></li>
<li><a href="#org90fbe8c">Assumiamo che la segment size sia 500.</a></li>
<li><a href="#org956ec3b">L'applicazione lato sender scrive 2000 byte nell'SB della socket esposto.</a></li>
<li><a href="#org4d97452">Ovviamente, va eseguita una frammentazione a livello trasporto.</a>
<ul>
<li><a href="#orgfe25b21">Assumiamo per ora che non avvengano problemi nella trasmissione.</a></li>
</ul>
</li>
<li><a href="#orgeba6369">Nel sending buffer della TCP, nascosto al livello applicazione, vengono copiati e segmentati opportunamente i byte del buffer superiore.</a></li>
<li><a href="#org7be641f">Nello header è presente l'informazione SEQ=X. Il payload sarà dal byte X a quello X + 499</a>
<ul>
<li><a href="#org7033c48">X è in realtà X+1 se la connessione è appena stata instaurata, ma per semplicità si considera X il valore corrente.</a></li>
</ul>
</li>
<li><a href="#org10abce3">Nel frattempo, il receiver si aspettava il Sequence Number = X e così si accerta che l'ordine sia corretto.</a></li>
<li><a href="#org0d8e819">I dati arrivano nel buffer inferiore, ma dato che l'ordine è corretto, vengono subito copiati nel buffer superiore.</a></li>
<li><a href="#orgf479fad">Lo header risposta del receiving buffer contiene il campo ACK a 1 e quello Ack a X + 500, che è il primo byte successivo a quello ricevuto.</a>
<ul>
<li><a href="#org48407ef">Implicitamente vuol dire che il segmento precedente è correttamente ricevuto.</a></li>
</ul>
</li>
<li><a href="#orgc124063">Il sender elimina dal buffer del TCP il segmento corrispondente.</a></li>
<li><a href="#org30f28c9">Allora, il prossimo segmento mandato è quello che parte da X+500 e questo valore è nel SEQ dello header.</a></li>
<li><a href="#org7fbf26a">Anche questo pacchetto è in ordine e quindi va subito spostato nel buffer superiore.</a>
<ul>
<li><a href="#org6eb57e0">Il TCP tiene tutti i segmenti non in ordine nel buffer inferiore.</a></li>
<li><a href="#org6d365fb">Ogni segmento correttamente ricevuto, ma successivo ad un segmento non ricevuto, rimane nel buffer inferiore.</a></li>
</ul>
</li>
<li><a href="#orgc459ccd">Analogamente al messaggio precedente, il receiver risponde con un Ack = X+1000.</a>
<ul>
<li><a href="#org5ef5d5c">Anche adesso, il sender si libera del segmento.</a></li>
</ul>
</li>
<li><a href="#org1657fe8">Procedo così fino allo svuotamento del buffer di invio.</a></li>
</ul>
</li>
<li><a href="#orge9c6f80">Nella configurazione precedente, c'è un problema nel caso in cui ho bisogno di (real-time?) ad esempio ssh su una console remota.</a>
<ul>
<li><a href="#orgf31e32d">Voglio che i dati vengano processati byte per byte</a></li>
<li><a href="#orgf3a82b7">Allora uso la flag PUSH, in modo che TCP spedisca il singolo byte, senza arrivare ad una dimensione del segmento di 500 byte come prima</a></li>
<li><a href="#orgc1a8f6c">Quando PUSH viene usata, il receiver manda un regolare ACK, con Ack X+1</a></li>
<li><a href="#orge4e09de">In questo caso, però, viene fatta una eco dello stesso byte, questa volta</a></li>
<li><a href="#org4fc03d8">Il motivo per cui viene fatta la eco è che il sender prende input a tastiera ma non mostra direttamente a schermo, perchè non è sicuro che dall'altra parte sia correttamente ricevuto. Solo quando si è sicuri che dall'altra parte sia stato ricevuto, viene stampato a tastiera</a></li>
</ul>
</li>
<li><a href="#org9e7ab83">Per garantire&#x2026;(?) viene introdotto il delay acknowledgment.</a>
<ul>
<li><a href="#org7afb419">La questione è che TCP ignora l'obiettivo delle applicazioni, ma loro lo sanno e potrebbero voler inserire più informazioni nello header.</a></li>
<li><a href="#orga25a70e">Immaginiamo una situazione come prima: si riceve un byte pushato.</a></li>
<li><a href="#orgd8eb813">Il receiver, però, non risponde subito con un Ack, ma aspetta un tempo (standard 200ms).</a></li>
<li><a href="#org081b0fc">Se in quel tempo arriva qualcosa nel buffer di invio del ricevitore, quei dati vengono incorporati nel messaggio di Ack.</a>
<ul>
<li><a href="#org8f27e17">In questo caso, sia sequence che ack number sono considerati. Seq è quello che ti do, ack quello che prendo.</a>
<ul>
<li><a href="#org95fadc3">Prima invece, il campo sequence non era mai impostato</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcf08a4e">In questo caso, quando la eco viene aggiunta nel buffer di invio della ricezione, viene inserita nello stesso frame di Ack. Così ri risparmia un messaggio TCP.</a>
<ul>
<li><a href="#orgd67c8a4">Il prossimo messaggio del sender sarà sia un ACK della echo che un send del byte successivo.</a></li>
</ul>
</li>
<li><a href="#org51c0a00">Questa soluzione è efficiente dal punto di vista di rete, ma inefficiente dal punto di vista della user-experience.</a>
<ul>
<li><a href="#org1899905">Per trovare un compromesso fra rete e user-experience, si utilizza la tecnica del <b>NAGLE</b>.</a>
<ul>
<li><a href="#org3b817da">Ho un sender con una serie di segmenti composti da un singolo byte da pushare.</a></li>
<li><a href="#org8472f26">Come prima, mando un segmento con il byte, il receiver lo riceve e aspetta 200ms.</a>
<ul>
<li><a href="#orgcac7180">L'applicazione riceve il byte e fa la ACK + echo, con SEQ = Y, PUSH attivato, ACK attivato e Ack = X + 1</a></li>
</ul>
</li>
<li><a href="#org625a319">I successivi byte vengono impacchettati in un singolo segmento e mandati tutti insieme. Il receiver risponde con l'ack.</a>
<ul>
<li><a href="#org14d9f72"><span class="todo TODO">TODO</span> Capire se viene effettuata la echo dei byte in blocco e se viene fatta byte per byte o cumulativa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8944071"></a></li>
</ul>
</li>
<li><a href="#org2f34f11">In caso di errori, è lo stesso TCP che se ne accorge e cerca di sanarlo.</a>
<ul>
<li><a href="#org0a4374b">TCP è orientato allo stream.</a>
<ul>
<li><a href="#org7aff566">Abbiamo già visto che a livello 2 ogni pacchetto è identificato da un numero che viene utilizzato per riconoscere i frame su cui avviene l'errore.</a></li>
<li><a href="#orgd7e5892">In TCP l'idea del sequence number è che, conoscendo la dimensione del file \(N\), il segmento va da \(X\) a \(X+N\).</a></li>
<li><a href="#org1ec49de">Ci interessa capire fino a che punto dello stream è stato ricevuto tutto correttamente.</a>
<ul>
<li><a href="#org981b590">Ovvero, l'indice \(K<N\) fino a cui è assicurata la comunicazione avvenuta correttamente.</a></li>
</ul>
</li>
<li><a href="#org6aeaa0d">Quindi il sequence number sommato al payload, mi da il nuovo numero di sequenza.</a></li>
<li><a href="#org4aca1dd">Immaginiamo di avere una situazione in cui l'app sender debba spedire 2400 byte con una dimensione del segmento di 500.</a></li>
<li><a href="#orged74cfe">Il primo segmento viene spedito con SEQ=X.</a></li>
<li><a href="#orge9c5362">Il secondo viene spedito senza aspettare l'ACK, con SEQ=X+500</a></li>
<li><a href="#orgf0576e2">Si immagini adesso che il secondo segmento venga perso.</a></li>
<li><a href="#org4d199b0">Nel frattempo, il receiver risponde con un ACK per il primo segmento, ovvero con Ack X + 500 e dato che il segmento è nell'ordine corretto, questo viene spedito al buffer superiore.</a></li>
<li><a href="#orgde9e891">Quando il secondo segmento è spedito ma non è stato ricevuto l'ack corrispondente, il segmento è ancora nel sending buffer del tcp del sender.</a></li>
<li><a href="#org604fc18">Comunque non aspetto l'ACK del secondo, perchè essendoci la rete per mezzo, non posso sapere se arriverà a breve o non arriverà.</a></li>
<li><a href="#org2926dd8">Quindi mando il terzo, con SEQ=X+1000.</a></li>
<li><a href="#org8e94444">Quando il receiver riceve questo segmento, lo mette nel suo buffer, ma risponde con lo stesso ACK di prima.</a>
<ul>
<li><a href="#orgac4ceb9">Ovvero, si intende che sebbene qualcosa sia ricevuto, non "riempie lo spazio" di ciò che non era stato ricevuto.</a></li>
</ul>
</li>
<li><a href="#orgdc46ecb">La questione è che ogni segmento attiva un timer. Finchè il timer non scade, TCP prosegue con <b>tutti</b> i segmenti successivi in buffer d'invio.</a></li>
<li><a href="#orga85e9e4">Quando il timer scade, soltanto quello specifico segmento viene inviato.</a></li>
<li><a href="#org9eb6a05">A questo punto, il ricevitore si renderà conto che quel segmento, il secondo in questo caso, va posizionato prima dei successivi, che già possiede nel buffer. Allora tutti quelli successivi saranno sbloccati ed il prossimo ACK li includerà. Si parla quindi di ACK cumulativo.</a></li>
<li><a href="#org1f07b7c">Questa roba si chiama <b>fast retransmit</b>, ovvero la ritrasmissione di un singolo segmento.</a></li>
<li><a href="#org2e5d87f">Il timer è pensato per considerare il caso di perdita, anche abbastanza inusuale, sovradimensionato.</a></li>
<li><a href="#orgd8a60ef">Si usa però anche una strategia del triplo ACK: al terzo ACK uguale ricevuto, viene inviato il segmento corrispondente.</a></li>
<li><a href="#org39715f4">Usando queste due strategie, si limita il danno sull'efficienza del timeout e si rende più veloce l'invio dei segmenti precedenti.</a>
<ul>
<li><a href="#org9414a7a">Ad esempio, si fa in modo che tutti i segmenti in coda nel buffer a cui serve quello perso per sbloccarsi, debbano aspettare al massimo T ma spesso anche di meno, così da ridurre lo spazio di memoria occupato.</a></li>
</ul>
</li>
<li><a href="#org36c6f51">Il timer è anche molto utile per gli ultimi (?)2 segmenti, dopo i quali non esistono 3 ack che facciano partire la ritrasmissione.</a>
<ul>
<li><a href="#org0ddf778"><span class="todo TODO">TODO</span> Per quanti segmenti vale questa proprietà</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3f50fe8">Negle ha un utilità quando vogliamo garantire un utilizzo efficiente della rete.</a>
<ul>
<li><a href="#orgc085dba">Lo si usa al posto di mandare ogni carattere da solo, con un overhead altissimo dovuto allo header IP e TCP.</a>
<ul>
<li><a href="#org9c0f8c9">Per mandare un byte, mi servono 4 messaggi.</a></li>
<li><a href="#orgfe24cd3">Si usa il delay per diminuire i messaggi che vengono mandati, ma si paga troppo tempo per l'attesa del delay ogni volta, con piggy bagging in cui nei dati da comunicare si inserisce anche l'ack cumulativo</a></li>
<li><a href="#org2b1eaca">Un compromesso e il nagle</a></li>
</ul>
</li>
<li><a href="#orga18f056">Il Nagle viene in supporto quando abbiamo un quantitativo di dati dall'applicazione, ovvero nel SB (superiore) che è minore alla maximum segment size.</a>
<ul>
<li><a href="#orgb3be167">Nagle innanzitutto guarda il TCP Sending Buffer (quello inferiore). Se è vuoto vuol dire che non sto aspettando nessun ACK.</a>
<ul>
<li><a href="#org91bb292">In questo caso, invio direttamente il contenuto dell'SB, nonostante sia inferiore.</a></li>
</ul>
</li>
<li><a href="#org9d2b855">Se invece ci sono altri segmenti nel buffer inferiore, lo accoda.</a></li>
<li><a href="#orgb8c6e61">Uno dei lati negativi di Nagle è che sebbene utilizzi bene la rete, ovvero limitando l'overhead, (QUAL è L'ASPETTO NEGATIVO)?</a></li>
</ul>
</li>
<li><a href="#orgd69112e">Un altro aspetto è che tcp è orientato allo stream e ragiona in base ai bit.</a>
<ul>
<li><a href="#org8b90cf5">Una sequenza di dati presente nel sending buffer non dev'essere multiplo della max segment size. Il TCP suddivide in blocchetti della dimensione corretta.</a>
<ul>
<li><a href="#org7bcad21">Se un ultimo blocchetto non raggiunge la max segment size, sta all'applicazione decidere se mandarlo subito o se aspettare nuovi dati, la cui prima parte verrà aggiunta all'ultimo segmento e mandata tutto insieme.</a></li>
</ul>
</li>
<li><a href="#orga713985">Quindi si parla di segmento numero n come divisione logica, ma tutto è relativo al byte di inizio sequenza.</a></li>
<li><a href="#org5551980">Il principio è che si occupa il meno possibile. L'eventuale padding è fatto ai livelli inferiori.</a></li>
</ul>
</li>
<li><a href="#org42c0bb3">Quando TCP invia un pacchetto ad IP, quest'ultimo, conoscendo perfettamente la max transfer unit del suo livello 2, frammenta ulteriormente se necessario.</a>
<ul>
<li><a href="#org3cb370e">IP stesso riassemblerà poi la serie di pacchetti e la fornirà a tcp</a></li>
<li><a href="#org18520ee">Se non ci riesce, a TCP non arriverà assolutamente nulla.</a>
<ul>
<li><a href="#orgb80414d">Inoltre, solo il primo pacchetto avrà lo header tcp.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org391b8a0">Come abbiamo già visto, il round trip time è il tempo necessario perchè un segmento venga inviato ed ackAto.</a>
<ul>
<li><a href="#orgc18b325">Possiamo però anche inviare più segmenti nello stesso momento.</a></li>
<li><a href="#org863348b">Ogni segmento fa partire un timer, che dev'essere dimensionato correttamente e quindi non può essere statico.</a></li>
<li><a href="#org74b4664">Esiste uno standard che ci spiega come calcolarlo</a>
<ul>
<li><a href="#org6cd48c7">Diciamo che il round trip time in media impieghi 30 ms</a></li>
<li><a href="#org5b2f1c1">La stima viene fatta considerandolo come un outlier della distribuzione.</a>
<ul>
<li><a href="#orgaaadd7f">Tipicamente si dice che un valore di +3sigma, quindi media più 4 deviazioni standard ci da una stima di un caso molto raro di outlier.</a></li>
<li><a href="#org5fd2948">Quindi dobbiamo sapere la media e la deviazione standard in base ai dati del round trip time.</a>
<ul>
<li><a href="#org1d457dd">INSERIRE FORMULA</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org13990b6">Il controllo di flusso viene messo in atto quando il produttore produce molto più velocemente del ricevente.</a>
<ul>
<li><a href="#orge271806">Infatti, il buffer di ricezione andrebbe poi in overflow.</a>
<ul>
<li><a href="#org6c49477">Immaginiamo di avere una situazione in cui il sending buffer è di 3000 e il receiving 2000. (mss sempre 500 (ma standard 512)).</a>
<ul>
<li><a href="#orgcb9ff54">L'informazione della dimensione dell'altro è nota ad entrambi.</a></li>
<li><a href="#org14b05a4">Una volta che il sender ha mandato 2000 bit (in 4 tranche perchè la finestra è di 500), il receiving manda non solo un ACK per controllo errori, ma anche un WIN=0, per il controllo di flusso, che indica che lo spazio è finito.</a></li>
<li><a href="#org8af79f2">Quando avrà poi letto 1000 byte, manderà un ACK con lo stesso byte atteso del precedente, ma una window size di 1000.</a></li>
</ul>
</li>
<li><a href="#org41f9561">Il problema è che se il secondo ack di riapertura viene perso, il sender rimarrebbe bloccato per sempre, ovvero si avrebbe un deadlock.</a>
<ul>
<li><a href="#orgc40fde9">Allo scadere di un Persist Timer nel receiver, viene mandato un segmento speciale vuoto, ovvero senza dati, a cui il receiver risponde con un reinvio dell'ack con nuova finestra.</a>
<ul>
<li><a href="#orga116e27">Se anche quel nuovo ack è perso, allo scadere di un nuovo timer la connessione sarebbe chiusa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgae545f3">Il problema della silly window syndrome accade quando il receiver riempie la propria window e continua a notificare la nuova disponibilità ma per una quantità di byte minima.</a>
<ul>
<li><a href="#orgfc8453e">La soluzione è l'algoritmo di Clark, in cui l'aggiornamento della windows dev'essere almeno grande come la MSS o come la metà del buffer.</a></li>
</ul>
</li>
<li><a href="#org5af507a">La rete ignora completamente il controllo di flusso.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org149aae6"><span class="todo TODO">TODO</span> Riempire con ultime 2 lezioni di livello 4</a></li>
<li><a href="#orgc668dca">Iniziamo il livello applicazione parlando del DNS, ovvero il Domain Name System.</a>
<ul>
<li><a href="#orge0cbd2e">E' un sistema che permette di rendere più semplice raggiungere un host</a>
<ul>
<li><a href="#orgee697e9">Normalmente si usa un IP per raggiungere un host, ma è praticamente impossibile ricordare un IP.</a></li>
</ul>
</li>
<li><a href="#orgaebad13">Funziona associando un nome (dominio) all'ip di uno specifico host.</a>
<ul>
<li><a href="#orgb0cf427">Permette anche di recuperare altre informazioni</a></li>
</ul>
</li>
<li><a href="#org3ffa469">L'idea è quella di disaccoppiare il modo in cui un essere umano raggiunga un certo servizio.</a>
<ul>
<li><a href="#org5b11c5c">Ad esempio il servizio potrebbe cambiare indirizzo ip in modo trasparente agli utenti.</a>
<ul>
<li><a href="#org2eb4f2f">Questo è utilizzato anche per il load balancing, così che il traffico venga diviso su diversi server.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2fd1e69">Il fully qualified domain name (FQDN) contiene un punto alla fine che indica il root domain</a></li>
<li><a href="#org25b72aa">Il modo in cui avviene la risoluzione del FQDN fra due macchine, ovvero fra un host che richiede e il server che risponde, è sostituendo ad ogni punto il numero di caratteri che seguono quel punto prima di quello successivo, esempio 2DI5UNIMI2IT0.</a></li>
<li><a href="#org8389264">Una query DNS contiene uno header, il FQDN specifico, il tipo di query(A, AAAA, Mx), la classe (che indica la rete su cui si vuole risolvere, che di fatto è sempre internet)</a>
<ul>
<li><a href="#org5db6117">Il tipo può essere2 A per IPv4, AAAA per IPv6, MX per posta, CNAME (canonical name) che è un altro nome per lo stesso sito</a></li>
</ul>
</li>
<li><a href="#org2f520a9">La risposta ricopia i dati e inserisce l'indirizzo nell'ultimo campo.</a></li>
<li><a href="#org450da38">Un record DNS in cache può essere associato ad uno specifico TTL, dopo il quale il record scade e la prossima richiesta effettuata da qualunque client dovrà essere risoluta di nuovo</a>
<ul>
<li><a href="#org9c5a8cd"><span class="todo TODO">TODO</span> Capire funzionamento in caso di record scaduto</a></li>
</ul>
</li>
<li><a href="#org9637bb1">Il resolving DNS avviene con un client che chiede la risoluzione di uno specifico FQDN al resolver all'interno della stessa macchina.</a>
<ul>
<li><a href="#org55190f4">Il resolver usa UDP perchè non gli serve instaurare la connessione e parla con il Local DNS, che viene impostato in fase di configurazione.</a></li>
</ul>
</li>
<li><a href="#org54b497e">A livello globale ci sono dei root DNS servers che contengono soltanto i domini di primo livello, con gli IP corrispondenti dei NameServer.</a>
<ul>
<li><a href="#orgef596cf">Usiamo questi se non sappiamo come raggiungere il dominio di primo livello, che di solito però conosciamo già perchè rimane in cache</a></li>
<li><a href="#orgc970664">Sul libro sono indicati due approcci, uno iterativo e uno ricorsivo, ma gli esempi sono tutti iterativi.</a>
<ul>
<li><a href="#org87cd323">L'approccio ricorsivo funziona con il resolver che manda una query al local dns e quest'ultimo risponde con l'indirizzo già pronto.</a>
<ul>
<li><a href="#org7e6346f">Non è implementata nei server per questioni di scalabilità.</a></li>
<li><a href="#org6cafc50">Il problema è che sebbene sia molto comoda per il client, il resolver dovrebbe mantenere tantissime informazioni di stato in attesa dei passi successivi.</a></li>
</ul>
</li>
<li><a href="#org7d95c94">L'approccio iterativo si applica dal local dns in poi, mentre fra resolver e local dns rimane ricorsivo, ovvero il local dns mantiene lo stato della richiesta fino all'invio della risposta al resolver.</a>
<ul>
<li><a href="#orga98ba2c">Il client continua a ricevere una risposta valida già pronta.</a></li>
<li><a href="#org2193f4c">Il local DNS, però, gestisce in modo iterativo.</a>
<ul>
<li><a href="#orgb8200e7">Manda l'intero dominio al root, che conosce però solo l'IP di primo livello e risponde con un informazione parziale, ovvero con l'indirizzo del NS di primo livello.</a></li>
<li><a href="#org6a7d73d">Una volta conosciuto quello di primo livello, si chiede al corrispondente NameServer di risolvere la parte rimanente del dominio.</a>
<ul>
<li><a href="#org9328b07">Questo risponde con l'indirizzo del DNS Server del secondo livello.</a></li>
</ul>
</li>
<li><a href="#org83f3c26">Se il dominio era composto da tre livelli, il DNS server di secondo livello risponde con l'IP specifico</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0f75bf7">Anche l'approccio iterativo richidede un overhead per il primo step, che viene attenuato dall'utilizzo della cache.</a>
<ul>
<li><a href="#orgdf551e4">In questo modo, la prossima volta che verrà richiesto un dominio di terzo livello appartenente allo stesso secondo livello, la richiesta verrà effettuata direttamente al Name Server di secondo livello.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgddb2ba4">Ultima lezione</a></li>
</ul>
</div>
</div>
<div id="outline-container-org08bb564" class="outline-2">
<h2 id="org08bb564">References</h2>
<div class="outline-text-2" id="text-org08bb564">
<p>
<a href="https://computer.howstuffworks.com/ethernet.htm">How Ethernet works</a>
<a href="https://intronetworks.cs.luc.edu/1/html/index.html">Exercises from Chicago University</a>
</p>
</div>
</div>
<div id="outline-container-org29180fd" class="outline-2">
<h2 id="org29180fd">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org2228452" class="outline-2">
<h2 id="org2228452">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd6cc51b" class="outline-2">
<h2 id="orgd6cc51b">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org5df9786" class="outline-2">
<h2 id="org5df9786">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgaf438d0" class="outline-2">
<h2 id="orgaf438d0">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org950ccae" class="outline-2">
<h2 id="org950ccae">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org3605f48" class="outline-2">
<h2 id="org3605f48">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org763e335" class="outline-2">
<h2 id="org763e335">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orge526da8" class="outline-2">
<h2 id="orge526da8">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org84cbc5f" class="outline-2">
<h2 id="org84cbc5f">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org36124a3" class="outline-2">
<h2 id="org36124a3">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgb0469e7" class="outline-2">
<h2 id="orgb0469e7">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgbc3728a" class="outline-2">
<h2 id="orgbc3728a">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org1eb8280" class="outline-2">
<h2 id="org1eb8280">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd77b681" class="outline-2">
<h2 id="orgd77b681">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orge6c8b46" class="outline-2">
<h2 id="orge6c8b46">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org2af6a5a" class="outline-2">
<h2 id="org2af6a5a">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd2c93e7" class="outline-2">
<h2 id="orgd2c93e7">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org71205b8" class="outline-2">
<h2 id="org71205b8">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org98d5d71" class="outline-2">
<h2 id="org98d5d71">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd570d63" class="outline-2">
<h2 id="orgd570d63">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org90fd521" class="outline-2">
<h2 id="org90fd521">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org56b2f6c" class="outline-2">
<h2 id="org56b2f6c">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org660452f" class="outline-2">
<h2 id="org660452f">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org8527999" class="outline-2">
<h2 id="org8527999">Introduciamo il DHCP&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org41d4771" class="outline-2">
<h2 id="org41d4771">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org41ad2dc" class="outline-2">
<h2 id="org41ad2dc">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org728728f" class="outline-2">
<h2 id="org728728f">Ci rifacciamo alla stessa struttura riguardante il routing, con un router che contiene un forwarder con porte IO di ingresso ed uscita e che opera su una tabella di routing, facendo un lookup e stabilendo la corretta porta di output. Chi scrive sulla tabella è il router, che ha i propri pacchetti di controllo e opera come un processo totalmente asincrono ed indipendente.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org186bd41" class="outline-2">
<h2 id="org186bd41">Supponiamo di avere due macchina che ha uno strato applicativo, seguito da TCP, IP ecc&#x2026;, attaccata ad una rete IP.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org51c9001" class="outline-2">
<h2 id="org51c9001">Al livello 3 c'è un processo chiamato router, autonomo rispetto al forwarder. Questa separazione ci facilita la costruzione e l'implementazione dell'instradamento e la sua messa in cloud.</h2>
<div class="outline-text-2" id="text-org51c9001">
</div>
<div id="outline-container-orgb93c5a2" class="outline-3">
<h3 id="orgb93c5a2">Il forwarder è un punto delicato per l'efficienza, perchè fa numerose operazioni, facendo lookup di source e address dello header ip per instradare correttamente il pacchetto.</h3>
</div>
<div id="outline-container-orgb34c0d2" class="outline-3">
<h3 id="orgb34c0d2">Nell'area 0, ovvero backbone, di un sistema autonomo, i router hanno un carico notevole. Più aumentiamo l'efficienza dei router interni alla backbone area, migliore è il risultato dell'intera rete.</h3>
<div class="outline-text-3" id="text-orgb34c0d2">
</div>
<div id="outline-container-orge7d12a6" class="outline-4">
<h4 id="orge7d12a6">Viene usato il Multi-Protocol Label Switching, in cui ogni router contiene una <b>tabella di etichette</b>.</h4>
<div class="outline-text-4" id="text-orge7d12a6">
</div>
<div id="outline-container-org9c4de35" class="outline-5">
<h5 id="org9c4de35">Il primo router, un area border router, ovvero quello che fa da interfaccia fra il gateway e la backbone, è un router di etichetta, ovvero aggiunge o rimuove un intestazione MPLS a cui tutti i router della backbone fanno riferimento, ignorando lo header IP.</h5>
</div>
<div id="outline-container-org56f0ae8" class="outline-5">
<h5 id="org56f0ae8">In questo modo, il loro lavoro diventa molto più veloce, un po come lo switching del data link.</h5>
</div>
<div id="outline-container-org477e7c1" class="outline-5">
<h5 id="org477e7c1">Ogni router contiene una tabella <b>per ogni porta</b>, che spiega dove switchare il pacchetto <b>a seconda dell'etichetta</b>, insieme alla politica di accodamento e scheduling (prossime lezioni)</h5>
<div class="outline-text-5" id="text-org477e7c1">
</div>
<div id="outline-container-org309454b" class="outline-6">
<h6 id="org309454b">Quindi, posso creare dei gruppi di tipi di pacchetto affini, che seguano direzioni diverse a seconda del servizio richiesto (sul libro classi equivalenti di inoltro)</h6>
</div>
<div id="outline-container-orgf524204" class="outline-6">
<h6 id="orgf524204">Non solo minimizza il tempo necessario per la commutazione, ma permette anche di effettuare load-balancing.</h6>
</div>
</div>
<div id="outline-container-orgfbf0a04" class="outline-5">
<h5 id="orgfbf0a04">Lo header di mpls contiene un etichetta a 20 bit, la classe di servizio e il ttl</h5>
</div>
<div id="outline-container-orgc93b280" class="outline-5">
<h5 id="orgc93b280">Di fatto, come per l'sdn nell'instradamento, cè un entità esterna, il network manager, che ha le funzionalita di segnalazione e segnala ai LSR (label switched router) e LER(stesso ma sulla Edge) informazioni per gestire al meglio la rete</h5>
<div class="outline-text-5" id="text-orgc93b280">
</div>
<div id="outline-container-orgb3d05a8" class="outline-6">
<h6 id="orgb3d05a8">Ad esempio si potrebbe imporre di seguire un percorso più lungo ma meglio distrbuito.</h6>
</div>
</div>
<div id="outline-container-org2dcd48f" class="outline-5">
<h5 id="org2dcd48f">Nel campo della Class of Service è inserita una flag dal livello 4 o applicazione, che specifica come gestire quel campo.</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org63c9577" class="outline-2">
<h2 id="org63c9577">Il traffico realtime, come la telefonia su internet o la conferenza su internet, è associato ad una jitter sensitivity ed aldelay associato ad un singolo pacchetto.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org6c58e92" class="outline-2">
<h2 id="org6c58e92">IPV6 è uguale ma con molte meno opzioni</h2>
<div class="outline-text-2" id="text-org6c58e92">
</div>
<div id="outline-container-orgacbf0d2" class="outline-3">
<h3 id="orgacbf0d2">Inoltre il time to live si chiama hop count</h3>
</div>
<div id="outline-container-org190842a" class="outline-3">
<h3 id="org190842a">Type of service si chiama traffic class</h3>
</div>
<div id="outline-container-orga8fc6a9" class="outline-3">
<h3 id="orga8fc6a9">c'è il campo next header che è nuovo ed è un puntatore ad un estensione dello header</h3>
<div class="outline-text-3" id="text-orga8fc6a9">
</div>
<div id="outline-container-orgb0d3fd5" class="outline-4">
<h4 id="orgb0d3fd5">La motivazione per cui è usato è che il nuovo header è molto spoglio e non esistono le option</h4>
</div>
<div id="outline-container-orga48b3af" class="outline-4">
<h4 id="orga48b3af">Quindi è possibile aggiungere nuovi header</h4>
<div class="outline-text-4" id="text-orga48b3af">
</div>
<div id="outline-container-orgd63e1fc" class="outline-5">
<h5 id="orgd63e1fc">Fra i possibili header esistono:</h5>
<div class="outline-text-5" id="text-orgd63e1fc">
</div>
<div id="outline-container-orgf75e90b" class="outline-6">
<h6 id="orgf75e90b">hop by hop, usati per i jumbo packets, pacchetti più grandi di 65k</h6>
<div class="outline-text-6" id="text-orgf75e90b">
</div>
<div id="outline-container-orgec1971f" class="outline-7">
<h7 id="orgec1971f">In distanze lontane, quello che interviene come parametro è il tempo di propagazione</h7>
</div>
<div id="outline-container-orgb096d71" class="outline-7">
<h7 id="orgb096d71">Più roba riesco a mandare concatenata, più aumento l'utilizzo</h7>
</div>
</div>
<div id="outline-container-orge0c0f09" class="outline-6">
<h6 id="orge0c0f09">routing per il source routing</h6>
<div class="outline-text-6" id="text-orge0c0f09">
</div>
<div id="outline-container-org1a98cf7" class="outline-7">
<h7 id="org1a98cf7">il campo bit map avrà tanti bit settati quanti sono gli indirizzi da visitare</h7>
<div class="outline-text-7" id="text-org1a98cf7">
</div>
<div id="outline-container-org8f3610c" class="outline-8">
<h8 id="org8f3610c">Il valore di questi bit è 0 o 1 a seconda di come si comportano</h8>
<div class="outline-text-8" id="text-org8f3610c">
</div>
<div id="outline-container-org74842fd" class="outline-9">
<h9 id="org74842fd">Con la strict routing impongo che venga visitato un certo router</h9>
</div>
<div id="outline-container-orgeb1377c" class="outline-9">
<h9 id="orgeb1377c">Loose può usare quanti hop vuole in mezzo a due ip selezionati</h9>
</div>
</div>
</div>
<div id="outline-container-org9c5ee35" class="outline-7">
<h7 id="org9c5ee35">In realtà lo spazio ammesso non è 24 come la bitmap sembrerebbe permettere, ma 23 (per qualche motivo da controllare)</h7>
</div>
</div>
<div id="outline-container-orgdef0770" class="outline-6">
<h6 id="orgdef0770">fragment</h6>
</div>
<div id="outline-container-org2e70535" class="outline-6">
<h6 id="org2e70535">authentication</h6>
</div>
</div>
</div>
<div id="outline-container-orgec0bf72" class="outline-4">
<h4 id="orgec0bf72">Ogni next header viene ins</h4>
</div>
</div>
<div id="outline-container-org133784b" class="outline-3">
<h3 id="org133784b">L'indirizzo di ipv6</h3>
<div class="outline-text-3" id="text-org133784b">
</div>
<div id="outline-container-org23a084f" class="outline-4">
<h4 id="org23a084f">può inglobare ipv4 con tutti 0 o tutti 0, poi 16 1 e in ogni caso alla fine 32 bit di ipv4</h4>
</div>
<div id="outline-container-org0f4b50e" class="outline-4">
<h4 id="org0f4b50e">è diviso in varie sezioni in modo da snellire le tabelle di routing per ad esempio i router ad alto livello che vogliono smistare velocemente</h4>
</div>
</div>
<div id="outline-container-org11ffd1b" class="outline-3">
<h3 id="org11ffd1b">IPV6 coesiste con IPV4, per cui può capitare che ci siano macchine IPV4 e IPV6, che vogliono parlare con lo stesso server.</h3>
<div class="outline-text-3" id="text-org11ffd1b">
</div>
<div id="outline-container-org9d275ff" class="outline-4">
<h4 id="org9d275ff">Quel server deve avere entrambe le opzioni</h4>
</div>
<div id="outline-container-org217aba2" class="outline-4">
<h4 id="org217aba2">Può capitare anche che due macchine ipv6 passino attraverso un router ipv4</h4>
<div class="outline-text-4" id="text-org217aba2">
</div>
<div id="outline-container-org16cdf77" class="outline-5">
<h5 id="org16cdf77">In questo caso si fa tunneling</h5>
</div>
</div>
<div id="outline-container-org7198a79" class="outline-4">
<h4 id="org7198a79">Quando una macchina IPV6 parla con IPV4, serve che ci sia in mezzo un NAT, diverso da quello che abbiamo studiato, che mappa degli indirizzi 6 su IPv4</h4>
<div class="outline-text-4" id="text-org7198a79">
</div>
<div id="outline-container-org4d340af" class="outline-5">
<h5 id="org4d340af">Il gateway usa degli indirizzi pubblici dinamici per la rete interna con cui le macchine all'interno comunicano e il gateway si occupa della comunicazione con IPv6 in modo trasparente alla stazione</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcee69f3" class="outline-2">
<h2 id="orgcee69f3">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org8d7197d" class="outline-2">
<h2 id="org8d7197d">Quindi siamo arrivati al SYN che uno manda per aprire la connessione, con un numero di sequenza generato in numero casuale. Il canale è bidirezionale e quindi avviene tutto nello stesso modo in entrambi gli host.</h2>
<div class="outline-text-2" id="text-org8d7197d">
</div>
<div id="outline-container-org4a35ac4" class="outline-3">
<h3 id="org4a35ac4">Il SYN parte a 1, in risposta il SYN è a uno e anche l'ACK, che indica che il campo Ack è significativo e tale campo è numDiSequenza +1, per indicare che quello è il prossimo bit che si è pronti a ricevere.</h3>
<div class="outline-text-3" id="text-org4a35ac4">
</div>
<div id="outline-container-orgb1b713d" class="outline-4">
<h4 id="orgb1b713d">Ovviamente manda anche il proprio numero di sequenza.</h4>
</div>
</div>
<div id="outline-container-org79f9b79" class="outline-3">
<h3 id="org79f9b79">Se tutto va a buon fine, la terza risposta dal sender è uguale alla seconda dal receiver e da lì in poi la connessione è aperta.</h3>
</div>
<div id="outline-container-orgcc32eac" class="outline-3">
<h3 id="orgcc32eac">C'è un timer che garantisce che se l'ACK viene perso, o impiega troppo tempo ad arrivare, venga mandato un messaggio con RESET a 1 che annulla l'handshake, che va rieffettuato</h3>
<div class="outline-text-3" id="text-orgcc32eac">
<pre class="example" id="org4ccfc6c">
Let me explain why starting sequence numbers in the Transport layer are random:

    Security: Random initial sequence numbers help prevent TCP sequence prediction attacks. If sequence numbers were predictable, attackers could potentially hijack TCP connections by guessing the next sequence number.

    Connection Uniqueness: Random sequence numbers reduce the likelihood of old segments from previous connections being mistakenly accepted as valid in new connections between the same endpoints.

    Prevents Segment Mix-up: If multiple connections are established between the same hosts, random sequence numbers help ensure segments from different connections don't get mixed up.

    Protection against Spoofing: Random initial sequence numbers make it harder for attackers to inject fake segments into an existing connection since they would need to guess the correct sequence number.

    Avoids Overlap: In case of delayed segments from previous connections, random sequence numbers help prevent confusion between old and new data streams.

This randomization is a crucial security measure in modern TCP implementations and helps maintain the integrity and reliability of network communications.
</pre>
</div>
</div>
<div id="outline-container-org369f4fe" class="outline-3">
<h3 id="org369f4fe">In ogni header è indicato il Max Segment Size, che indica la dimensione massima di segmento che l'host può gestire senza andare in overflow.</h3>
<div class="outline-text-3" id="text-org369f4fe">
</div>
<div id="outline-container-org127bb79" class="outline-4">
<h4 id="org127bb79">La dimensione Standard, quando il campo è vuoto, il segmento è di 536 byte.</h4>
</div>
</div>
<div id="outline-container-org97bcd2a" class="outline-3">
<h3 id="org97bcd2a">L'obiettivo di TCP è trasferire i dati nel miglior modo, garantendo affidabilità, gest.errori, ordine ecc., e anche farlo in modo efficiente, evitando un overhead eccessivo</h3>
</div>
<div id="outline-container-org7150122" class="outline-3">
<h3 id="org7150122">Il motivo per cui viene scelta 536 byte è che siamo sicuri che il livello IP non frammenterà tale segmento in più pacchetti.</h3>
<div class="outline-text-3" id="text-org7150122">
</div>
<div id="outline-container-org708ecef" class="outline-4">
<h4 id="org708ecef">Per ogni frammentazione effettuata dall'IP, serve copiare sia header TCP che IP, introducendo overhead.</h4>
</div>
<div id="outline-container-orgafd2787" class="outline-4">
<h4 id="orgafd2787">Inoltre, essendo la rete best-effort, quanti più sotto-segmenti vengono mandati quanto più è probabile che avvengano dei problemi che dovranno essere poi gestiti</h4>
</div>
</div>
<div id="outline-container-org88522cb" class="outline-3">
<h3 id="org88522cb">Immaginiamo di avere una connessione A-B in TCP, necessariamente bidirezionale.</h3>
<div class="outline-text-3" id="text-org88522cb">
</div>
<div id="outline-container-orgec68a1b" class="outline-4">
<h4 id="orgec68a1b">Dato che noi analizziamo solo i casi "unidirezionali", noi valutiamo solo SendingBuffer e TcpSendingBuffer nel sender, e i corrispondenti ma per il receiver nel receiver.</h4>
</div>
<div id="outline-container-org90fbe8c" class="outline-4">
<h4 id="org90fbe8c">Assumiamo che la segment size sia 500.</h4>
</div>
<div id="outline-container-org956ec3b" class="outline-4">
<h4 id="org956ec3b">L'applicazione lato sender scrive 2000 byte nell'SB della socket esposto.</h4>
</div>
<div id="outline-container-org4d97452" class="outline-4">
<h4 id="org4d97452">Ovviamente, va eseguita una frammentazione a livello trasporto.</h4>
<div class="outline-text-4" id="text-org4d97452">
</div>
<div id="outline-container-orgfe25b21" class="outline-5">
<h5 id="orgfe25b21">Assumiamo per ora che non avvengano problemi nella trasmissione.</h5>
</div>
</div>
<div id="outline-container-orgeba6369" class="outline-4">
<h4 id="orgeba6369">Nel sending buffer della TCP, nascosto al livello applicazione, vengono copiati e segmentati opportunamente i byte del buffer superiore.</h4>
</div>
<div id="outline-container-org7be641f" class="outline-4">
<h4 id="org7be641f">Nello header è presente l'informazione SEQ=X. Il payload sarà dal byte X a quello X + 499</h4>
<div class="outline-text-4" id="text-org7be641f">
</div>
<div id="outline-container-org7033c48" class="outline-5">
<h5 id="org7033c48">X è in realtà X+1 se la connessione è appena stata instaurata, ma per semplicità si considera X il valore corrente.</h5>
</div>
</div>
<div id="outline-container-org10abce3" class="outline-4">
<h4 id="org10abce3">Nel frattempo, il receiver si aspettava il Sequence Number = X e così si accerta che l'ordine sia corretto.</h4>
</div>
<div id="outline-container-org0d8e819" class="outline-4">
<h4 id="org0d8e819">I dati arrivano nel buffer inferiore, ma dato che l'ordine è corretto, vengono subito copiati nel buffer superiore.</h4>
</div>
<div id="outline-container-orgf479fad" class="outline-4">
<h4 id="orgf479fad">Lo header risposta del receiving buffer contiene il campo ACK a 1 e quello Ack a X + 500, che è il primo byte successivo a quello ricevuto.</h4>
<div class="outline-text-4" id="text-orgf479fad">
</div>
<div id="outline-container-org48407ef" class="outline-5">
<h5 id="org48407ef">Implicitamente vuol dire che il segmento precedente è correttamente ricevuto.</h5>
</div>
</div>
<div id="outline-container-orgc124063" class="outline-4">
<h4 id="orgc124063">Il sender elimina dal buffer del TCP il segmento corrispondente.</h4>
</div>
<div id="outline-container-org30f28c9" class="outline-4">
<h4 id="org30f28c9">Allora, il prossimo segmento mandato è quello che parte da X+500 e questo valore è nel SEQ dello header.</h4>
</div>
<div id="outline-container-org7fbf26a" class="outline-4">
<h4 id="org7fbf26a">Anche questo pacchetto è in ordine e quindi va subito spostato nel buffer superiore.</h4>
<div class="outline-text-4" id="text-org7fbf26a">
</div>
<div id="outline-container-org6eb57e0" class="outline-5">
<h5 id="org6eb57e0">Il TCP tiene tutti i segmenti non in ordine nel buffer inferiore.</h5>
</div>
<div id="outline-container-org6d365fb" class="outline-5">
<h5 id="org6d365fb">Ogni segmento correttamente ricevuto, ma successivo ad un segmento non ricevuto, rimane nel buffer inferiore.</h5>
</div>
</div>
<div id="outline-container-orgc459ccd" class="outline-4">
<h4 id="orgc459ccd">Analogamente al messaggio precedente, il receiver risponde con un Ack = X+1000.</h4>
<div class="outline-text-4" id="text-orgc459ccd">
</div>
<div id="outline-container-org5ef5d5c" class="outline-5">
<h5 id="org5ef5d5c">Anche adesso, il sender si libera del segmento.</h5>
</div>
</div>
<div id="outline-container-org1657fe8" class="outline-4">
<h4 id="org1657fe8">Procedo così fino allo svuotamento del buffer di invio.</h4>
</div>
</div>
<div id="outline-container-orge9c6f80" class="outline-3">
<h3 id="orge9c6f80">Nella configurazione precedente, c'è un problema nel caso in cui ho bisogno di (real-time?) ad esempio ssh su una console remota.</h3>
<div class="outline-text-3" id="text-orge9c6f80">
</div>
<div id="outline-container-orgf31e32d" class="outline-4">
<h4 id="orgf31e32d">Voglio che i dati vengano processati byte per byte</h4>
</div>
<div id="outline-container-orgf3a82b7" class="outline-4">
<h4 id="orgf3a82b7">Allora uso la flag PUSH, in modo che TCP spedisca il singolo byte, senza arrivare ad una dimensione del segmento di 500 byte come prima</h4>
</div>
<div id="outline-container-orgc1a8f6c" class="outline-4">
<h4 id="orgc1a8f6c">Quando PUSH viene usata, il receiver manda un regolare ACK, con Ack X+1</h4>
</div>
<div id="outline-container-orge4e09de" class="outline-4">
<h4 id="orge4e09de">In questo caso, però, viene fatta una eco dello stesso byte, questa volta</h4>
</div>
<div id="outline-container-org4fc03d8" class="outline-4">
<h4 id="org4fc03d8">Il motivo per cui viene fatta la eco è che il sender prende input a tastiera ma non mostra direttamente a schermo, perchè non è sicuro che dall'altra parte sia correttamente ricevuto. Solo quando si è sicuri che dall'altra parte sia stato ricevuto, viene stampato a tastiera</h4>
<div class="outline-text-4" id="text-org4fc03d8">
<pre class="example" id="orgad33e6e">
Let me explain why TCP echoes bytes with the PUSH flag:

    Data Acknowledgment vs Echo:

    The ACK simply acknowledges receipt of data
    The echo (sending the same byte back) serves a different purpose: it confirms the connection is still alive and functioning in both directions

    Key Benefits of Echoing:

    Tests bi-directional data flow
    Helps detect half-open connections
    Provides an additional validation mechanism beyond simple acknowledgment
    Useful for interactive applications where immediate response is needed

    Relationship to PUSH Flag:

    The PUSH flag indicates that data should be delivered to the application immediately
    Echoing PUSH-flagged bytes ensures the urgent nature of the data is maintained in both directions
    This is particularly important for interactive protocols like Telnet where character-by-character feedback is needed

The echo mechanism complements ACKs rather than duplicating them - ACKs confirm receipt, while echoes validate the full duplex nature of the connection and maintain interactive responsiveness.
</pre>
</div>
</div>
</div>
<div id="outline-container-org9e7ab83" class="outline-3">
<h3 id="org9e7ab83">Per garantire&#x2026;(?) viene introdotto il delay acknowledgment.</h3>
<div class="outline-text-3" id="text-org9e7ab83">
</div>
<div id="outline-container-org7afb419" class="outline-4">
<h4 id="org7afb419">La questione è che TCP ignora l'obiettivo delle applicazioni, ma loro lo sanno e potrebbero voler inserire più informazioni nello header.</h4>
</div>
<div id="outline-container-orga25a70e" class="outline-4">
<h4 id="orga25a70e">Immaginiamo una situazione come prima: si riceve un byte pushato.</h4>
</div>
<div id="outline-container-orgd8eb813" class="outline-4">
<h4 id="orgd8eb813">Il receiver, però, non risponde subito con un Ack, ma aspetta un tempo (standard 200ms).</h4>
</div>
<div id="outline-container-org081b0fc" class="outline-4">
<h4 id="org081b0fc">Se in quel tempo arriva qualcosa nel buffer di invio del ricevitore, quei dati vengono incorporati nel messaggio di Ack.</h4>
<div class="outline-text-4" id="text-org081b0fc">
</div>
<div id="outline-container-org8f27e17" class="outline-5">
<h5 id="org8f27e17">In questo caso, sia sequence che ack number sono considerati. Seq è quello che ti do, ack quello che prendo.</h5>
<div class="outline-text-5" id="text-org8f27e17">
</div>
<div id="outline-container-org95fadc3" class="outline-6">
<h6 id="org95fadc3">Prima invece, il campo sequence non era mai impostato</h6>
</div>
</div>
</div>
<div id="outline-container-orgcf08a4e" class="outline-4">
<h4 id="orgcf08a4e">In questo caso, quando la eco viene aggiunta nel buffer di invio della ricezione, viene inserita nello stesso frame di Ack. Così ri risparmia un messaggio TCP.</h4>
<div class="outline-text-4" id="text-orgcf08a4e">
<pre class="example" id="org8d72f38">
Let me explain a common TCP optimization technique from computer networking. This technique is called "Delayed Acknowledgment" or "Delayed ACK."

The Delayed ACK technique involves:

    Deliberately waiting for a short period (typically around 200ms) before sending an ACK
    During this wait period, if the receiving host has data to send back to the sender, it can combine (piggyback) the ACK with this outgoing data
    The wait period also allows the receiver to potentially combine multiple ACKs into a single response if more segments arrive during the delay

This technique helps improve network efficiency by:

    Reducing protocol overhead
    Minimizing the number of small packets on the network
    Taking advantage of bi-directional data flow
    Optimizing bandwidth usage by combining ACKs with data when possible

However, Delayed ACK is not used in all cases - for example, every second full-sized segment must be acknowledged immediately to maintain TCP's flow control mechanisms.
</pre>
</div>
<div id="outline-container-orgd67c8a4" class="outline-5">
<h5 id="orgd67c8a4">Il prossimo messaggio del sender sarà sia un ACK della echo che un send del byte successivo.</h5>
</div>
</div>
<div id="outline-container-org51c0a00" class="outline-4">
<h4 id="org51c0a00">Questa soluzione è efficiente dal punto di vista di rete, ma inefficiente dal punto di vista della user-experience.</h4>
<div class="outline-text-4" id="text-org51c0a00">
</div>
<div id="outline-container-org1899905" class="outline-5">
<h5 id="org1899905">Per trovare un compromesso fra rete e user-experience, si utilizza la tecnica del <b>NAGLE</b>.</h5>
<div class="outline-text-5" id="text-org1899905">
</div>
<div id="outline-container-org3b817da" class="outline-6">
<h6 id="org3b817da">Ho un sender con una serie di segmenti composti da un singolo byte da pushare.</h6>
</div>
<div id="outline-container-org8472f26" class="outline-6">
<h6 id="org8472f26">Come prima, mando un segmento con il byte, il receiver lo riceve e aspetta 200ms.</h6>
<div class="outline-text-6" id="text-org8472f26">
</div>
<div id="outline-container-orgcac7180" class="outline-7">
<h7 id="orgcac7180">L'applicazione riceve il byte e fa la ACK + echo, con SEQ = Y, PUSH attivato, ACK attivato e Ack = X + 1</h7>
</div>
</div>
<div id="outline-container-org625a319" class="outline-6">
<h6 id="org625a319">I successivi byte vengono impacchettati in un singolo segmento e mandati tutti insieme. Il receiver risponde con l'ack.</h6>
<div class="outline-text-6" id="text-org625a319">
</div>
<div id="outline-container-org14d9f72" class="outline-7">
<h7 id="org14d9f72"><span class="todo TODO">TODO</span> Capire se viene effettuata la echo dei byte in blocco e se viene fatta byte per byte o cumulativa.</h7>
<div class="outline-text-7" id="text-org14d9f72">
<pre class="example" id="org4c2ecb8">
No, when using Nagle's algorithm, the block of bytes in the second segment is not echoed, and the ACK does not contain an echo of the whole block. Here's why:

    First byte behavior:

    The first byte is sent immediately (Nagle allows this)
    This byte gets acknowledged and echoed (typical for interactive data)

    Block of bytes behavior:

    The subsequent block is sent as a single segment due to Nagle's algorithm
    The receiver only sends an ACK for this data
    The block is NOT echoed back

The reason for this difference is:

    Single byte echoing is typically used for interactive traffic (like telnet) where immediate feedback is needed
    Larger blocks of data don't need character-by-character echo feedback
    Echoing large blocks would be inefficient and isn't necessary for bulk data transfer
    The ACK alone is sufficient to confirm receipt of the block

This behavior helps optimize network performance by:

    Reducing unnecessary network traffic
    Preventing excessive echoing of bulk data
    Maintaining interactivity where needed (single bytes)
    Providing reliable delivery confirmation through ACKs
</pre>

<pre class="example" id="org490f9c6">
The echo of the first byte in Nagle's algorithm serves these specific purposes:

    Connection Validation:

    The echo of the first byte confirms that the connection is fully functional in both directions
    It quickly verifies that the remote end is responsive and processing data

    Interactive Feedback:

    For interactive applications (like telnet or ssh), the first byte often represents a keystroke
    Users need immediate feedback for this first input to confirm their interaction
    The echo provides visual confirmation that the connection is working

    Fast Start Verification:

    Rather than waiting for the full data transfer to verify connection quality
    The single byte echo serves as a quick initial test of the connection

    Protocol Efficiency:

    Only echoing the first byte (not the subsequent block) is a compromise between:
        Providing necessary interactive feedback
        Avoiding unnecessary network overhead for bulk data
    After the initial verification, regular ACKs are sufficient for bulk data transfer

This selective echoing behavior combines the benefits of interactive responsiveness for the initial byte with efficient bulk transfer for subsequent data.
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8944071" class="outline-4">
<h4 id="org8944071"></h4>
</div>
</div>
<div id="outline-container-org2f34f11" class="outline-3">
<h3 id="org2f34f11">In caso di errori, è lo stesso TCP che se ne accorge e cerca di sanarlo.</h3>
<div class="outline-text-3" id="text-org2f34f11">
</div>
<div id="outline-container-org0a4374b" class="outline-4">
<h4 id="org0a4374b">TCP è orientato allo stream.</h4>
<div class="outline-text-4" id="text-org0a4374b">
</div>
<div id="outline-container-org7aff566" class="outline-5">
<h5 id="org7aff566">Abbiamo già visto che a livello 2 ogni pacchetto è identificato da un numero che viene utilizzato per riconoscere i frame su cui avviene l'errore.</h5>
</div>
<div id="outline-container-orgd7e5892" class="outline-5">
<h5 id="orgd7e5892">In TCP l'idea del sequence number è che, conoscendo la dimensione del file \(N\), il segmento va da \(X\) a \(X+N\).</h5>
</div>
<div id="outline-container-org1ec49de" class="outline-5">
<h5 id="org1ec49de">Ci interessa capire fino a che punto dello stream è stato ricevuto tutto correttamente.</h5>
<div class="outline-text-5" id="text-org1ec49de">
</div>
<div id="outline-container-org981b590" class="outline-6">
<h6 id="org981b590">Ovvero, l'indice \(K<N\) fino a cui è assicurata la comunicazione avvenuta correttamente.</h6>
</div>
</div>
<div id="outline-container-org6aeaa0d" class="outline-5">
<h5 id="org6aeaa0d">Quindi il sequence number sommato al payload, mi da il nuovo numero di sequenza.</h5>
</div>
<div id="outline-container-org4aca1dd" class="outline-5">
<h5 id="org4aca1dd">Immaginiamo di avere una situazione in cui l'app sender debba spedire 2400 byte con una dimensione del segmento di 500.</h5>
</div>
<div id="outline-container-orged74cfe" class="outline-5">
<h5 id="orged74cfe">Il primo segmento viene spedito con SEQ=X.</h5>
</div>
<div id="outline-container-orge9c5362" class="outline-5">
<h5 id="orge9c5362">Il secondo viene spedito senza aspettare l'ACK, con SEQ=X+500</h5>
</div>
<div id="outline-container-orgf0576e2" class="outline-5">
<h5 id="orgf0576e2">Si immagini adesso che il secondo segmento venga perso.</h5>
</div>
<div id="outline-container-org4d199b0" class="outline-5">
<h5 id="org4d199b0">Nel frattempo, il receiver risponde con un ACK per il primo segmento, ovvero con Ack X + 500 e dato che il segmento è nell'ordine corretto, questo viene spedito al buffer superiore.</h5>
</div>
<div id="outline-container-orgde9e891" class="outline-5">
<h5 id="orgde9e891">Quando il secondo segmento è spedito ma non è stato ricevuto l'ack corrispondente, il segmento è ancora nel sending buffer del tcp del sender.</h5>
</div>
<div id="outline-container-org604fc18" class="outline-5">
<h5 id="org604fc18">Comunque non aspetto l'ACK del secondo, perchè essendoci la rete per mezzo, non posso sapere se arriverà a breve o non arriverà.</h5>
</div>
<div id="outline-container-org2926dd8" class="outline-5">
<h5 id="org2926dd8">Quindi mando il terzo, con SEQ=X+1000.</h5>
</div>
<div id="outline-container-org8e94444" class="outline-5">
<h5 id="org8e94444">Quando il receiver riceve questo segmento, lo mette nel suo buffer, ma risponde con lo stesso ACK di prima.</h5>
<div class="outline-text-5" id="text-org8e94444">
</div>
<div id="outline-container-orgac4ceb9" class="outline-6">
<h6 id="orgac4ceb9">Ovvero, si intende che sebbene qualcosa sia ricevuto, non "riempie lo spazio" di ciò che non era stato ricevuto.</h6>
</div>
</div>
<div id="outline-container-orgdc46ecb" class="outline-5">
<h5 id="orgdc46ecb">La questione è che ogni segmento attiva un timer. Finchè il timer non scade, TCP prosegue con <b>tutti</b> i segmenti successivi in buffer d'invio.</h5>
</div>
<div id="outline-container-orga85e9e4" class="outline-5">
<h5 id="orga85e9e4">Quando il timer scade, soltanto quello specifico segmento viene inviato.</h5>
</div>
<div id="outline-container-org9eb6a05" class="outline-5">
<h5 id="org9eb6a05">A questo punto, il ricevitore si renderà conto che quel segmento, il secondo in questo caso, va posizionato prima dei successivi, che già possiede nel buffer. Allora tutti quelli successivi saranno sbloccati ed il prossimo ACK li includerà. Si parla quindi di ACK cumulativo.</h5>
</div>
<div id="outline-container-org1f07b7c" class="outline-5">
<h5 id="org1f07b7c">Questa roba si chiama <b>fast retransmit</b>, ovvero la ritrasmissione di un singolo segmento.</h5>
</div>
<div id="outline-container-org2e5d87f" class="outline-5">
<h5 id="org2e5d87f">Il timer è pensato per considerare il caso di perdita, anche abbastanza inusuale, sovradimensionato.</h5>
</div>
<div id="outline-container-orgd8a60ef" class="outline-5">
<h5 id="orgd8a60ef">Si usa però anche una strategia del triplo ACK: al terzo ACK uguale ricevuto, viene inviato il segmento corrispondente.</h5>
</div>
<div id="outline-container-org39715f4" class="outline-5">
<h5 id="org39715f4">Usando queste due strategie, si limita il danno sull'efficienza del timeout e si rende più veloce l'invio dei segmenti precedenti.</h5>
<div class="outline-text-5" id="text-org39715f4">
</div>
<div id="outline-container-org9414a7a" class="outline-6">
<h6 id="org9414a7a">Ad esempio, si fa in modo che tutti i segmenti in coda nel buffer a cui serve quello perso per sbloccarsi, debbano aspettare al massimo T ma spesso anche di meno, così da ridurre lo spazio di memoria occupato.</h6>
</div>
</div>
<div id="outline-container-org36c6f51" class="outline-5">
<h5 id="org36c6f51">Il timer è anche molto utile per gli ultimi (?)2 segmenti, dopo i quali non esistono 3 ack che facciano partire la ritrasmissione.</h5>
<div class="outline-text-5" id="text-org36c6f51">
</div>
<div id="outline-container-org0ddf778" class="outline-6">
<h6 id="org0ddf778"><span class="todo TODO">TODO</span> Per quanti segmenti vale questa proprietà</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3f50fe8" class="outline-2">
<h2 id="org3f50fe8">Negle ha un utilità quando vogliamo garantire un utilizzo efficiente della rete.</h2>
<div class="outline-text-2" id="text-org3f50fe8">
</div>
<div id="outline-container-orgc085dba" class="outline-3">
<h3 id="orgc085dba">Lo si usa al posto di mandare ogni carattere da solo, con un overhead altissimo dovuto allo header IP e TCP.</h3>
<div class="outline-text-3" id="text-orgc085dba">
</div>
<div id="outline-container-org9c0f8c9" class="outline-4">
<h4 id="org9c0f8c9">Per mandare un byte, mi servono 4 messaggi.</h4>
</div>
<div id="outline-container-orgfe24cd3" class="outline-4">
<h4 id="orgfe24cd3">Si usa il delay per diminuire i messaggi che vengono mandati, ma si paga troppo tempo per l'attesa del delay ogni volta, con piggy bagging in cui nei dati da comunicare si inserisce anche l'ack cumulativo</h4>
</div>
<div id="outline-container-org2b1eaca" class="outline-4">
<h4 id="org2b1eaca">Un compromesso e il nagle</h4>
</div>
</div>
<div id="outline-container-orga18f056" class="outline-3">
<h3 id="orga18f056">Il Nagle viene in supporto quando abbiamo un quantitativo di dati dall'applicazione, ovvero nel SB (superiore) che è minore alla maximum segment size.</h3>
<div class="outline-text-3" id="text-orga18f056">
</div>
<div id="outline-container-orgb3be167" class="outline-4">
<h4 id="orgb3be167">Nagle innanzitutto guarda il TCP Sending Buffer (quello inferiore). Se è vuoto vuol dire che non sto aspettando nessun ACK.</h4>
<div class="outline-text-4" id="text-orgb3be167">
</div>
<div id="outline-container-org91bb292" class="outline-5">
<h5 id="org91bb292">In questo caso, invio direttamente il contenuto dell'SB, nonostante sia inferiore.</h5>
</div>
</div>
<div id="outline-container-org9d2b855" class="outline-4">
<h4 id="org9d2b855">Se invece ci sono altri segmenti nel buffer inferiore, lo accoda.</h4>
</div>
<div id="outline-container-orgb8c6e61" class="outline-4">
<h4 id="orgb8c6e61">Uno dei lati negativi di Nagle è che sebbene utilizzi bene la rete, ovvero limitando l'overhead, (QUAL è L'ASPETTO NEGATIVO)?</h4>
</div>
</div>
<div id="outline-container-orgd69112e" class="outline-3">
<h3 id="orgd69112e">Un altro aspetto è che tcp è orientato allo stream e ragiona in base ai bit.</h3>
<div class="outline-text-3" id="text-orgd69112e">
</div>
<div id="outline-container-org8b90cf5" class="outline-4">
<h4 id="org8b90cf5">Una sequenza di dati presente nel sending buffer non dev'essere multiplo della max segment size. Il TCP suddivide in blocchetti della dimensione corretta.</h4>
<div class="outline-text-4" id="text-org8b90cf5">
</div>
<div id="outline-container-org7bcad21" class="outline-5">
<h5 id="org7bcad21">Se un ultimo blocchetto non raggiunge la max segment size, sta all'applicazione decidere se mandarlo subito o se aspettare nuovi dati, la cui prima parte verrà aggiunta all'ultimo segmento e mandata tutto insieme.</h5>
</div>
</div>
<div id="outline-container-orga713985" class="outline-4">
<h4 id="orga713985">Quindi si parla di segmento numero n come divisione logica, ma tutto è relativo al byte di inizio sequenza.</h4>
</div>
<div id="outline-container-org5551980" class="outline-4">
<h4 id="org5551980">Il principio è che si occupa il meno possibile. L'eventuale padding è fatto ai livelli inferiori.</h4>
</div>
</div>
<div id="outline-container-org42c0bb3" class="outline-3">
<h3 id="org42c0bb3">Quando TCP invia un pacchetto ad IP, quest'ultimo, conoscendo perfettamente la max transfer unit del suo livello 2, frammenta ulteriormente se necessario.</h3>
<div class="outline-text-3" id="text-org42c0bb3">
</div>
<div id="outline-container-org3cb370e" class="outline-4">
<h4 id="org3cb370e">IP stesso riassemblerà poi la serie di pacchetti e la fornirà a tcp</h4>
</div>
<div id="outline-container-org18520ee" class="outline-4">
<h4 id="org18520ee">Se non ci riesce, a TCP non arriverà assolutamente nulla.</h4>
<div class="outline-text-4" id="text-org18520ee">
</div>
<div id="outline-container-orgb80414d" class="outline-5">
<h5 id="orgb80414d">Inoltre, solo il primo pacchetto avrà lo header tcp.</h5>
</div>
</div>
</div>
<div id="outline-container-org391b8a0" class="outline-3">
<h3 id="org391b8a0">Come abbiamo già visto, il round trip time è il tempo necessario perchè un segmento venga inviato ed ackAto.</h3>
<div class="outline-text-3" id="text-org391b8a0">
</div>
<div id="outline-container-orgc18b325" class="outline-4">
<h4 id="orgc18b325">Possiamo però anche inviare più segmenti nello stesso momento.</h4>
</div>
<div id="outline-container-org863348b" class="outline-4">
<h4 id="org863348b">Ogni segmento fa partire un timer, che dev'essere dimensionato correttamente e quindi non può essere statico.</h4>
</div>
<div id="outline-container-org74b4664" class="outline-4">
<h4 id="org74b4664">Esiste uno standard che ci spiega come calcolarlo</h4>
<div class="outline-text-4" id="text-org74b4664">
</div>
<div id="outline-container-org6cd48c7" class="outline-5">
<h5 id="org6cd48c7">Diciamo che il round trip time in media impieghi 30 ms</h5>
</div>
<div id="outline-container-org5b2f1c1" class="outline-5">
<h5 id="org5b2f1c1">La stima viene fatta considerandolo come un outlier della distribuzione.</h5>
<div class="outline-text-5" id="text-org5b2f1c1">
</div>
<div id="outline-container-orgaaadd7f" class="outline-6">
<h6 id="orgaaadd7f">Tipicamente si dice che un valore di +3sigma, quindi media più 4 deviazioni standard ci da una stima di un caso molto raro di outlier.</h6>
</div>
<div id="outline-container-org5fd2948" class="outline-6">
<h6 id="org5fd2948">Quindi dobbiamo sapere la media e la deviazione standard in base ai dati del round trip time.</h6>
<div class="outline-text-6" id="text-org5fd2948">
</div>
<div id="outline-container-org1d457dd" class="outline-7">
<h7 id="org1d457dd">INSERIRE FORMULA</h7>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org13990b6" class="outline-3">
<h3 id="org13990b6">Il controllo di flusso viene messo in atto quando il produttore produce molto più velocemente del ricevente.</h3>
<div class="outline-text-3" id="text-org13990b6">
</div>
<div id="outline-container-orge271806" class="outline-4">
<h4 id="orge271806">Infatti, il buffer di ricezione andrebbe poi in overflow.</h4>
<div class="outline-text-4" id="text-orge271806">
</div>
<div id="outline-container-org6c49477" class="outline-5">
<h5 id="org6c49477">Immaginiamo di avere una situazione in cui il sending buffer è di 3000 e il receiving 2000. (mss sempre 500 (ma standard 512)).</h5>
<div class="outline-text-5" id="text-org6c49477">
</div>
<div id="outline-container-orgcb9ff54" class="outline-6">
<h6 id="orgcb9ff54">L'informazione della dimensione dell'altro è nota ad entrambi.</h6>
</div>
<div id="outline-container-org14b05a4" class="outline-6">
<h6 id="org14b05a4">Una volta che il sender ha mandato 2000 bit (in 4 tranche perchè la finestra è di 500), il receiving manda non solo un ACK per controllo errori, ma anche un WIN=0, per il controllo di flusso, che indica che lo spazio è finito.</h6>
</div>
<div id="outline-container-org8af79f2" class="outline-6">
<h6 id="org8af79f2">Quando avrà poi letto 1000 byte, manderà un ACK con lo stesso byte atteso del precedente, ma una window size di 1000.</h6>
</div>
</div>
<div id="outline-container-org41f9561" class="outline-5">
<h5 id="org41f9561">Il problema è che se il secondo ack di riapertura viene perso, il sender rimarrebbe bloccato per sempre, ovvero si avrebbe un deadlock.</h5>
<div class="outline-text-5" id="text-org41f9561">
</div>
<div id="outline-container-orgc40fde9" class="outline-6">
<h6 id="orgc40fde9">Allo scadere di un Persist Timer nel receiver, viene mandato un segmento speciale vuoto, ovvero senza dati, a cui il receiver risponde con un reinvio dell'ack con nuova finestra.</h6>
<div class="outline-text-6" id="text-orgc40fde9">
</div>
<div id="outline-container-orga116e27" class="outline-7">
<h7 id="orga116e27">Se anche quel nuovo ack è perso, allo scadere di un nuovo timer la connessione sarebbe chiusa.</h7>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae545f3" class="outline-4">
<h4 id="orgae545f3">Il problema della silly window syndrome accade quando il receiver riempie la propria window e continua a notificare la nuova disponibilità ma per una quantità di byte minima.</h4>
<div class="outline-text-4" id="text-orgae545f3">
</div>
<div id="outline-container-orgfc8453e" class="outline-5">
<h5 id="orgfc8453e">La soluzione è l'algoritmo di Clark, in cui l'aggiornamento della windows dev'essere almeno grande come la MSS o come la metà del buffer.</h5>
</div>
</div>
<div id="outline-container-org5af507a" class="outline-4">
<h4 id="org5af507a">La rete ignora completamente il controllo di flusso.</h4>
</div>
</div>
</div>
<div id="outline-container-org149aae6" class="outline-2">
<h2 id="org149aae6"><span class="todo TODO">TODO</span> Riempire con ultime 2 lezioni di livello 4</h2>
</div>
<div id="outline-container-orgc668dca" class="outline-2">
<h2 id="orgc668dca">Iniziamo il livello applicazione parlando del DNS, ovvero il Domain Name System.</h2>
<div class="outline-text-2" id="text-orgc668dca">
</div>
<div id="outline-container-orge0cbd2e" class="outline-3">
<h3 id="orge0cbd2e">E' un sistema che permette di rendere più semplice raggiungere un host</h3>
<div class="outline-text-3" id="text-orge0cbd2e">
</div>
<div id="outline-container-orgee697e9" class="outline-4">
<h4 id="orgee697e9">Normalmente si usa un IP per raggiungere un host, ma è praticamente impossibile ricordare un IP.</h4>
</div>
</div>
<div id="outline-container-orgaebad13" class="outline-3">
<h3 id="orgaebad13">Funziona associando un nome (dominio) all'ip di uno specifico host.</h3>
<div class="outline-text-3" id="text-orgaebad13">
</div>
<div id="outline-container-orgb0cf427" class="outline-4">
<h4 id="orgb0cf427">Permette anche di recuperare altre informazioni</h4>
</div>
</div>
<div id="outline-container-org3ffa469" class="outline-3">
<h3 id="org3ffa469">L'idea è quella di disaccoppiare il modo in cui un essere umano raggiunga un certo servizio.</h3>
<div class="outline-text-3" id="text-org3ffa469">
</div>
<div id="outline-container-org5b11c5c" class="outline-4">
<h4 id="org5b11c5c">Ad esempio il servizio potrebbe cambiare indirizzo ip in modo trasparente agli utenti.</h4>
<div class="outline-text-4" id="text-org5b11c5c">
</div>
<div id="outline-container-org2eb4f2f" class="outline-5">
<h5 id="org2eb4f2f">Questo è utilizzato anche per il load balancing, così che il traffico venga diviso su diversi server.</h5>
</div>
</div>
</div>
<div id="outline-container-org2fd1e69" class="outline-3">
<h3 id="org2fd1e69">Il fully qualified domain name (FQDN) contiene un punto alla fine che indica il root domain</h3>
</div>
<div id="outline-container-org25b72aa" class="outline-3">
<h3 id="org25b72aa">Il modo in cui avviene la risoluzione del FQDN fra due macchine, ovvero fra un host che richiede e il server che risponde, è sostituendo ad ogni punto il numero di caratteri che seguono quel punto prima di quello successivo, esempio 2DI5UNIMI2IT0.</h3>
</div>
<div id="outline-container-org8389264" class="outline-3">
<h3 id="org8389264">Una query DNS contiene uno header, il FQDN specifico, il tipo di query(A, AAAA, Mx), la classe (che indica la rete su cui si vuole risolvere, che di fatto è sempre internet)</h3>
<div class="outline-text-3" id="text-org8389264">
</div>
<div id="outline-container-org5db6117" class="outline-4">
<h4 id="org5db6117">Il tipo può essere2 A per IPv4, AAAA per IPv6, MX per posta, CNAME (canonical name) che è un altro nome per lo stesso sito</h4>
</div>
</div>
<div id="outline-container-org2f520a9" class="outline-3">
<h3 id="org2f520a9">La risposta ricopia i dati e inserisce l'indirizzo nell'ultimo campo.</h3>
</div>
<div id="outline-container-org450da38" class="outline-3">
<h3 id="org450da38">Un record DNS in cache può essere associato ad uno specifico TTL, dopo il quale il record scade e la prossima richiesta effettuata da qualunque client dovrà essere risoluta di nuovo</h3>
<div class="outline-text-3" id="text-org450da38">
</div>
<div id="outline-container-org9c5a8cd" class="outline-4">
<h4 id="org9c5a8cd"><span class="todo TODO">TODO</span> Capire funzionamento in caso di record scaduto</h4>
</div>
</div>
<div id="outline-container-org9637bb1" class="outline-3">
<h3 id="org9637bb1">Il resolving DNS avviene con un client che chiede la risoluzione di uno specifico FQDN al resolver all'interno della stessa macchina.</h3>
<div class="outline-text-3" id="text-org9637bb1">
</div>
<div id="outline-container-org55190f4" class="outline-4">
<h4 id="org55190f4">Il resolver usa UDP perchè non gli serve instaurare la connessione e parla con il Local DNS, che viene impostato in fase di configurazione.</h4>
</div>
</div>
<div id="outline-container-org54b497e" class="outline-3">
<h3 id="org54b497e">A livello globale ci sono dei root DNS servers che contengono soltanto i domini di primo livello, con gli IP corrispondenti dei NameServer.</h3>
<div class="outline-text-3" id="text-org54b497e">
</div>
<div id="outline-container-orgef596cf" class="outline-4">
<h4 id="orgef596cf">Usiamo questi se non sappiamo come raggiungere il dominio di primo livello, che di solito però conosciamo già perchè rimane in cache</h4>
</div>
<div id="outline-container-orgc970664" class="outline-4">
<h4 id="orgc970664">Sul libro sono indicati due approcci, uno iterativo e uno ricorsivo, ma gli esempi sono tutti iterativi.</h4>
<div class="outline-text-4" id="text-orgc970664">
</div>
<div id="outline-container-org87cd323" class="outline-5">
<h5 id="org87cd323">L'approccio ricorsivo funziona con il resolver che manda una query al local dns e quest'ultimo risponde con l'indirizzo già pronto.</h5>
<div class="outline-text-5" id="text-org87cd323">
</div>
<div id="outline-container-org7e6346f" class="outline-6">
<h6 id="org7e6346f">Non è implementata nei server per questioni di scalabilità.</h6>
</div>
<div id="outline-container-org6cafc50" class="outline-6">
<h6 id="org6cafc50">Il problema è che sebbene sia molto comoda per il client, il resolver dovrebbe mantenere tantissime informazioni di stato in attesa dei passi successivi.</h6>
</div>
</div>
<div id="outline-container-org7d95c94" class="outline-5">
<h5 id="org7d95c94">L'approccio iterativo si applica dal local dns in poi, mentre fra resolver e local dns rimane ricorsivo, ovvero il local dns mantiene lo stato della richiesta fino all'invio della risposta al resolver.</h5>
<div class="outline-text-5" id="text-org7d95c94">
</div>
<div id="outline-container-orga98ba2c" class="outline-6">
<h6 id="orga98ba2c">Il client continua a ricevere una risposta valida già pronta.</h6>
</div>
<div id="outline-container-org2193f4c" class="outline-6">
<h6 id="org2193f4c">Il local DNS, però, gestisce in modo iterativo.</h6>
<div class="outline-text-6" id="text-org2193f4c">
</div>
<div id="outline-container-orgb8200e7" class="outline-7">
<h7 id="orgb8200e7">Manda l'intero dominio al root, che conosce però solo l'IP di primo livello e risponde con un informazione parziale, ovvero con l'indirizzo del NS di primo livello.</h7>
</div>
<div id="outline-container-org6a7d73d" class="outline-7">
<h7 id="org6a7d73d">Una volta conosciuto quello di primo livello, si chiede al corrispondente NameServer di risolvere la parte rimanente del dominio.</h7>
<div class="outline-text-7" id="text-org6a7d73d">
</div>
<div id="outline-container-org9328b07" class="outline-8">
<h8 id="org9328b07">Questo risponde con l'indirizzo del DNS Server del secondo livello.</h8>
</div>
</div>
<div id="outline-container-org83f3c26" class="outline-7">
<h7 id="org83f3c26">Se il dominio era composto da tre livelli, il DNS server di secondo livello risponde con l'IP specifico</h7>
</div>
</div>
</div>
<div id="outline-container-org0f75bf7" class="outline-5">
<h5 id="org0f75bf7">Anche l'approccio iterativo richidede un overhead per il primo step, che viene attenuato dall'utilizzo della cache.</h5>
<div class="outline-text-5" id="text-org0f75bf7">
</div>
<div id="outline-container-orgdf551e4" class="outline-6">
<h6 id="orgdf551e4">In questo modo, la prossima volta che verrà richiesto un dominio di terzo livello appartenente allo stesso secondo livello, la richiesta verrà effettuata direttamente al Name Server di secondo livello.</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgddb2ba4" class="outline-2">
<h2 id="orgddb2ba4">Ultima lezione</h2>
<div class="outline-text-2" id="text-orgddb2ba4">
<p>
Gli esercizi su livello 2 e calcolo di RTT sono fondamentali. Ce ne sono di solito 2.
Scrivere a rossi@di.unimi.it per problemi.
Le domande sono più o meno metà su livelli bassi e metà su quelli alti.
TCP è molto gettonato.
Non usare tante parole ma fare gli schemi.
Ad esempio, per la chiusura della comunicazione TCP, inserire i messaggi scambiati, compreso l'ACK e possibilmente mettere i timer a lato.
Bisogna essere specifici, ad esempio se viene chiesta la chiusura asimmetrica, non serve descrivere anche quella simmetrica.
Decidere che livello di dettaglio usare per la domanda.
Anche per una domanda sul distance vector e split horizon, sarebbe bene fare un esempio e descrivere bene che il problema è che non viene indicato il link che si usa per raggiungere una destinazione
Il prof non sa esattamente quali sono i valori di alfa e beta, comunque basta indicare quali sono stati usati vicino l'esercizio
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-02-04 Tue 18:31</p>
</div>
</body>
</html>
