<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-01-22 Wed 20:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retibozza</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Retibozza</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga9ead05">References</a></li>
<li><a href="#org89bc25b">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orga35ed1f">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgc9a4cb3">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd32a61e">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orga34e53c">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd63f4e1">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org326c5a1">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgce186af">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orga2be518">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgc6cff4d">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org9608393">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.</a>
<ul>
<li><a href="#org930e134">In una LAN (local a.. network) la rete è broadcast, ovvero c'è un dispositivo che comunica a tutti gli altri, compreso quello da cui ha ricevuto il segnale in entrata. Ovvero un HUB, chiamato anche <b>centro stella passivo</b></a></li>
<li><a href="#org785f985">Un terzo modo, che è come ethernet era fatto inizialmente, si ha una struttura a bus lineare, in cui tutti i dispositivi sono collegati in serie. Sia questa che la seconda sono chiamate <b>broadcast</b>.</a></li>
<li><a href="#orgcbe6ec3">Il problema delle strutture broadcast è innanzitutto quello di creare l'equivalente semantico di una comunicazione fra due soli dispositivi, e si fa utilizzando header di mittente e destinatario, così che nel secondo driver di IO capiscono se salvano o buttano via i dati.</a></li>
<li><a href="#orgda875f4">Un altro problema è che trasmettere sull'hub o su bus lineare è critico e va quindi garantita la mutua esclusività per l'accesso a canale condiviso: non tutti i dispositivi possono trasmettere nello stesso momento.</a>
<ul>
<li><a href="#org2adf6fe">Si può sfruttare un token unico e condiviso dalle stazioni. La struttura è fatta ad anello e chi lo riceve, lo estrae e trasmette. Una volta che la trasmissione torna al primo dispositivo, vuol dire che la comunicazione è arrivata a tutti e cede il token ad un altro.</a>
<ul>
<li><a href="#org549df2d">Da notare che bisogna fidarsi che il dispositivo ceda il token. Potrebbe non farlo, ed in quel caso nessun altro parlerebbe</a></li>
<li><a href="#org1176b56">Questa è una soluzione deterministica, perchè in ogni momento so esattamente chi sta parlando.</a></li>
<li><a href="#org81ebac9">Questo approccio comporta dei problemi:</a></li>
</ul>
</li>
<li><a href="#orgd8a9f9b">Ethernet utilizza, invece, una soluzione <b>non deterministica</b>, fuzzy, in cui c'entra molto la probabilità ed in cui le collisioni sono ammesse, chiamato CSMA-CD.</a>
<ul>
<li><a href="#org8c047f2">Un primo modo, chiamato ALOHA, precedente a quello finale, prevede che nel caso in cui ci sia una collisione, entrambi i mittenti non ricevono alcun ACK e ritrasmettono. Se avessero T uguale, ritrasmetterebbero nello stesso momento, generando una nuova collisione. Viene quindi introdotto un ritardo casuale. Questo diminuisce le probabilità di collisione.</a>
<ul>
<li><a href="#orgde1a58f">Questa soluzione è vincente rispetto la precedente. Questo è un sistema distribuito, in cui un nuovo dispositivo può inserirsi immediatamente e trasmettere in una nuova rete.</a>
<ul>
<li><a href="#orgae59ca7">La prima volta nella storia in cui un approccio probabilistico vince con uno deterministico.</a></li>
</ul>
</li>
<li><a href="#org111db75">Questa soluzione ha un'efficienza minima, intorno al 18%.</a></li>
</ul>
</li>
<li><a href="#org9754491">L'innovazione adottata per il protocollo di Ethernet è l'operazione di ascolto, chiamata CS, ovvero Carrier Sense. Vedo se il canale è libero e solo in quel caso immette il proprio pacchetto.</a>
<ul>
<li><a href="#orge1a1ac0">Il rischio di collisione avviene nel caso in cui due stazioni facciano Carrier Sense nello stesso momento. Scopriranno che il Carrier si è liberato nello stesso momento e immetteranno i pacchetti.</a>
<ul>
<li><a href="#orgd136b5d">Una soluzione per ridurre la probabilità di collisioni di questo tipo, potrebbe essere quella di introdurre un ritardo dal momento in cui viene notata la fine del pacchetto attraverso il Carrier Sense. Dato che la probabilità di questo tipo di collisione è considerata bassa in Ethernet, non viene introdotto un ulteriore ritardo. Si scommette che non avvenga di frequenza.</a>
<ul>
<li><a href="#org9c405f2">Applicare il ritardo comporterebbe un protocollo Non-Persistent, ovvero le stazioni non sono competitive.</a></li>
<li><a href="#orgf440642">La nostra scelta è 1Persistent, ovvero i pacchetti trasmettono con probabilità 1.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgef822ba">La collisione viene gestita, però, in modo molto più rapido: se una stazione riceve qualcosa di diverso da quello che sta immettendo, c'è una collisione e blocca istantaneamente la trasmissione. Solo a quel punto inizia il timer random</a>
<ul>
<li><a href="#orgbafd950">BEB (binary exponential backoff) è un modo per calcolare il tempo di ritardo dopo una collisione</a>
<ul>
<li><a href="#org345ba3c">Ad ogni i-esima collisione, genero un ritardo randomicamente scelto fra 0 e 2<sup>i</sup>-1 * unità di tempo</a>
<ul>
<li><a href="#org848887e">Quindi la prima volta il ritardo può essere di 0 o 1 unità, la seconda 0,1,2,3, la terza tra 0 d e 7 è così via</a></li>
<li><a href="#orgff46211">Il prof dice che 2<sup>i</sup>-1 è l'estremo dell'intervallo e non il numero di scelte.</a></li>
</ul>
</li>
<li><a href="#orgabd0d0f"><span class="todo TODO">TODO</span> controllare cos'è</a></li>
<li><a href="#org678c7b8">L'unità di tempo viene dallo standard IEEE 802.3 che specifica il CSMA-CD 1Persistente.</a>
<ul>
<li><a href="#org72909fa">Abbiamo un cavo di 2500 mt, diviso in 5 sezioni di 500mt da 4 repeater. Lunghezza per indice del rame, mi da un tempo di 12.5 microsecondi.</a></li>
<li><a href="#org4ef8fde">Devo garantire che questo tempo, ovvero 2tp = 25 microsecondi, non pesi troppo rispetto al tx.</a></li>
<li><a href="#org161fb57">Immaginiamo ci siano A e B, B alla fine del cavo di cui prima. Prima di 25microsecondi, se B facesse Carrier Sense, troverebbe la rete libera e colliderebbe. Lo stesso vale perchè A riconosca la presenza di bit corrotti e quindi la collisione.</a></li>
<li><a href="#org2d77a32">In una rete di questo tipo, per garantire la collision detection, è necessario che il primo trasmettitore trasmetta per un tempo almeno maggiore di 2tp, ovvero il tempo che la trasmissione arrivi a tutti gli altri, e la trasmissione di tutti gli altri ritorni.</a></li>
<li><a href="#org0cc4c11">Si è quindi deciso di settare il parametro 2tp in 51,2 ms, che è il tempo richiesto ad ogni stazione per continuare a trasmettere, in modo da rilevare la collisione, questo diventa il tempo minimo di trasmissione in rete.</a>
<ul>
<li><a href="#orgd8412c7">Se la rete lavora con un clock a 10Mbit, in 51.2microsecondi trasmetto 512 bit, ovvero 64byte</a></li>
<li><a href="#org1971e86">Questo parametro di 51,2 è l'unita di tempo fondamentale, che viene applicata anche per il BEB.</a></li>
</ul>
</li>
<li><a href="#org70910cf">Lo IEEE 802.11 è lo standard WiFi.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8a6ee56">Nel MAC, che è un layer di livello 2, multiple access control, che sarebbe lo stesso standard IEEE802.3, viene definito anche il formato del pacchetto, in cui si usa un header e un padding, che serve per raggiungere la dimensione minima.</a></li>
<li><a href="#org5cbc8e5">Il nome è Carrier Sense, Multiple Access, Collision Detection.</a></li>
<li><a href="#org995fa15">La curva d'efficienza la ottiene nello sweet spot di stazioni ed è intorno al 95%.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga7bb851">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0</a>
<ul>
<li><a href="#org276e162">Con ethernet, però, abbiamo vari problemi. Uno è quello di disambiguare sequenze di bit uguali, un'altra è quella di far arrivare il valore in modo chiaro al ricevitore.</a>
<ul>
<li><a href="#orgc96d620">Ethernet utilizza quindi la codifica Manchester, che a differenza del solito, legge nel momento centrale del bit, che è il punto meno soggetto a distorsione.</a>
<ul>
<li><a href="#org2229e52">Ciò che viene letto, però, non è il valore assoluto ma la transizione. Se vede che c'è una transizione verso l'alto, abbiamo un uno, altrimenti zero.</a>
<ul>
<li><a href="#org6f3389f">Questo comporta che in caso di valori uguali consecutivi, bisogna cambiare la tensione appena si capisce che il prossimo bit è uguale, e poi nel momento centrale (quello letto), effettuare la transizione.</a></li>
<li><a href="#org31d1d5b">Questo comporta anche che la trasmissione sia shiftata di mezzo ciclo di clock.</a></li>
</ul>
</li>
<li><a href="#org11a2666">Essendo un sistema a stato IDLE pre-trasmissione, prima che questa inizi, il ricevitore non conosce il clock di trasmissione, perchè i bit in entrata sono tutti uguali.</a>
<ul>
<li><a href="#org8e6cd71">La sfida è quella di tenere il clock del ricevitore sincronizzato, magari non fornendgli un clock indipendente, ma incorporando univocamente questa informazione nei dati</a>
<ul>
<li><a href="#org458fb1a">Un primo problema è che il ricevitore non può a priori sapere se una transizione allo scattare del clock (quindi quella di preparazione), non sia una transizione valida "trasmittiva", ovvero quella mid-clock</a></li>
</ul>
</li>
<li><a href="#org86a7e82">Introduciamo un preambolo, formato da 7 byte in cui i bit 0 e 1 si alternano, ed un ottavo byte così costituito [1010101011], che il ricevitore riceve per sincronizzarsi. Gli ultimi due uno, o in particolare l'ultimo, che prevede una doppia transizione, segnala l'inizio del vero frame.</a></li>
</ul>
</li>
<li><a href="#org0fe35bc">(non serve guardare la codifica Manchester differenziale)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org26ebac9">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)</a>
<ul>
<li><a href="#org2b675d1">Si dimostra che al tendere delle stazioni K all'infinito, 1/A tende a "e".</a></li>
<li><a href="#orgbc99553">Inoltre, si ricorda che abbiamo definito tx come dimFrame/velBanda e tp come Lunghezza/velCavo.</a>
<ul>
<li><a href="#orgdcf2c9f">Allora divido tutto per tx e ottengo \(\frac{1}{1+2 \frac{BL}{CF}e }\). Quindi, all'aumentare della banda e della lunghezza, l'utilizzo diminuisce di tanto.</a>
<ul>
<li><a href="#orgce01ac8">Sembra inutile aumentare la banda, perchè diminuirebbe l'utilizzo.</a></li>
<li><a href="#org4fb69d5">Diventa quindi necessario gestire il problema dell'aumento banda</a>
<ul>
<li><a href="#org3fdf0a8">Ricordiamo che nelle reti moderne, la struttura è a centro stella passivo, con un hub a cui fanno riferimento vari dispositivi, in una struttura complessa ad albero, in cui i vari hub sono collegati fra loro.</a>
<ul>
<li><a href="#org55d7b83">Questa struttura causa problemi quando il numero di dispositivi diventa eccessivo</a></li>
<li><a href="#orgfbe7126">Misurando il tasso di collisione di ritrasmissione, ci si rende conto che la rete è overcrowded</a></li>
<li><a href="#org19dfe8d">Per ovviare al problema, si fa uso dei <b>bridge</b>.</a>
<ul>
<li><a href="#orgfb0721e">Immaginiamo di avere una rete locale composta da 6 stazioni, 3 per hub, su 2 hub collegati.</a>
<ul>
<li><a href="#orgf4df8e8">Gli hub sono passivi e ogni stazione può trasmettere agli altri, e può anche collidere con essi.</a>
<ul>
<li><a href="#org0b0b376">Hub collegati comportano che tutte le stazioni facciano parte dello stesso dominio di collisione, ovvero lo spazio di rete in cui le stazioni competono per l'accesso al canale condiviso di trasmissione</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org126b4a2">Il bridge non è totalmente passivo, ovvero che opera a livello soltanto fisico, ma un apparato intelligente che possiede un buffer e trasmette se utile e necessario secondo certi criteri.</a>
<ul>
<li><a href="#org1e7a226">Se il bridge riceve una trasmissione da parte di una stazione, verso la stazione nello stesso dominio, la scarta, perchè sa che è già arrivata a destinazione</a></li>
<li><a href="#org0c5e33b">Se invece riceve una trasmissione verso un altro dominio a esso collegato, la inoltra verso il nuovo dominio.</a></li>
<li><a href="#orgddb14e5">Queste operazioni prendono il nome di Store-and-Forward.</a></li>
<li><a href="#orgfed2f6e">Un bridge è fatto da tante schede Ethernet (Livelli MAC) quante sono le LAN a esso collegate, con corrispondenti MAC Address per entrambe.</a>
<ul>
<li><a href="#org346da98">Quindi si comporta esattamente come una stazione</a></li>
</ul>
</li>
<li><a href="#org574d549">Chiaramente, deve contenere anche una tabella con le stazioni e la corrispondente porta attraverso cui è collegato con esse.</a>
<ul>
<li><a href="#org16ee378">Per riempire la tabella, si fa in modo che il bridge impari poco alla volta dove si trovano le stazioni. Quando riceve un frame da una porta, salva la stazione nella tabella</a></li>
<li><a href="#orgc784a03">Se una frame è destinata ad una stazione a cui non è collegata una porta, si fa broadcast.</a>
<ul>
<li><a href="#orgcaba892">DOMANDA: Quindi ogni volta che trasmetto verso una porta non registrata, occupo tutti i domini di collisione? Se ho un bridge con tante porte, dovrò occuparle tutte, per raggiungerne una sola. E se la porta di destinazione non spedisse mai?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org424d808">Il bridge è il primo strumento di CSMA-CD che opera a <b>livello 2</b></a></li>
</ul>
</li>
<li><a href="#org0e124dc">Un altro dispositivo è lo <b>switch</b>.</a>
<ul>
<li><a href="#org2d72976">E' simile all'hub, ma siamo a livello 2 e contiene una tabella di store e forward.</a></li>
<li><a href="#orgb3e4343">La differenza con il bridge è che le connessioni fra le stazioni e lo switch sono punto-punto, e quindi il CSMA-CD non è necessario. Lo switch smista le comunicazioni in modo intelligente.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2a594fb">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.</a>
<ul>
<li><a href="#org322de27">Una soluzione immediata sarebbe quella di usare 4 fili e dividere un bit in ognuno. In realtà, se ne usano solo 3 per la trasmissione, perchè il 2 è quello usato per CarrierSense e CollisionDetection.</a></li>
<li><a href="#org2ca3f78">Come si raggiungono 1000Mbit, con solo 3 fili da 25Mbps? Si usa una codifica diversa, ternaria non binaria, chiamata 8B6T, ovvero "mappo 8 bit Binari su 6 Ternari".</a>
<ul>
<li><a href="#orge089f5a">A questo punto abbiamo 100 * 10<sup>6</sup> Mbit *6/8 diviso i 3 fili, ottengo 25 bit ternari per filo, che corrispondono a 33 binari.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org455acb6">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.</a>
<ul>
<li><a href="#org0ffab8c">flading, broadcast ma senza restituire alla porta da cui è arrivato.</a></li>
<li><a href="#orgf40a4e2">Un problema è che se un dispositivo, con un certo MAC address, si sposta da un dominio all'altro, la tabella non è più valida. Ogni entrata deve quindi avere un timer, Il flading è quindi parte integrante dell'apparato</a></li>
</ul>
</li>
<li><a href="#org3085c92">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.</a></li>
<li><a href="#org889b0c2">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.</a>
<ul>
<li><a href="#org838601c">E' stato deciso, in sede di standard, ogni tratta deve essere grande al massimo 200 metri, quindi 800 metri in tutto al massimo ( per andare sulle 2 tratte e tornare sulle stesse).</a>
<ul>
<li><a href="#orgacbed02">Su 800 metri, il tempo andata e ritorno è circa 4ms. Con 1Gbit, esce fuori 4000bit, ovvero 500bit, arrotondati a 512B.</a></li>
<li><a href="#org40662ea">Se si fosse lasciato il tempo di 51.2 microsecondi, avremmo dovuto mandare 51200 bit per ogni minimo frame e sarebbe stato poco efficiente. Viene quindi ridotto il diametro, e anche la dimensione dei frame.</a></li>
<li><a href="#orgce9bac8">Per evitare di cambiare anche la porta MAC, che fa il padding di solo 64Byte, il padding viene fatto a livello fisico.</a>
<ul>
<li><a href="#orgaf53c00">In ogni caso, il padding è eccessivo ed è il motivo per cui spopolano gli switch e il Gbit ethernet non ha fatto presa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org078c52e">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.</a>
<ul>
<li><a href="#org49105d6">C'è, però, anche un'interfaccia aggiuntiva, posizionata appena sopra il MAC, ma sempre a livello 2, chiamata <b>Logical Link Control</b>.</a></li>
<li><a href="#org2ff1b73">Quello che facciamo con questo sottolivello serve a creare dei canali logici punto-punto fra sè e le altre stazioni.</a>
<ul>
<li><a href="#orgc6127cf">Quindi, a livello MAC gestisco la situazione Broadcast, e nel Logical Link Control, creo una sovrastruttura logica che modella i collegamenti come punto-punto. In questo modo, dal Logical Link Control in sù, ignoro qualunque ragionamento riguardo il MAC e le sue operazioni.</a>
<ul>
<li><a href="#org010fad7">Questi collegamenti logici, possono essere sia best-effort che affidabili, esattamente come fossimo su una rete magliata.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgafdaba2">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.</a>
<ul>
<li><a href="#org568e3ef">Stazioni che fanno parte di VLAN diverse, non possono comunicare fra loro, anche se fanno parte dello stesso hub. Serve uno switching intelligente per attivare questa funzione, perchè di base le comunicazioni sullo stesso hub girano liberamente</a></li>
<li><a href="#org533205e">Per permettere a macchine appartenenti a VLAN diversi, è necessario utilizzare il routing di livello 3, perchè la separazione introdotta, sebbene logica, è finale.</a>
<ul>
<li><a href="#org063ecdf">Gli switch avanzati posseggono una funzione di routing incorporata</a></li>
</ul>
</li>
<li><a href="#org0d8ef5c">Le informazioni riguardo le VLAN sono contenute nello switch, che <b>tagga</b> le porte e le frame a esse corrispondenti</a>
<ul>
<li><a href="#org456f7c5">Quindi, le stazioni mandano i soliti frame 802.3, e lo switch si occupa di taggarli e smistarli secondo un nuovo standard, chiamato 802.1Q</a>
<ul>
<li><a href="#org065a49c">Entrambi i formati, posseggono il DestinationAddress come primo campo. L'1Q, rimpiazza il campo della lunghezza con quello del protocol ID. Quindi, in quel campo, posso aspettarmi sia una lunghezza che l'ID, ed il secondo viene distinto dal fatto che contiene 8100H in hex, ovvero u numero maggiore di 1500 che è la lunghezza massima.</a></li>
<li><a href="#orge36458a">Nei due byte successivi, si trovano info legate alle VLAN e, in particolare, 12 bit di VLAN identifier.</a></li>
<li><a href="#org2106870">Il cavo fra switch, su cui circolano soltanto frame <b>tagged</b>, si chiama <b>trunk</b></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9da70b4">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.</a>
<ul>
<li><a href="#org9220af4">Convergence sublayer e Physical-medium dependent layer per il physical layer, il cui primo serve per separare ulteriormente il livello fisico finale, che è fortemente dipendente dall'architettura</a></li>
<li><a href="#orgb61ba7d">LLC(Logical Link Control) e MAC(Multiple Access Control), il cui primo si occupa di rendere trasparente la gestione complicata del CSMA-CD da parte del MAC, gestendo apparentemente le connessioni come punto-punto.</a></li>
</ul>
</li>
<li><a href="#org3a35279">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.</a>
<ul>
<li><a href="#org0ebdf8e">Chiaramente, il MAC address smette di avere valore, su questa scala, e viene introdotto l'IP, che identifica univocamente qualunque stazione appartenente a qualunque LAN.</a></li>
<li><a href="#org5182586">Nell'andare da una stazione ad un altra, quindi da un livello Application all'altro, attraversiamo un numero indefinito di macchine che operano al massimo a livello 3. Ognuna di esse deve occuparsi dell'Addressing, ovvero come gestire l'univocità dell'IP, ed il routing, ovvero come trovare una strada fra le stazioni in modo efficiente.</a></li>
<li><a href="#org046ca30">Nel livello 3 non c'è solo un entità, ma 5, di cui analizzeremo due e IP in particolare, con il suo sottomodulo OSPF, per il routing. L'altro è ARP, con cui si mappa/risolve l'IP globale nel MAC.</a></li>
</ul>
</li>
<li><a href="#org2526aab">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.</a>
<ul>
<li><a href="#org6f9973f">Il formato di un pacchetto IP è formato da 5 parole (ovvero 4 byte, 32 bit) ed un ultimo spazio opzionale, utilizzato ad esempio per il source routing.</a>
<ul>
<li><a href="#orge4fcf43">Il primo campo è quello versione, che occupa i primi 4 bit e indica la versione del protocollo, di cui ne esistono due, la v4 e la v6.</a></li>
<li><a href="#orge6da679">Dopodichè c'è la header length, che occupa altri 4 bit e specifica quanti byte è lungo l'header. Serve nel caso in cui il campo option venga utilizzato, perchè ha lunghezza variabile.</a></li>
<li><a href="#org7a25431">Gli 8 bit successivi sono occupati dal Type Of Service (TOS),</a>
<ul>
<li><a href="#orgaaedf0c">E' importantissimo soprattutto oggi, dato che viaggia traffico di tipo diverso (best-effort, audio, video, real time) ed ognuno richiede un servizio diverso.</a>
<ul>
<li><a href="#org6717277">Se arriva un flusso di contenuti real-time, in cui il gitter è importante, questo verrà processato per primo. Lo scheduler sceglie la coda d'uscita in cui imbucare in base a questo parametro, e chi lo decide è il livello superiore.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb9e6b9c">I successivi 16 bit che completano la parola riguardano la Total Length, che quindi può arrivare a \(2^{16}\).</a></li>
<li><a href="#orgc668eb5">Nella prossima parola, si inizia con 16 bit per l'ID, seguito da 3 bit, di cui il primo vuoto per futuro uso e due bit chiamati D (Do not fragment) e M (More fragment)</a></li>
<li><a href="#org1473868">Poi ci sono i restanti 13 bit della parola, che si chiama Fragment Offset</a>
<ul>
<li><a href="#org221e879">Gestisce la frammentazione all'interno del livello 3. Un'unità dati utente non può passare sulla rete nella sua interezza e va frammentata per essere trasmessa. Di solito questa è una funzionalità di livello 4. Questo è un altro tipo di frammentazione.</a>
<ul>
<li><a href="#org3e60b51">Un dato viene prodotto a livello 7 e frammentato in <b>segmenti</b> dal livello 4, che vengono poi singolarmente mandati al livello 3 attraverso il relativo servizio, che lo manda alla rete, che non è un concetto astratto ma una rete di qualche tipo, ad esempio Ethernet, la cui grandezza massima è 512 o ~1500 byte. Quindi il livello 3 deve frammentare a sua volta, che comunica direttamente con il livello 2 per capire la lunghezza massima e predispone sequenze da essa dipendenti.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org07266a5">Nella terza parola, i primi 8 bit sono un timestamp, TTL (Time to live).</a>
<ul>
<li><a href="#org7677b6a">Ogni pacchetto parte dalla sorgente, che decide quanto tempo può vivere il pacchetto in rete e se arriva alla destinazione con un valore nullo, verrà discardato. Sebbene si parli di Time, di fatto la misura è l'Hop, ovvero quanti step effettua. Se ne effettua troppi, potrebbe essersi trovato in un lungo loop.</a></li>
</ul>
</li>
<li><a href="#orgcbfd7d3">Il secondo campo di 8 bit si chiama Protocol selector.</a>
<ul>
<li><a href="#org3c9f9a9">A livello 4 esistono diversi protocolli, ad esempio TCP ed UDP. Il pacchetto destinazione deve avere un modo per capire quale protocollo la sorgente abbia utilizzato per inviare il pacchetto.</a></li>
</ul>
</li>
<li><a href="#orgcf4a1a4">I restanti 16 sono di Header Checksum</a>
<ul>
<li><a href="#orga2eef85">Internet è, per definizione, una rete best-effort. Non c'è nessun tipo di affidabilità implementata prima del livello 4. Sull'header, però, si utilizza una checksum in modo da controllare, limitatamente all'header, la validità, in modo da scartare i pacchetti non validi.</a></li>
</ul>
</li>
<li><a href="#orgad03c4a">Nella quarta e quinta parola troviamo rispettivamente il Source e il Destination address, che quindi sono di 32 bit ognuno.</a></li>
</ul>
</li>
<li><a href="#org3379a66">Immaginiamo di avere due stazioni che comunicano, passando attraverso vari gateway, che collegano stazioni attraverso tecnologie diverse.</a>
<ul>
<li><a href="#org8522137">Ad esempio, immaginiamo che la source esca con un ring, con un limite di 4000 byte per frame, passi per due gateway, di cui il secondo è collegato ethernet, con un limite di 1500 byte per frame alla stazione di arrivo.</a>
<ul>
<li><a href="#org04ac34a">In questo caso, devo splittare il pacchetto in un certo modo all'uscita, sfruttando i campi che abbiamo visto prima, ovvero l'ID del pacchetto e il fragment offset (che è un array a scorrimento con info riguardo la posizione del pacchetto mandato).</a></li>
<li><a href="#org6e57d70">Innanzitutto, non posso utilizzare tutti i 4000, perchè 20 servono per l'header.</a></li>
<li><a href="#org30d4d91">Inoltre, la dimensione massima è a 16 bit, ma l'indice di fragment offset è su 13. Come si potrebbe indicare l'indice successivo a un pacchetto che già occupava la dimensione massima su 16 bit?</a></li>
<li><a href="#org67d375a">Si decide di utilizzare ogni bit per indicare un ottetto. Questo comporta che ogni frammento deve avere una dimensione in byte che sia un multiplo di 8.</a></li>
<li><a href="#org5064088">Il primo frammento sarebbe quindi di una dimensione uguale al multiplo di 8 appena minore dello spazio rimasto oltre i byte.</a>
<ul>
<li><a href="#org6176b54">L'ID è assegnato, la lunghezza totale pure. Nel primo frammento il fragment offset sarà a 0, e il bit More fragments a 1. Nel secondo pacchetto, invece, il fragment offset sarà uguale al numero di byte spediti in quello precedente, diviso 8. Così indico la posizione che il nuovo frammento occupa rispetto a quello precedente. Alla fine, il bit M verrà settato a 0 e si passerà al prossimo.</a></li>
</ul>
</li>
<li><a href="#org38b7b3d">Il riassemblamento viene effettuato soltanto dagli end system, quindi i pacchetti non vengono riassemblati per poi essere di nuovo frammentati per rispettare i nuovi protocolli, ma si lavora sui frammenti già presenti.</a></li>
<li><a href="#org7d28129">In ogni tratta mi occupo di soddifare i requisiti della rete fisica di cui mi sto occupando, ma non ricompongo mai, scompongo soltanto ulteriormente.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org69c3c2c">L'indirizzamento avviene attraverso l'IP address, che consiste in 4 sequenze di 8 bit, di cui viene rappresentato il valore decimale.</a>
<ul>
<li><a href="#org315705e">L'indirizzo IP è unico a livello globale. Esiste un organismo internazionale, chiamato ICANN, ovvero "&#x2026; for Name and Numbers" e se voglio assegnare un nome al mio dispositivo, devo chiedere a loro.</a></li>
<li><a href="#orga3a9e92">Abbiamo 5 modalità di addressing:</a>
<ul>
<li><a href="#org268a7af">Tutte queste soluzioni sono rivolte a garantire l'unicità degli indirizzi IP</a></li>
</ul>
</li>
<li><a href="#orgab13f4f">Nel CLASS based, esistono 3 classi diverse, che gestiscono trasmissioni Unicast, ovvero punto-punto.</a>
<ul>
<li><a href="#org3a246aa">Esistono anche una classe per Multicast e una Reserved.</a></li>
<li><a href="#org15a52e1">La classe A è caratterizzata dal primo bit settato a quindi il valore del primo byte è da 0 a 127</a></li>
<li><a href="#org9b8448e">La classe B ha il primo bit settato ad 1, quindi da 128 a 191</a></li>
<li><a href="#orge975a40">La classe C ha i primi due bit, quindi da 192 a 255</a></li>
<li><a href="#org4b9ce94">In ogni classe, una prima sezione riguarda l'ID della rete, mentre la seconda riguarda il singolo Host</a>
<ul>
<li><a href="#orge3d81c3">Se un router vede che la sezione iniziale è di passaggio, non si preoccupa neanche di controllare l'HostID.</a></li>
<li><a href="#org7a8d469">Più alta è la classe, meno reti univoche esistono, ma hanno più spazio per host.</a></li>
</ul>
</li>
<li><a href="#orge585120">C'è un problema di frammentazione interna: è praticamente impossibile che un certo network ID utilizzi tutti gli Host ID ad esso associati</a></li>
<li><a href="#org851a591">Il subnetting riserva, a partire dalla divisione in classi precedente, una parte dell'HostID per creare delle subnet, utili all'amministratore per gestire ed organizzare logicamente le reti.</a>
<ul>
<li><a href="#orga1b32ff">Prendiamo un indirizzo del tipo 130.50.15.6.</a>
<ul>
<li><a href="#org799c23b">Ignoriamo i primi 16 bit, che sono quelli del NetID, abbiamo 15.6, ovvero 00001111 00000110.</a></li>
<li><a href="#org6b79aa6">Come fa il router a selezionare i 6 bit della subnet e i 10 bit dell'host?</a>
<ul>
<li><a href="#org9584ac3">Bisogna in qualche modo istruire il router in modo che capisca che questo il modo in cui vanno letti e non quello originario, in cui tutti i bit sono Host.</a></li>
<li><a href="#org21d2aa6">Viene quindi introdotta una subnet mask, che filtri via i 6 bit della subnet e lasci tutto il resto, venendo sovrapposta con un AND, dove i 6 bit della subnet, e tutti i bit precedenti, quelli del NetID sono settati a 1, in modo da lasciarli intatti, e il resto a 0, in modo da cancellare il restanti 10 bit dell'host.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgeb85436">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.</a>
<ul>
<li><a href="#orgf12c20e">Gli altri metodi, CIDR e NAT, sono usati per superare il problema della frammentazione interna degli IP e aumentare la longevità di IPv4.</a>
<ul>
<li><a href="#org3631536">Prima o poi, gli indirizzi a 32 bit di v4 finiranno, e saremmo costretti a utilizzare i 128 bit del IPv6.</a></li>
<li><a href="#orgc6fa437">CIDR sta per Classless Inter Domain Routing e invece di dividere in classi, lo fa in blocchi autonomi e indipendenti, geografici (europeo, nord-americano, asiatico, ecc.).</a>
<ul>
<li><a href="#org4de2b24">Per esempio, in Europa gli indirizzi vanno da 194.0.0.0 a 194.255.255.255 e lo stesso per 195. Quindi abbiamo 3 sequenze da 8 bit, quindi ognuna da 256 indirizzi, con un totale di 16,777,216. Questo numero è per ogni sequenza iniziale di bit, quindi, moltiplicata per 2, ci porta ad un totale di 33,554,432 indirizzi per l'europa.</a></li>
<li><a href="#org139b38d">Il vantaggio è che ogni operatore può scegliere un numero di subnet o host che preferisce.</a>
<ul>
<li><a href="#org30aea46">Fra paginazione e segmentazione, il vantaggio è che la seconda fa perdere frammentazione interna, ma può creare quella esterna.</a>
<ul>
<li><a href="#orga219dc0">Infatti, nel momento in cui ogni spazio è occupato e uno degli spazi viene deallocato, bisogna trovare qualcuno che abbia bisogno di un numero massimo uguale a quello lasciato, altrimenti non trova posto e quello spazio rimane inallocato.</a></li>
</ul>
</li>
<li><a href="#org1e0db39">Supponiamo che un organizzazione di Milano richieda 2048 indirizzi e gli viene assegnato l'indirizzo 194.24.0.___, fino a quello 194.24.7.___. L'ultima parte è interna e quindi non serve indicarla.</a>
<ul>
<li><a href="#orge25c4c1">All'organizzazione viene assegnato l'indirizzo base, ovvero i primi 3 byte. Bisogna però dare al router un altro strumento di filtro, per evitare che vada ad utilizzare indirizzi fuori da questo slot.</a></li>
</ul>
</li>
<li><a href="#orgb27673f">Una di roma chiede 2046 indirizzi, servono quindi 16 pagine da 256 indirizzi, allora 4 bit saranno cancellati</a></li>
<li><a href="#org76d0abf">Ogni router deve quindi far girare tutte le maschere che conosce in AND con l'indirizzo ricevuto, finchè non trova la base dello spazio di indirizzi che è stato assegnato.</a></li>
<li><a href="#org70071e5">Questa soluzione allunga la vita a IPV4, ma non risolve completamente il problema. Fra l'altro, il numero massimo di IP è 30 milioni, molto minore della popolazione europea.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4174286">Il NAT estende ulteriormente la vita di IPv4.</a>
<ul>
<li><a href="#orgce555d4">Ogni rete privata ha un NAT, che è un router, che fa da "firewall" fra il mondo di indirizzamento pubblico e quello di indirizzamento privato.</a></li>
<li><a href="#org1bce080">Vengono riservati gli ip che iniziano con 10, 172 e 192 alle reti private.</a></li>
<li><a href="#org3279665">Ogni organizzazione viene raggiunta da un IP unico a livello globale, che poi smisterà il pacchetto agli IP, univoci solo a livello di organizzazione, degli host singoli.</a></li>
<li><a href="#org2e36e20">Ovviamente, è necessario che i pacchetti salvino sia l'IP globale che quello locale.</a></li>
<li><a href="#orgb405482">Bisogna gestire il caso delle requeste da parte degli host locali: questi ultimi sanno dove passare per raggiungere il server, ovvero attraverso il NAT. Il server, invece, riceve una request soltanto dal NAT e risponderà ad esso, ma non ha informazione dell'host locale originario.</a>
<ul>
<li><a href="#org4df89f8">Abbiamo bisogno di qualcosa di nuovo per salvare questa informazione, in modo che il NAT riesca ad associare i pacchetti in arrivo con gli specifici host.</a></li>
<li><a href="#org9f9eca4">Un metodo per risolvere questo problema è attraverso il concetto di porta: il TCP è un identificatore numerico che vale solo nel sistema operativo, che associa all'interno della macchina il processo alla specifica entità TCP.</a>
<ul>
<li><a href="#orge2d8b64">Il numero della porta è restituito all'apertura di una socket, come per i file descriptor al momento della open o write in un SO.</a></li>
<li><a href="#org71ae2fd">I server web di tutto il mondo parlano sulla porta 80, well-known-port.</a></li>
<li><a href="#org35f37c4">I server client hanno, invece, un numero di porta effimero assegnato mediante chiamata a primitiva socket e consistente durante la vita della socket.</a></li>
<li><a href="#orgc91a547">Immaginiamo ora che la host machine dietro NAT usi la porta 1500 ed il server la porta 80. Allora, ogni pacchetto conterrà, oltre ai 3 ip coinvolti (host, NAT, server), anche la porta sorgente e quella destinazione, così che la comunicazione avverrà tra le due porte in questione e il NAT avrà modo di associare il pacchetto in arrivo all'host originario.</a></li>
<li><a href="#orgeb6545c">A questo punto, la gerarchia ben definita secondo cui ogni livello pensa solo a sè stesso, crolla.</a>
<ul>
<li><a href="#org774db56">Infatti, IP porta in giro lo header di TCP, che sta a livello 4 e quindi dovrebbe essere completamente ignorato a livello 3.</a></li>
<li><a href="#org14a8f7d">Invece, il router NAT a livello 3, per compiere le sue tipiche funzioni di instradamento nell'inviare il pacchetto alla sua macchina host, deve andare a leggere lo header TCP, in particolare la porta che quello ha assegnato all'host. Lo stesso vale per le comunicazioni in uscita.</a></li>
<li><a href="#org4c97dc9">Insomma, lo svolgimento del livello 3 quando è coinvolto un NAT, è basato su risultati creati a livello 4.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3158f6d">Questa soluzione porta ad un problema successivo: cosa accade se a due processi differenti, viene assegnato lo stesso numero di porta dalle primitive socket?</a></li>
<li><a href="#org4008451">L'unico modo diventa quello di rendere le porte univoche, ed il NAT lo fa utilizzando una numerazione propria e diversa per ogni processo.</a>
<ul>
<li><a href="#org1de6dba">Il NAT, quindi, accede allo header di livello 4 non soltanto per leggere, ma anche per sostituire la porta locale con quella NAT.</a></li>
<li><a href="#org870be24">Ovviamente, modifica anche l'IP.</a></li>
<li><a href="#org3995b6e">Di conseguenza, le reply arriveranno all'IP del NAT e alla specifica porta NAT, che quest'ultimo trasformerà nella porta host corretta.</a></li>
<li><a href="#org10797e5">A cosa serve quindi tenere la porta originale? BHO</a></li>
</ul>
</li>
<li><a href="#org4c8ae1d">Il NAT offre grandi garanzie in termini di sicurezza, perchè le macchine dietro di lui sono assolutamente invisibili ed inaccessibili dall'esterno, infatti fa anche da firewall.</a></li>
<li><a href="#org39d8bd9">L'ultima questione da risolvere è quella di un server dietro NAT, dato che nessuno conosce la porta che mi porta ad esso.</a>
<ul>
<li><a href="#org257ffcf">Un modo banale è quello di assegnargli un IP pubblico, ma perdendo i vantaggi dovuti all'utilizzo del NAT.</a></li>
<li><a href="#org2153ee8">Un secondo modo è quello di aprire la porta specifica del server. In questo modo, tutte le richieste verso quella porta vengono routate al server in questione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2ff2230">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.</a>
<ul>
<li><a href="#org2a0ef71">A livello 2, in una rete CSMA-CD l'indirizzo è il MAC</a></li>
<li><a href="#org52dcd21">A livello 3, l'indirizzo è quello IP, con tutte le considerazioni fatte in precedenza.</a></li>
<li><a href="#orgb1a0474">Un problema che dobbiamo risolvere è quello di mappare l'IP al corrispondente MAC.</a>
<ul>
<li><a href="#org6b5c94a">Infatti, finora non c'è nessun modo per far arrivare un pacchetto a destinazione.</a></li>
</ul>
</li>
<li><a href="#orgbba1bd7">Immaginiamo che A e B siano sulla stessa rete locale.</a>
<ul>
<li><a href="#org4d5a1d2">Se la macchina A manda un pacchetto al modulo B, chiede ad ARP di risolvere l'IP in un MAC address, così che possa mandarglielo attraverso il livello 2</a></li>
<li><a href="#orgd7d9458">In pratica l'ARP, per conto di IP, manda ai livelli sottostanti una richiesta, ARPRequest, così che il dispositivo in questione risponda con un ARPReply, rispondendo con il proprio MAC, che ARP fornirà al livello IP della macchina sorgente.</a>
<ul>
<li><a href="#org16c6367">Le due macchine, nell'esempio, si trovano nella stessa rete. Ovviamente, nella richiesta non si sa chi sia l'host destinazione, quindi è necessario fare una richiesta broadcast. La risposta sarà, invece, punto-punto.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org455c2e2">Immaginiamo adesso che siano su macchine diverse.</a>
<ul>
<li><a href="#org7adf358">A manda richiesta a Z, su un'altra rete.</a></li>
<li><a href="#orgec01aea">Il site access gateway leggerà il NETID e vedrà che non appartiene alla rete locale e che quindi va cercato al di fuori. Prenderà lui in carico l'operazione.</a></li>
<li><a href="#org973da04">A questo punto, risponderà con il proprio MAC, in modo che A mandi le richieste al gateway.</a></li>
<li><a href="#org20d2028">Il gateway aspetterà autonomamente per la ARPReply della macchina remota e salverà il risultato.</a></li>
<li><a href="#orgfe7eff2">Questo servizio si chiama ProxyARP.</a></li>
</ul>
</li>
<li><a href="#orgeed7755">ARP in ogni dispositivo terrà una ARP Cache, in cui salverà tutte le associazioni IP-MAC, così che le volte successive non servirà una nuova richiesta.</a></li>
<li><a href="#orge7adf3a">Quindi uso ARP per fare una discovery delle macchine che sono raggiungibili in rete.</a></li>
<li><a href="#org01b062a">Anche in questo caso, abbiamo un livello 3 che per funzionare (anzi, il suo obiettivo) è di livello 2. Deve infatti andare a toccare il MAC, indirizzo di livello 2, ma in questo caso almeno fa una richiesta</a></li>
<li><a href="#org19284db">Notiamo che nello header di livello 3, il campo type è usato anche per identificare se la richiesta sia IPv4 o ARP</a></li>
</ul>
</li>
<li><a href="#org0fc631e">Introduciamo il DHCP</a>
<ul>
<li><a href="#org7fd68ab">Abbiamo tante macchine collegate ad una LAN, che possono essere nostre oppure di ospiti che arrivano transitoriamente. Come assegniamo l'IP privato alle macchine?</a>
<ul>
<li><a href="#org4861a87">La LAN potrebbe essere Wireless, collegata tramite un Access Point ad una Lan fisica, che tramite il suo Access Gateway è collegata alla rete fisica.</a></li>
</ul>
</li>
<li><a href="#org15d33a8">Il Gateway riesce a fare Address Resolution e quindi è anche un NAT. Ovvero, riesce a mascherare un indirizzo interno.</a>
<ul>
<li><a href="#orgd0df152">Ci presenta con un IP pubblico alla rete, ma poi smista alle macchine singole con gli indirizzi privati.</a></li>
</ul>
</li>
<li><a href="#org7c811c1">Questi indirizzi potrebbero esere statici, ma questo è scomodo. (Perchè?).</a></li>
<li><a href="#org6e23884">E' più comodo se al momento della prima connessione alla rete, venga assegnato un IP dinamico al dispositivo, che rimanga fino allo spegnimento.</a></li>
<li><a href="#orga63ba45">Per assegnare l'IP dinamico, usiamo il server DHCP (eventualmente molteplici)</a>
<ul>
<li><a href="#orgc13eb47">Appena una macchina cliente viene bootata, fa un operazione di Request DHCP al server, che farà a sua volta una Reply.</a></li>
<li><a href="#orgc1f6590">La reply assegna un IP privato, valido per tutto il tempo necessario.</a>
<ul>
<li><a href="#orga4eafcb">Addirittura, un DHCP address ha un TimeToLeave, poi viene buttato e refreshato.</a></li>
<li><a href="#org90b5814">Al punto che quando arriva un ospite (abilitato ad accedere alla rete), loro parlano con DHCP e diventano a tutti gli effetti parte della rete.</a></li>
</ul>
</li>
<li><a href="#orga3df222">La RequestForComment che lo definisce è la 2131.</a></li>
<li><a href="#org28eaab0">Il client triggera la richiesta, che nello specifico si chiama DHCP Discover.</a>
<ul>
<li><a href="#org918919e">Questa discover è un pacchetto IP che viaggia con sorgente 0.0.0.0, perchè non so scriverlo ed è proprio per questo che mando la richiesta.</a></li>
<li><a href="#org1ef64ea">La destinazione è 255.255.255.255. Un pacchetto broadcast all'interno della LAN. Non va direttamente al server DHCP. Il motivo è che se io voglio un assegnamento dinamico per ogni macchina, anche non appartenenti alla mia rete, non posso assumere che questi sappiano l'indirizzo del server DHCP.</a></li>
<li><a href="#org165f9d0">Inoltre, se io mettessi un singolo IP, perderei la possiblità di avere molteplici DHCP server, utilizi banalmente per ridondanza.</a></li>
<li><a href="#org805ec63">Poi c'è un campo Time To Live,  con un Transaction ID, che viene associato all'indirizzo della macchina.</a>
<ul>
<li><a href="#orgf527c15">Questo serve per associare le request alle response</a></li>
<li><a href="#org6a429c0">Per identificare questo Time To Live con il client della richiesta, non può essere utilizzato l'IP, ma necessariamente il MAC di livello 2.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7bc0665">Il server riceve la richiesta e reagisce con una DHCP Offer.</a>
<ul>
<li><a href="#org11b6d41">Quello che offre il DHCP server è l'IP address.</a></li>
<li><a href="#org77d9008">Sarà sempre un pacchetto con sorgente IP del Server, broadcast e lo stesso transactionID della richiesta.</a>
<ul>
<li><a href="#org882b60a">Deve necessariamente essere broadcast.</a></li>
</ul>
</li>
<li><a href="#org3383704">Prima di fare la offer, il server fa un check. Il check dell'IP prevede che tramite ICMP il server sia in grado di verificare se per caso quell'IP non sia stato già assegnato a qualcuno per errore.</a>
<ul>
<li><a href="#org7fda429">In pratica fa un ping, che prevede un echo se la stazione è raggiungibile. Se l'echo è assente, l'IP non è stato associato a nessuno. Altrimenti l'IP va aggiornato.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9da067d">A questo punto il client ha <b>apparentemente</b> risolto il suo problema.</a>
<ul>
<li><a href="#org2cc334f">Si può immaginare che il client abbia un timeout in modo che non trascorra troppo prima dell'arrivo di una offer. (Stesso principio dell'ACK).</a></li>
<li><a href="#org3cdb5b0">Il problema è che un algoritmo di questo tipo funzionerebbe se e solo se ammettesse uno e un solo server DHCP operativo per ogni rete, ma il protocollo è fatto per funzionare con un numero arbitrario di server.</a>
<ul>
<li><a href="#orgd7223c2">Infatti, la discover è in broadcast e arriva a tutti i server, che si adopereranno tutti per offrire un IP.</a></li>
</ul>
</li>
<li><a href="#org3220e03">Bisogna garantire che venga accettata l'offerta di un solo server.</a></li>
</ul>
</li>
<li><a href="#org3ce8f92">Diventa necessaria un ulteriore fase, una commit, chiamata DHCP Request.</a>
<ul>
<li><a href="#org13ec8d2">Questa viaggia con stesse sorgente e destinazione della discover (0 e 1Broadcast), ma con un ulteriore campo scelta, che contiene un ID del server la cui offerta è stata accettata.</a></li>
</ul>
</li>
<li><a href="#org6e3f09a">A questo punto, si chiude il commitment con una DHCP Ack, che è una validazione della request. Anche questo è mandato in broadcast secondo IP.</a>
<ul>
<li><a href="#org85058d6">Ricordare che tutte queste comunicazioni di risposta da parte del server, utilizzano il MAC di livello 2 e sono quindi Unicast.</a></li>
</ul>
</li>
<li><a href="#org340a788">Questo protocollo è un protocollo a 4 vie, a causa della necessità di selezionare fra i vari server.</a></li>
<li><a href="#org47d7302">Servono inoltre dei check per verificare la validità degli IP, anche dal punto di vista del client.</a>
<ul>
<li><a href="#org91c88e9">Viene utilizzato ARP, che è perfetto per questo lavoro, ovvero risolvere un IP in un MAC.</a>
<ul>
<li><a href="#orge906ec6">Facendo una ARP request con l'IP appena assegnato al server, in caso di risposta positiva si capisce che l'IP è già assegnato.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org12d787b">Esistono dei meccanismi di ricovero, per gestire i casi in cui i messaggi vengano persi. Si utilizza ad esempio un timer T, che viene eseguito massimo K volte (numero di retry). Una volta aver provato K volte, si ritorna alle origini e si ricomincia da capo.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc358057">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).</a></li>
<li><a href="#org45d723d">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente</a>
<ul>
<li><a href="#org6548db2">Immaginiamo di avere due macchine con porte I/O e un forwarder in mezzo, che contiene una tabella e fa un lookup per capire su quale porta trasmettere il messaggio entrato.</a>
<ul>
<li><a href="#orgf74c36a">A livello 2, questo è fatto dal bridge, che popola e spopola le tabelle periodicamente per lasciar spostare le macchine.</a></li>
<li><a href="#orge4ace56">Se saliamo di un piano, quello che cambia radicalmente è che non è più vero che la macchina destinazione sia attaccata al link. La validità di un forwarding livello 2, a livello 3 non è più sufficiente.</a>
<ul>
<li><a href="#orgf1b141b">Il forwarding deve avere la capacità di scegliere la porta che conduce alla destinazione in futuro, e in un modo oscuro alla singola macchina.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org290eec7">A livello 3, la tabella viene popolata da un secondo processo, che chiamiamo <b>router</b>, che lavora con i suoi pacchetti di controllo, utili soltanto a lui, tramite i quali impara la topologia della rete e popola la tabella in modo da permettere di raggiungere ogni host in un modo efficiente, possibilmente il cammino minimo.</a>
<ul>
<li><a href="#orgbf325b6">La cosa interessante è che abbiamo una separazione netta fra tutto ciò che è gestione dei dati utente e la gestione di controllo di tutto ciò che serve alla rete autonomamente perchè funzioni.</a></li>
<li><a href="#orgdde5dca">Con il routing questa diventa chiara.</a>
<ul>
<li><a href="#orga4899b9">Finora i messaggi di controllo e i dati erano mescolati, anche fisicamente.</a></li>
<li><a href="#org3ee6554">Adesso, il router lavora in modo assolutamente autonomo.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgda4ce45">Il router opera attraverso 3 tecniche:</a>
<ul>
<li><a href="#org1d16bcf">Il protocollo con Distance vector opera assegnando due etichette con numero del link e corrispondente peso su ogni arco bidirezionale.</a>
<ul>
<li><a href="#orgb4b1f44">Ogni nodo produce la tabella delle adiacenze. Questa contiene Router, Link e Cost.</a>
<ul>
<li><a href="#org3266fd5">Sè stesso è raggiungibile da sè stesso (no link) con costo 0.</a></li>
<li><a href="#orgd2c4f15">Ogni altro router, è raggiungibile attraverso un certo link, con un costo uguale alla somma delle etichette dei pesi di tutti gli archi che vengono attraversati.</a></li>
</ul>
</li>
<li><a href="#org7f64ae1">Con queste costruiamo la conoscenza locale, ovvero tutti i router appena adiacenti attraverso soltanto un filo, insieme al loro costo.</a>
<ul>
<li><a href="#org0d970d7">Ancora non abbiamo una visione topologica della rete. Abbiamo solo una visione delle adiacenze.</a>
<ul>
<li><a href="#org7f79420">Un singolo nodo nono ha idea di quali nodi possa raggiungere oltre le adiacenze.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb591f16">Il modo per passare da una conoscenza locale a quella globale sfrutta la comunicazione fra nodi.</a></li>
<li><a href="#org8f6eb0c">Periodicamente viene trasferito agli altri il distance vector, ovvero l'associazione Router-Costo</a>
<ul>
<li><a href="#org5e0b404">Ogni router ha un proprio timer, alla scadenza del quale trasferisce il vettore delle distanze ai suoi vicini.</a></li>
</ul>
</li>
<li><a href="#orgfb8f511">Quando un nodo riceve il vettore delle distanze del vicino, aggiorna il proprio vettore con i nuovi nodi raggiungibili attraverso il vicino, la cui distanza è la somma fra il primo nodo è quello appena collegato e quest'ultimo con il nuovo.</a></li>
<li><a href="#orgd023831">Ogni vettore delle distanze nuovo che arriva, un router calcola anche tutte le nuove distanze per le destinazioni che già conosce, in modo da aggiornare nuove distanze minime.</a></li>
<li><a href="#org6045df6">Il tempo necessario per conoscere tutta la rete è lineare con il suo diametro.</a></li>
<li><a href="#orgeafbb6d">Viene inoltre utilizzato il trigger update con cui i nodi vicini possono richiedere informazioni alla variazione dello stato. Ad esempio usano il trigger update i router appena accesi così chiamano velocemente informazioni nuove.</a></li>
<li><a href="#orgc3c4d60">Il problema di questo protocollo è che non c'è modo di aggiornare in caso di peggioramenti e questo causa un malfunzionamento abbastanza grave.</a>
<ul>
<li><a href="#orgf48bd30">Immaginiamo che un link su un certo nodo si guasti.</a>
<ul>
<li><a href="#orgf0ea541">Il nodo stesso lo riconosce subito e aggiorna la propria tabella con valore <b>infinito</b> per il nodo dietro quel link.</a></li>
<li><a href="#org2200a2b">Gli altri nodi però non lo sanno e continuano a mandare su quel link, se la loro tabella dice che è quella la strada minore.</a></li>
<li><a href="#org9adc9cf">Questa situazione finisce soltanto nel momento in cui B propaga il suo distance vector con costo infinito.</a></li>
<li><a href="#orgf6553ef">Cosa succede se però nel frattempo un altro nodo, non ancora informato del guasto, manda il proprio distance vector al nodo che ha appena notato il guasto?</a>
<ul>
<li><a href="#orgbfa0b8c">Siano A, B e C i nodi, con A che vuole raggiungere C attraverso B, e il collegamento fra B e C guasto.</a>
<ul>
<li><a href="#org45e2cf9">Allora la distanza fra A e C è uguale alla distanza fra A e B più quella fra B e C</a></li>
<li><a href="#org7c0c7aa">Il problema è che adesso la distanza fra B e C è infinita, ma quella fra A e C considera ancora il valore da B e C precedente.</a></li>
<li><a href="#orgfc69b28">Allora B aggiorna la sua stessa distanza fra B e C come quella suggerita da A, che però già contiene la distanza B-C non aggiornata, più la distanza fra A e B.</a>
<ul>
<li><a href="#orgb1415f3">In pratica, B rimpiazza l'infinito con la distanza B-A più A-B più B-C vecchia.</a></li>
<li><a href="#org13e90b8">Alla update successiva, A vede che B ha aumentato la propria distanza di un valore uguale alla distanza A-B e aggiorna il suo valore a quella distanza, più B-A</a>
<ul>
<li><a href="#org9747441">Quindi A rimpiazza A-B + old(B-C) con A</a></li>
<li><a href="#org3adbad8">Quello che succede è questo (indico la distanza fra i nodi A o B e C):</a></li>
</ul>
</li>
<li><a href="#org0e97308">Si inizierà un <b>count to infinity</b> in cui ad ogni step la distanza verso quel collegamento aumenta della distanza fra i due nodi in questione.</a></li>
<li><a href="#org8844df2">Questo accade perchè le distanze di sia A che B verso quello guasto C contengono al loro interno la distanza A-B. Ovvero, B raggiunge C tramite A (o almeno crede di fare così) e A raggiunge C tramite B.Il sistema è innescato da B, che normalmente non dovrebbe aggiornare la propria distanza per includere quella di A, perchè il collegamento diretto con C è banalmente più breve di quello che compie un ciclo tramite A e poi ripercorre il collegamento diretto.</a>
<ul>
<li><a href="#orgbf68a92">Quando però il link con C è danneggiato, accade che il ciclo attraverso A più la vecchia distanza B-C è sicuramente più breve dell'infinito e B aggiorna, senza sapere che A fa affidamento su di lui.</a></li>
<li><a href="#org30716ce">A aggiorna, senza sapere che B fa affidamento su di lui.</a></li>
<li><a href="#org55f9a5e">MAIN</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9a09d34">Le due cause del problema sono il fatto che l'informazione dello specifico nodo utilizzato per raggiungere una destinazione è persa, e che i disstance vector viaggiano in modo asincrono e possono anche essere smarriti.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6900f70">Il count to infinity da luogo al bouncing effect, in cui i pacchetti fra i nodi A e B dell'esempio precedente rimangono bloccati rimbalzando fra gli stessi.</a></li>
<li><a href="#org9e6f3fd">Una soluzione al <b>count to infinity</b> è lo <b>split horizon</b></a>
<ul>
<li><a href="#orge624ded">Il distance vector riporterà costo infinito per il link corrispondente a quello utilizzato per inviare lo stesso distance vector.</a>
<ul>
<li><a href="#org929fe8a">Di conseguenza, quando l'infinito inizia a propagarsi,</a></li>
<li><a href="#org459d63c">Con questo trucco, il distance vector non potrà contenere loop perchè un nodo non sceglierà mai di utilizzare il link che conduce ad un loop.</a></li>
<li><a href="#org30a9b3b">Esiste un caso in cui il problema del count to infinity avviene anche in questo caso.</a>
<ul>
<li><a href="#org0c21baa">In particolare, lo split horizon non aiuta nel caso in cui ci siano più di due router coinvolti. Infatti, in questo caso, il nodo appena adiacente a quello su cui è avvenuto il guasto non direbbe a questùltimo di conoscere la strada, ma la direbbe ad un nodo ancora successivo e collegato al primo, su cui è avvenuto il guasto. il terzo nodo della catena avviserebbe il primo di conoscere una strada, la quale sebbene non passi per il link diretto con il nodo che ha un link guasto, passa per un ciclo che eventualmente arriverà a quel nodo. La conseguenza è la stessa.</a></li>
<li><a href="#orgd8c0c75">Si può dunque dire che lo split horizon abbia un orizzonte di risoluzione di massimo 2 nodi, oltre i quali il problema è irrisolvibile.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6b3f7e1">I difetti sono che: 1 passo solo il peso ma non il percorso seguito ,2 non ho la topologia magliata, ma conosco solo i miei vicini,3 la propagazione è asincrona e potrei perdere qualche informazione, ovvero le tabele non sempre divergono.</a></li>
<li><a href="#org80a496c">Quindi le tre tecniche usate per migliorare l'efficienza di questa tecnica sono le seguenti:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgde5b09b">Ci rifacciamo alla stessa struttura riguardante il routing, con un router che contiene un forwarder con porte IO di ingresso ed uscita e che opera su una tabella di routing, facendo un lookup e stabilendo la corretta porta di output. Chi scrive sulla tabella è il router, che ha i propri pacchetti di controllo e opera come un processo totalmente asincrono ed indipendente.</a>
<ul>
<li><a href="#orgfb2876c">Il router è attivato periodicamente, mentre il forwarder è attivato alla presenza di un pacchetto in coda di input.</a></li>
<li><a href="#org36d7e3f">Vogliamo sviluppare una soluzione alternativa in cui oltre al peso e alla destinazione del cammino, si dice anche il link che si vuole utilizzare</a></li>
<li><a href="#org0824d4e">La gran parte delle reti fondamentali di internet, ovvero quelle intermedie fra LAN, utilizza un protocollo chiamato OSPF Link State</a>
<ul>
<li><a href="#orgb083c23">Voglio costruirmi il grafo della connettività, con i costi di ogni arco, dopo aver scambiato abbastanza informazioni fra nodi.</a></li>
<li><a href="#orgb0e8592">Ogni nodo manda la distanza sui suoi link a TUTTI gli altri nodi, quindi esistono N(N-1) messaggi di controllo</a>
<ul>
<li><a href="#org508c8b9">Questa strategia si chiama FLOODING.</a>
<ul>
<li><a href="#orge2f5b53">Ogni link state viene mandato su tutte le porte IO diverse da quella di arrivo.</a></li>
</ul>
</li>
<li><a href="#orge419df0">Il link state di uno specifico nodo continuerebbe a girare all'infinito. Allora viene introdotto un buffer che tiene l'ultimo state link e informazioni aggiuntive tipo header, contenenti l'indirizzo del mittente, un numero di sequenza associato allo specifico mittente, un TTL, ovvero un numero massimo di hops che possono essere effettuati e alla fine l'informazione vera e propria</a>
<ul>
<li><a href="#orgd254c40">Ogni LS inviato nel flooding prevede anche un ACK</a>
<ul>
<li><a href="#org0258f9b">Questo comporta che nella rete sia occupata da tanto traffico di controllo di livello 2</a></li>
</ul>
</li>
<li><a href="#orga3508ff">Per calcolare le distanze, si usa ICMP con il ping, calcolando la distanza con un cronometro fra l'invio ed il ritorno di un pacchetto.</a></li>
</ul>
</li>
<li><a href="#org2e6ed3d">Le cose positive del link state sono che si conosce la topologia della rete nella sua interezza, così che attraverso Dijkstra si stabiliscano tutti i cammini minimi.</a></li>
<li><a href="#org41b97ec">L'implementazione dei LinkState viene effettuata da OSPF, ovvero open shortest path first.</a>
<ul>
<li><a href="#org9095176">Il problema è che questo calcolo andrebbe fatto da ogni nodo nella rete, con un certo carico computazionale.</a></li>
<li><a href="#org588b3dd">La routing table conterrà la destinazione da raggiungere, il link attraverso cui si raggiunge e il costo, costruito tramite Dijkstra.</a></li>
<li><a href="#orgf4601f3">Questo protocollo è MULTIPATH, ovvero salva i casi in cui due path diverse abbiano lo stesso peso, in modo da fare load balancing.</a></li>
<li><a href="#org7fe2375">Addirittura posso obbligare un pacchetto a passare attraverso uno specifico nodo, imbullonandolo nello header.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4e2c2a3">Adesso immaginiamo di avere una topologia di nodi con due nodi, R1 ed R3, connessi ad una rete (ad esempio lan, ma qualunque) con netID rispettivamente 1 e 3, che contengono al loro interno uno degli host H1 e H3.</a>
<ul>
<li><a href="#orgfb8fc9f">Ogni nodo contiene anche una tabella di adiacenze, in cui ad ogni nodo è associato il link che serve per raggiungerlo</a></li>
<li><a href="#org6a1a9c1">Queste reti si chiamano stub, ovvero reti foglia, e contengono una tabella a loro volta, in cui è salvata la coppia netID-nodo a cui è collegata.</a>
<ul>
<li><a href="#orgb594973"><span class="todo TODO">TODO</span> Capire chi salva quali tabelle e in particolare chi tiene la netId table</a></li>
<li><a href="#orged311ed">Ad esempio, nella rete con netId 1 c'è scritto che la 1 è raggiungibile direttamente e la 3 attraverso il nodo R3.</a></li>
<li><a href="#org0507a53">Quando H1 manda un pacchetto a H3, traduce H3 in R3. Il router R1 manda verso R1 mandando sul router successivo secondo la sua routing table, in particolare sul link associato a quel router.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org73978ad">OSPF ruota sicuramente sulla area 0, ovvero il backbone dello Autonomous System. All'area 0 sono collegate sotto-aree che per comunicare da loro devono necessariamente passare attraverso l'area 0. L'area 0 contiene dei border-router attraverso cui passa TUTTO il traffico, intra area ed extra area.</a></li>
<li><a href="#org6a40b1d">Per mettere in comunicazione AS diversi, serve avere dei link che li collegano e i router fra essi utilizzano un altro protocollo, BGP.</a></li>
</ul>
</li>
<li><a href="#org3248d18">Per migliorare la efficienza e generare le tabelle di routing vengono messe in atto delle tecniche avanzate, fra cui centralizzare il calcolo dei cammini minimi. Un router specifico, chiamato Designated Router, che calcola i cammini minimi per tutte i nodi e gli rimanda le tabelle già calcolate.</a>
<ul>
<li><a href="#org087996a">Si riduce un po' il traffico, ma si ha lo svantaggio di congestionare i link verso lo stesso, su cui convergono le comunicazioni.</a></li>
<li><a href="#org5d88f61">Ormai tutte le reti lo usano.</a></li>
<li><a href="#org0ff55f6">Lo spunto di eleggere un designated router è stato preso tanto bene che invece di eleggere uno dei router, si è deciso di portarlo in cloud, inventando il Software Designed Network SDN.</a>
<ul>
<li><a href="#orgb8aa70e">Nella gran parte dei casi quel router si trova su cloud.</a></li>
<li><a href="#org770f256">Tutto ciò è possibile perchè noi fin dall'inizio abbiamo stabilito che il piano di controllo, routing, è separato dal piano di dati, forwarding.</a></li>
<li><a href="#org814f64a">Esiste un protocollo, Open Flow, che regola le comunicazioni con il Designated Router, anche cercando di risolvere problemi di sicurezza.</a></li>
<li><a href="#orge166cb7">A questo punto il flooding non esiste più, ma avviene una comunicazione punto punto con l'SDN o Designated Router.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgda7d1eb">Supponiamo di avere due macchina che ha uno strato applicativo, seguito da TCP, IP ecc&#x2026;, attaccata ad una rete IP.</a>
<ul>
<li><a href="#orgc6d9e25">Ora immaginiamo che una macchina in mezzo a queste macchine ci sia una rete non IP.</a></li>
<li><a href="#orgb96e679">La macchina centrale deve avere IP per riuscire a prendere i pacchetti e poi l'altro network per processarli correttamente. Poi andranno reinviati in IP</a></li>
<li><a href="#org47e9877">Il TUNNELLING è il modo di gestire lo header durante il passaggio in quella macchina</a></li>
<li><a href="#orgcd3a420">La soluzione banale è che l'intero pacchetto, compreso header, viene incapsulato e lo header dell'altro protocollo viene semplicemente aggiunto, per poi essere rimosso dopo</a></li>
</ul>
</li>
<li><a href="#orge3eaf51">TRANSPORT LAYER NUOVE LEZIONI</a></li>
<li><a href="#org3edddd8">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).</a>
<ul>
<li><a href="#org16987d8">Offre dei servizi che abbiamo già visto nel data-link.</a></li>
<li><a href="#org76a9343">Varie funzionalità possono essere attivate o disattivate.</a></li>
<li><a href="#org1a21a51">TCP e UDP sono ortogonali fra loro. La prima offre disponibilità, mentre la seconda è best-effort e non aggiunge nulla ai livelli superiori.</a></li>
<li><a href="#org8f4eca4">A livello data-link, tra due porte di rete abbiamo una trasmissione può essere affidabile, avere controllo degli errori ecc.</a>
<ul>
<li><a href="#org37c38e5">Quello che non è considerato a livello data-link è se qualcosa va perso a livello network.</a>
<ul>
<li><a href="#org8029c73">Un esempio è che abbiamo il nostro host con il suo livello IP.</a>
<ul>
<li><a href="#org5ee070a">Poi abbiamo tutti questi router intermedi con i loro livelli IP e un protocollo che li leghi (non ci interessa quale).</a></li>
<li><a href="#org511a5fb">In ogni nodo ci sono delle code di ricezione \(RX\) e di trasmissione \(RT\) che hanno una capacità limitata.</a></li>
<li><a href="#org4471539">Nonostante possiamo dare affidabilità al data-link, a questo livello IP, se il RT è in overflow, scarta un pacchetto e questo viene perso del tutto.</a>
<ul>
<li><a href="#orga092b16">Nonostante ci sia una somma di link affidabili, questa non garantisca che tutta la comunicazione end-to-end sia affidabile.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7db1462">In Transport viene riimplementata l'affidabilità in modo che quando un segmento venga perso, venga gestita la ritrasmissione.</a>
<ul>
<li><a href="#orgb278cbb">La trasmissione su cavo è molto affidabile e quindi l'affidabilità a livello data link è passata in secondo piano e diventa più importante quella su tratte più lunghe, con tutta la rete in mezzo, che coinvolgono i router di livello 3.</a></li>
</ul>
</li>
<li><a href="#orgb6e60f8">Le unità base di comunicazione a livello 4 sono chiamate <b>messaggi</b> o <b>segmenti</b>.</a></li>
<li><a href="#org8b78be0">Il livello di trasporto ha anche un suo indirizzamento (naming) utilizzando le porte, che servono per identificare l'applicazione che sta utilizzando il collegamento di livello 4.</a>
<ul>
<li><a href="#orgdf628fa">Mentre l'indirizzo IP serve per identificare l'host di rete</a></li>
<li><a href="#org2e4de53">Immaginiamo di avere un client ed un server con TCP o UDP a livello 4, IP sotto e poi una rete completamente trasparente.</a>
<ul>
<li><a href="#org21f3f34">Abbiamo poi delle applicazioni che comunicano, ad esempio app client e web server con db.</a></li>
<li><a href="#org695f51d">Immaginiamo arrivi un pacchetto IP a livello server.</a>
<ul>
<li><a href="#orgb606275">Il server legge il suo header e con il suo destination address sa che è destinato a lui.</a></li>
<li><a href="#orgb53fdbf">Nello campo "protocol" ci sarà scritto se il pacchetto è da mandare ad IP o UDP.</a></li>
<li><a href="#org37ba146">Le applicazioni ascoltano su una specifica porta (80 per http ecc.)</a></li>
<li><a href="#org027c20a">TCP si chiede: a quale di queste operazioni appartiene questo segmento? in modo da smistarlo correttamente.</a>
<ul>
<li><a href="#org50d1a5f">Quindi l'IP address identifica tutto l'host, il PROTOCOL indica il protocollo di transport e la porta(?) indica l'applicazione specifica che usa i dati.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge6ed47c">Anche dal lato client, si parte dall'Application layer e si sceglie il corretto protocollo (TCP/UDP) da utilizzare.</a>
<ul>
<li><a href="#org3648eae">Quindi l'IP e il protocollo da utilizzare sono informazioni necessarie per aprire la comunicazione.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8d99b0a">A livello di Trasporto si usano le socket.</a>
<ul>
<li><a href="#org1f0cddb">Una socket è fatta così (stessa dell'immagine sul libro):</a>
<ul>
<li><a href="#orge047a10">Abbiamo un ClientAP e un ServerAP (access point), che noi richiediamo semplicemente e sono offerte dal sistema operativo.</a></li>
<li><a href="#org4682d89">Fra i due AP abbiamo una transport entity</a></li>
<li><a href="#org96a8729">Ogni applicazione contiene due buffer che sono RecevingBuffer e SendingBuffer.</a></li>
<li><a href="#org220ab9e">Le socket berkeley sono lo standard de facto, di Unix, che non è altro che un descrittore di file su cui si può effettuare scrittura e lettura.</a>
<ul>
<li><a href="#org94975e7">Una write scrive sull'SB e la read sull'RB</a></li>
</ul>
</li>
<li><a href="#orga5c2cf8">Poi abbiamo un istanza del protocollo TCP che se vede che va tutto bene (poi vedremo cosa vuol dire), prende carico dei dati e li trasmette in rete.</a></li>
<li><a href="#org50561e9">C'è poi un altro livello di buffer, uno per ingresso e uno per uscita, aree di memoria temporanee che TCP riserva per tenere temporaneamente i pezzi di unità di informazione che devono essere ancora trasmessi.</a>
<ul>
<li><a href="#orgb75fde7">TCP lavora a stream di byte e c'è un ordinamento assoluto di essi e va garantito che il ricevitore le riceva nello stesso ordine.</a></li>
<li><a href="#org77703c9">Immaginiamo ad esempio di inviare 1, 2 e 3 e che 2 venga perso.</a></li>
<li><a href="#orga27fad7">Dopo aver ricevuto il 3, il TCP lato client si rende conto che manca qualcosa.</a></li>
<li><a href="#org3da9cb5">Il blocchetto 3 rimane temporaneamente in buffer e quando il blocchetto 2 arriva a destinazione, verrà sbloccato anche il successivo.</a></li>
<li><a href="#orga6ec256">Il buffer tcp d'uscita serve invece per tenere gli stream da mandare fino alla ricezione di un ACK.</a></li>
</ul>
</li>
<li><a href="#orge39458c">Adesso, la velocità di lettura e scrittura sono diverse fra loro, diventa necessario mettere un buffer al centro.</a>
<ul>
<li><a href="#orgb9a5593">Se una macchina genera in modo troppo veloce e l'altra troppo lenta, chiederà di rallentare la trasmissione.</a></li>
<li><a href="#org5ceaf8d">Siamo a livello kernel e non abbiamo tanta memoria.</a>
<ul>
<li><a href="#orge9c3d2f">Se non mettessimo un limite alla memoria, i buffer si saturerebbero e non rispetteremmo le specifiche di TCP che ci offre la totale affidabilità nella trasmissione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org281533f">Con le socket si interagisce in questo modo, ovvero le API da utilizzare sono:</a>
<ul>
<li><a href="#org3b91f28">Abbiamo ancora i due access point client e server che si interfacciano con il TCP/UDP.</a>
<ul>
<li><a href="#org9e1273e">Il livello 7 (application) è implementato nello user space.</a></li>
<li><a href="#org0b265c2">Il livello 4 è implementato nel kernel, quindi nel sistema operativo.</a></li>
<li><a href="#orgca0a34c">Il livello 3 anche</a></li>
<li><a href="#orge886396">Il livello 2 sulla scheda di rete, quindi a livello firmware</a></li>
<li><a href="#org2e6fc47">Il livello 1 è il cavo.</a></li>
</ul>
</li>
<li><a href="#org5772987">Nel server, ci sono:</a>
<ul>
<li><a href="#orgf018546">Una prima chiamata, bidirezionale, è <code>socket()</code>. Questa restituisce un descrittore di file aperto e bidirezionale, ovvero su cui si può leggere e scrivere.</a></li>
<li><a href="#orge6930b4">Poi c'è l'operazione di <code>bind()</code> a cui passiamo un indirizzo IP e una porta, che lega la socket a un indirizzo IP (0.0.0.0 se ascolti su tutti gli IP della macchina). O conosciamo l'IP o utilizziamo un indirizzo DNS e la porta o la sappiamo già o è una porta well-known, come 80 o 8080 per HTTP, 443 e 8443 per HTTPS, ssh sulla 22, DNS sulla 53UDP.</a></li>
<li><a href="#orgc5faa1c">Poi abbiamo <code>listen()</code> che dice alla socket di mettersi in ascolto sull'indirizzo indicato al <code>bind()</code>. Crea inoltre una coda di richieste.</a>
<ul>
<li><a href="#orgad3ed85">Anche qua, questa coda è finita e se arriva un bombardamento di richieste ovviamente il buffer si riempie e le successive richieste non saranno più gestite.</a></li>
</ul>
</li>
<li><a href="#orgcbade44">L'ultima chiamata è la <code>accept()</code>. Questa si blocca in attesa di una richiesta. Quindi è una richiesta bloccante. Aspetta che qualcuno arrivi per aprire una connessione.</a></li>
<li><a href="#org195f3e7">A questo punto, TCP non è ancora intervenuto ma ha stabilito tutte le parti necessarie per ottenere una comunicazione</a></li>
</ul>
</li>
<li><a href="#orga340f78">Nel client ci sono:</a>
<ul>
<li><a href="#org3f3c245"><code>socket</code> come prima</a></li>
<li><a href="#orge74b90b"><code>connect()</code>, bloccante, in cui, come nella <code>bind()</code> specifichiamo un IP e una porta per recapitare correttamente un messaggio.</a>
<ul>
<li><a href="#orgf3ed9be">Questa connect scatena un'apertura di connessione, (o il recapito di un messaggio in UDP), che sblocca il server attraverso la unlock, fa una <code>fork</code> che da luogo ad una nuova <code>socket()</code>, che effettuerà una nuova <code>bind()</code>.</a></li>
<li><a href="#org44d8963">Solo a questo punto viene tirata su la struttura del TCP con i 4 buffer.</a></li>
<li><a href="#org9ab46da">Quando viene effettuata la prima chiamata <code>socket</code> nel server, viene creata solo la coda di richieste.</a></li>
<li><a href="#orga831c54">Solo la seconda chiamata tira su tutto il sistema TCP indicato prima</a></li>
<li><a href="#org7d9af1a">La porta della sorgente è scelta randomicamente.</a></li>
</ul>
</li>
<li><a href="#org920211e">Alla ricezione dell'ok della socket pronta dall'altra parte, si sblocca anche il client e da lì in poi la comunicazione è aperta e si possono utilizzare le system call tipiche dei file, ovvero <code>send()</code> e <code>receive()</code></a></li>
</ul>
</li>
<li><a href="#orgbfc9cc6">Quando voglio chiudere, una delle due chiama una <code>close()</code></a>
<ul>
<li><a href="#org924038a">Questa chiusura coinvolge anche l'entità TCP, ma finora abbiamo soltanto osservato TCP dall'esterno.</a></li>
</ul>
</li>
<li><a href="#orgd682439">Con la quintupla [protocol, ipsrc, ipdst, portsrc, portdst] posso identificare la singola comunicazione che è stata tirata su dopo la serie di procedure appena indicata.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1ebb98e">Il TCP garantisce che la comunicazione sia <b>affidabile</b> e <b>ordinata</b>.</a>
<ul>
<li><a href="#org4eb9892">Opera inoltre un controllo di flusso, ovvero un controllo orizzontale, con un app sorgente che scrive e una dest che legge, entrambe ad un certo rate, in modo che non ci sia overflow.</a>
<ul>
<li><a href="#org7c1bd59">Questo avviene basandosi sul rate minore.</a></li>
</ul>
</li>
<li><a href="#org9f6cced">Opera poi un controllo errori.</a>
<ul>
<li><a href="#org1e865b8">Mentre UDP avverte in caso di errori, TCP si occupa anche di risolverli, gestendo la ritrasmissione.</a></li>
</ul>
</li>
<li><a href="#org2f20f13">Opera poi un controllo di congestione, questa volta verticale.</a>
<ul>
<li><a href="#org374de05">E' vero che TCP nasconde la rete sottostante, ma sa che c'è una rete e sa che questa è potenzialmente inaffidabile.</a></li>
<li><a href="#orgf751188">Sa che se vengono immessi troppi pacchetti su una rete, questa possa essere congestionata.</a></li>
<li><a href="#orgdf96212">TCP prova ad intuire la congestione della rete e prevenire la perdita di pacchetti della rete, diminuendo il rate di trasmissione di questi ultimi.</a></li>
</ul>
</li>
<li><a href="#org2097b4d">Inoltre, è orientata allo stream.</a>
<ul>
<li><a href="#org280b599">Il concetto su cui lavora è dello stream di byte, che devono arrivare tutti.</a></li>
</ul>
</li>
<li><a href="#org5024442">Poi, è orientato alla connessione.</a>
<ul>
<li><a href="#orgc83666d">Prima di utilizzare le socket, leggervi e scrivervi, dobbiamo instaurare una connessione, aprendola, che mantiene un certo stato.</a>
<ul>
<li><a href="#orga35583f">Il drawback è che è necessario tenere lo stato e tutte le info per la connessione in memoria nel kernel, e dev'essere occupato durante tutta la comunicazione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org72cc359">Lo header TCP è rappresentato in pagine larghe 32 bit.</a>
<ul>
<li><a href="#org366f059">Alla prima riga abbiamo 16 bit per porta sorgente e 16 per la destinazione</a></li>
<li><a href="#orgf494994">Alla seconda riga abbiamo i 32 bit per il numero di sequenza</a>
<ul>
<li><a href="#orge8f11f2">Il numero di sequenza indica il primo byte della lunghezza variabile di byte che compone il segmento.</a></li>
<li><a href="#orge2fac03">Viene inizializzato al momento dell'istanziamento della connessione.</a></li>
</ul>
</li>
<li><a href="#org28faaf4">Poi abbiamo il campo ACK number, strettamente legato al precedente.</a>
<ul>
<li><a href="#org3d7b6eb">Identifica il numero di byte che la destinazione di questa connessione ha correttamente ricevuto e qual è l'indice del prossimo byte che mi aspetto.</a></li>
<li><a href="#orgdebbc30">I due campi superiori vengono utilizzati per gestire i casi in cui ci sia una perdita di segmenti e gestire correttamente la trasmissione.</a></li>
</ul>
</li>
<li><a href="#orgdbcec34">Nella terza pagina abbiamo:</a>
<ul>
<li><a href="#org94a366d">Poi c'è il campo TCP Header Length da 4 bit</a>
<ul>
<li><a href="#org71b55f4">La dimensione dell'header è variabile, sebbene esista una lunghezza solitamente usata.</a></li>
</ul>
</li>
<li><a href="#org5a1d2d3">Poi 4 bit non utilizzati</a></li>
<li><a href="#orge6b1499">Poi c'è una serie di 8 bit di controllo</a>
<ul>
<li><a href="#org75dbfe9">Prima il CWR, Congestion Window Reduced, che serve alla rete congestionata per notificare la situazione</a></li>
<li><a href="#org0f2ea42">Poi lo ECE, &#x2026;. echo.</a>
<ul>
<li><a href="#org0aa8a33">Solo i due superiori sono presenti sul Tanenbaum ma non sull'Halsall</a></li>
</ul>
</li>
<li><a href="#org6b38581">Poi c'è un bit URGent, per indicare che certi dati sono urgenti e devono essere processati ASAP, superando l'ordinamento solito.</a></li>
<li><a href="#org3b1b6dc">Poi c'è il campo ACK</a></li>
<li><a href="#org2410174">Poi PUSH, che serve per mandaare via i dati contenuti nel buffer della socket.</a>
<ul>
<li><a href="#org83e8b2a">Ad esempio, immaginiamo che stiamo mandando dei dati e scrivendo nel SendingBuffer.</a></li>
<li><a href="#orgbe23d97">Il TCP riempie un segmento di una certa dimensione e poi lo manda quando ha una certa dimensione.</a></li>
<li><a href="#org21deb82">In alcuni casi, può essere necessario che tutti i dati vengano salvati immediatamente</a></li>
<li><a href="#orga8a7c50">La differenza con lo urgent è che in questo caso il valore viene mandato da solo ma rispettando l'ordine.</a></li>
</ul>
</li>
<li><a href="#orgf027d5c">Poi ci sono RST, SYN e FIN che non ho ascoltato. Reset, sincronizzazione e chiudi connessione.</a></li>
</ul>
</li>
<li><a href="#org4ae4aa4">I restanti 16 bit di Window Size indicano lo spazio ancora disponibile nel ricevitore.</a>
<ul>
<li><a href="#org146da1d">Chi sta trasmettendo, leggendo questo campo può capire se l'altra macchina sostiene il rate o deve rallentare.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org21e6425">Nella quarta pagina:</a>
<ul>
<li><a href="#orgf58c69d">Un checksum a 16 bit, che poi vedremo come viene calcolato, che ci permette di capire se tutto è corretto e viene collegato sulla base dello pseudoheader e tiene anche conto della conformità del payload (controllo degli errori)</a>
<ul>
<li><a href="#org131bb25">Lo pseudoheader è una versione ridotta dello header.</a></li>
</ul>
</li>
<li><a href="#org2cdb64f">Poi uno Urgent Pointer, che viene letto se e solo se il frame urgent è a 1, altrimenti non ce ne frega perchè viene trascurato.</a>
<ul>
<li><a href="#org935e9b7">Indica l'offset all'interno del campo data oltre il quale i dati sono urgent.</a></li>
<li><a href="#orgc84c6d2">Per convenzione, i dati urgent vengono messi alla fine del segmento e quindi non spazio per la fine della parte urgente.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org608b1b3">Dopodichè abbiamo le options, parole di 16 bit di cui può esserci un numero variabile.</a></li>
<li><a href="#orgf134439">Dopo le n options, c'è il payload.</a></li>
</ul>
</li>
<li><a href="#org231cfb4">Come si diceva, TCP è orientato alla connessione.</a>
<ul>
<li><a href="#org5527702">La connessione è bidirezionale, ma noi analizzeremo solo un lato della connessione, perchè analizzare entrambe sarebbe molto confuso.</a>
<ul>
<li><a href="#orgd7a3a1e">Ognuno trasmette e riceve in modo di indipendente. Quindi la sequence e lo ACK sono relativi solo ad una direzione della connessione.</a></li>
</ul>
</li>
<li><a href="#orge93f944">All'apertura della connessione, da entrambe le macchine viene generato un sequence number ISN casuale, per ragioni di sicurezza</a>
<ul>
<li><a href="#orgaf0e093">Altrimenti si potrebbe indovinare un numero ed inserirsi nella connessione</a></li>
<li><a href="#orgb4e13a1">I due flussi, e quindi i due numeri di sequenza, sono indipendenti.</a></li>
</ul>
</li>
<li><a href="#orgcc0fa6d">A chiede di aprire una connessione e manda un segmento con il frame SYN = 1 e il Seq = X (quello generato casualmente da A).</a></li>
<li><a href="#orgd05f642">B riceve il segmento e ne manda uno di risposta in cui SYN = 1, ACK = 1, Seq = Y (quello generato casualmente da B) e Ack = x + 1.</a>
<ul>
<li><a href="#org1667949">Il bit di ACK attivato indica che il valore in Ack è significativo è può essere letto.</a></li>
<li><a href="#org33fe6f3">Lo ack a x+1 indica che si è pronti ad andare avanti con la trasmissione. Il primo segmento parte da x ed è lungo 1, quindi il prossimo che sono pronto ad ascoltare è il successivo.</a></li>
</ul>
</li>
<li><a href="#orga43f893">A riceve il segmento e risponde con ACK=1 e Ack = y+1</a></li>
<li><a href="#orgc871f10">In tutti i 3 segmenti superiori, il valore del resto dello header e payload non importano.</a></li>
<li><a href="#org796aee0">La procedura prende il nome di three-way handshake.</a></li>
<li><a href="#org64accaf">Gestione casi delicati</a>
<ul>
<li><a href="#orge082c68">Viene introdotto un Timer, RTO, che gestisce il caso in cui uno fra i primi due segmenti di handshake vengano persi.</a>
<ul>
<li><a href="#org720b357">Come nel data link, se il timer scade perchè uno qualunque dei primi frame è scomparso, si prova ad aprire nuovamente la connessione.</a></li>
</ul>
</li>
<li><a href="#orga2ee710">Il timer gestisce anche i casi in cui l'handshake di risposta ci impieghi troppo ad arrivare ( o si può dire che dopo il tempo \(T\) si assuma che la connessione è persa e bisogna gestire il caso in cui la risposta invece arrivi)</a>
<ul>
<li><a href="#org585ecc0">Ogni nuova riapertura aggiorna il SEQ casuale</a></li>
<li><a href="#orgb482d36">Se arriva una risposta per un apertura precedente, è facile dal numero di sequenza capire che non sia la risposta corretta</a></li>
<li><a href="#org2659b63">In tal caso, si manda un messaggio con RST e si chiude la connessione.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf9a5e4f">Utilizzando lo stesso concetto di base del port scanning, si può fare SYN FLOOD.</a>
<ul>
<li><a href="#org79f6e8a">Mando tanti messaggi di SYN sulle varie porte.</a></li>
<li><a href="#org3d98af6">Il server mi risponde genuinamente e attende per la mia 3 risposta, finale, di handshake.</a></li>
<li><a href="#orgdcfee01">Io non rispondo e il server deve allocare risorse per tanti syn aperti contemporaneamente.</a></li>
<li><a href="#orge68b5d4">Se invece rispondo con un RST, non effettuo un attacco e non peso sulle risorse, ma analizzo soltanto le porte aperte.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfca29ed">Quindi siamo arrivati al SYN che uno manda per aprire la connessione, con un numero di sequenza generato in numero casuale. Il canale è bidirezionale e quindi avviene tutto nello stesso modo in entrambi gli host.</a>
<ul>
<li><a href="#org2c16f37">Il SYN parte a 1, in risposta il SYN è a uno e anche l'ACK, che indica che il campo Ack è significativo e tale campo è numDiSequenza +1, per indicare che quello è il prossimo bit che si è pronti a ricevere.</a>
<ul>
<li><a href="#org91460ba">Ovviamente manda anche il proprio numero di sequenza.</a></li>
</ul>
</li>
<li><a href="#org50cde1f">Se tutto va a buon fine, la terza risposta dal sender è uguale alla seconda dal receiver e da lì in poi la connessione è aperta.</a></li>
<li><a href="#org331e1bc">C'è un timer che garantisce che se l'ACK viene perso, o impiega troppo tempo ad arrivare, venga mandato un messaggio con RESET a 1 che annulla l'handshake, che va rieffettuato</a></li>
<li><a href="#orgdf5a725">In ogni header è indicato il Max Segment Size, che indica la dimensione massima di segmento che l'host può gestire senza andare in overflow.</a>
<ul>
<li><a href="#org8daff48">La dimensione Standard, quando il campo è vuoto, il segmento è di 536 byte.</a></li>
</ul>
</li>
<li><a href="#org60a393f">L'obiettivo di TCP è trasferire i dati nel miglior modo, garantendo affidabilità, gest.errori, ordine ecc., e anche farlo in modo efficiente, evitando un overhead eccessivo</a></li>
<li><a href="#org75dd47a">Il motivo per cui viene scelta 536 byte è che siamo sicuri che il livello IP non frammenterà tale segmento in più pacchetti.</a>
<ul>
<li><a href="#org19494b3">Per ogni frammentazione effettuata dall'IP, serve copiare sia header TCP che IP, introducendo overhead.</a></li>
<li><a href="#orgc1d2fdb">Inoltre, essendo la rete best-effort, quanti più sotto-segmenti vengono mandati quanto più è probabile che avvengano dei problemi che dovranno essere poi gestiti</a></li>
</ul>
</li>
<li><a href="#org7a93b65">Immaginiamo di avere una connessione A-B in TCP, necessariamente bidirezionale.</a>
<ul>
<li><a href="#orga0aef7c">Dato che noi analizziamo solo i casi "unidirezionali", noi valutiamo solo SendingBuffer e TcpSendingBuffer nel sender, e i corrispondenti ma per il receiver nel receiver.</a></li>
<li><a href="#orgd685284">Assumiamo che la segment size sia 500.</a></li>
<li><a href="#org25298f6">L'applicazione lato sender scrive 2000 byte nell'SB della socket esposto.</a></li>
<li><a href="#org145e1a5">Ovviamente, va eseguita una frammentazione a livello trasporto.</a>
<ul>
<li><a href="#orgef72f07">Assumiamo per ora che non avvengano problemi nella trasmissione.</a></li>
</ul>
</li>
<li><a href="#orgc5fd3b1">Nel sending buffer della TCP, nascosto al livello applicazione, vengono copiati e segmentati opportunamente i byte del buffer superiore.</a></li>
<li><a href="#org142d680">Nello header è presente l'informazione SEQ=X. Il payload sarà dal byte X a quello X + 499</a>
<ul>
<li><a href="#orge8d44f1">X è in realtà X+1 se la connessione è appena stata instaurata, ma per semplicità si considera X il valore corrente.</a></li>
</ul>
</li>
<li><a href="#orgd771a2a">Nel frattempo, il receiver si aspettava il Sequence Number = X e così si accerta che l'ordine sia corretto.</a></li>
<li><a href="#org9cf0370">I dati arrivano nel buffer inferiore, ma dato che l'ordine è corretto, vengono subito copiati nel buffer superiore.</a></li>
<li><a href="#orge26a815">Lo header risposta del receiving buffer contiene il campo ACK a 1 e quello Ack a X + 500, che è il primo byte successivo a quello ricevuto.</a>
<ul>
<li><a href="#org4972a9a">Implicitamente vuol dire che il segmento precedente è correttamente ricevuto.</a></li>
</ul>
</li>
<li><a href="#orgc5bf764">Il sender elimina dal buffer del TCP il segmento corrispondente.</a></li>
<li><a href="#orgf58968e">Allora, il prossimo segmento mandato è quello che parte da X+500 e questo valore è nel SEQ dello header.</a></li>
<li><a href="#orgfb83806">Anche questo pacchetto è in ordine e quindi va subito spostato nel buffer superiore.</a>
<ul>
<li><a href="#org488b6d5">Il TCP tiene tutti i segmenti non in ordine nel buffer inferiore.</a></li>
<li><a href="#orge08dd9d">Ogni segmento correttamente ricevuto, ma successivo ad un segmento non ricevuto, rimane nel buffer inferiore.</a></li>
</ul>
</li>
<li><a href="#org8a39074">Analogamente al messaggio precedente, il receiver risponde con un Ack = X+1000.</a>
<ul>
<li><a href="#orgf9ce911">Anche adesso, il sender si libera del segmento.</a></li>
</ul>
</li>
<li><a href="#orga70d403">Procedo così fino allo svuotamento del buffer di invio.</a></li>
</ul>
</li>
<li><a href="#org47be07b">Nella configurazione precedente, c'è un problema nel caso in cui ho bisogno di (real-time?) ad esempio ssh su una console remota.</a>
<ul>
<li><a href="#org6a66ce7">Voglio che i dati vengano processati byte per byte</a></li>
<li><a href="#org7bbb9b5">Allora uso la flag PUSH, in modo che TCP spedisca il singolo byte, senza arrivare ad una dimensione del segmento di 500 byte come prima</a></li>
<li><a href="#org987a8b5">Quando PUSH viene usata, il receiver manda un regolare ACK, con Ack X+1</a></li>
<li><a href="#org568ceed">In questo caso, però, viene fatta una eco dello stesso byte, questa volta</a></li>
<li><a href="#org3cb54f1">Il motivo per cui viene fatta la eco è che il sender prende input a tastiera ma non mostra direttamente a schermo, perchè non è sicuro che dall'altra parte sia correttamente ricevuto. Solo quando si è sicuri che dall'altra parte sia stato ricevuto, viene stampato a tastiera</a></li>
</ul>
</li>
<li><a href="#orgbb83a8f">Per garantire&#x2026;(?) viene introdotto il delay acknowledgment.</a>
<ul>
<li><a href="#orgfd6240e">La questione è che TCP ignora l'obiettivo delle applicazioni, ma loro lo sanno e potrebbero voler inserire più informazioni nello header.</a></li>
<li><a href="#org59697c6">Immaginiamo una situazione come prima: si riceve un byte pushato.</a></li>
<li><a href="#orgd2349e0">Il receiver, però, non risponde subito con un Ack, ma aspetta un tempo (standard 200ms).</a></li>
<li><a href="#orge04c101">Se in quel tempo arriva qualcosa nel buffer di invio del ricevitore, quei dati vengono incorporati nel messaggio di Ack.</a>
<ul>
<li><a href="#org4e43150">In questo caso, sia sequence che ack number sono considerati. Seq è quello che ti do, ack quello che prendo.</a>
<ul>
<li><a href="#orgb4874d9">Prima invece, il campo sequence non era mai impostato</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4e350bb">In questo caso, quando la eco viene aggiunta nel buffer di invio della ricezione, viene inserita nello stesso frame di Ack. Così ri risparmia un messaggio TCP.</a>
<ul>
<li><a href="#org26498ba">Il prossimo messaggio del sender sarà sia un ACK della echo che un send del byte successivo.</a></li>
</ul>
</li>
<li><a href="#orgc8affb2">Questa soluzione è efficiente dal punto di vista di rete, ma inefficiente dal punto di vista della user-experience.</a>
<ul>
<li><a href="#org1167623">Per trovare un compromesso fra rete e user-experience, si utilizza la tecnica del <b>NAGLE</b>.</a>
<ul>
<li><a href="#org4aea034">Ho un sender con una serie di segmenti composti da un singolo byte da pushare.</a></li>
<li><a href="#orge7af1fb">Come prima, mando un segmento con il byte, il receiver lo riceve e aspetta 200ms.</a>
<ul>
<li><a href="#orga706c56">L'applicazione riceve il byte e fa la ACK + echo, con SEQ = Y, PUSH attivato, ACK attivato e Ack = X + 1</a></li>
</ul>
</li>
<li><a href="#orged6549e">I successivi byte vengono impacchettati in un singolo segmento e mandati tutti insieme. Il receiver risponde con l'ack.</a>
<ul>
<li><a href="#org7ab79cc"><span class="todo TODO">TODO</span> Capire se viene effettuata la echo dei byte in blocco e se viene fatta byte per byte o cumulativa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2a7effa"></a></li>
</ul>
</li>
<li><a href="#org9579bb8">In caso di errori, è lo stesso TCP che se ne accorge e cerca di sanarlo.</a>
<ul>
<li><a href="#orgc66099b">TCP è orientato allo stream.</a>
<ul>
<li><a href="#org18854a4">Abbiamo già visto che a livello 2 ogni pacchetto è identificato da un numero che viene utilizzato per riconoscere i frame su cui avviene l'errore.</a></li>
<li><a href="#org6fcfb70">In TCP l'idea del sequence number è che, conoscendo la dimensione del file \(N\), il segmento va da \(X\) a \(X+N\).</a></li>
<li><a href="#orgcf0a6a7">Ci interessa capire fino a che punto dello stream è stato ricevuto tutto correttamente.</a>
<ul>
<li><a href="#org946b841">Ovvero, l'indice \(K<N\) fino a cui è assicurata la comunicazione avvenuta correttamente.</a></li>
</ul>
</li>
<li><a href="#org487b1f3">Quindi il sequence number sommato al payload, mi da il nuovo numero di sequenza.</a></li>
<li><a href="#orga191249">Immaginiamo di avere una situazione in cui l'app sender debba spedire 2400 byte con una dimensione del segmento di 500.</a></li>
<li><a href="#orgd000467">Il primo segmento viene spedito con SEQ=X.</a></li>
<li><a href="#org25d3a98">Il secondo viene spedito senza aspettare l'ACK, con SEQ=X+500</a></li>
<li><a href="#org6276068">Si immagini adesso che il secondo segmento venga perso.</a></li>
<li><a href="#orgf703eaf">Nel frattempo, il receiver risponde con un ACK per il primo segmento, ovvero con Ack X + 500 e dato che il segmento è nell'ordine corretto, questo viene spedito al buffer superiore.</a></li>
<li><a href="#orgcac1e5b">Quando il secondo segmento è spedito ma non è stato ricevuto l'ack corrispondente, il segmento è ancora nel sending buffer del tcp del sender.</a></li>
<li><a href="#org62501c9">Comunque non aspetto l'ACK del secondo, perchè essendoci la rete per mezzo, non posso sapere se arriverà a breve o non arriverà.</a></li>
<li><a href="#orgee9a478">Quindi mando il terzo, con SEQ=X+1000.</a></li>
<li><a href="#org72c646f">Quando il receiver riceve questo segmento, lo mette nel suo buffer, ma risponde con lo stesso ACK di prima.</a>
<ul>
<li><a href="#org7830648">Ovvero, si intende che sebbene qualcosa sia ricevuto, non "riempie lo spazio" di ciò che non era stato ricevuto.</a></li>
</ul>
</li>
<li><a href="#org474dd1c">La questione è che ogni segmento attiva un timer. Finchè il timer non scade, TCP prosegue con <b>tutti</b> i segmenti successivi in buffer d'invio.</a></li>
<li><a href="#org8d90805">Quando il timer scade, soltanto quello specifico segmento viene inviato.</a></li>
<li><a href="#org038561b">A questo punto, il ricevitore si renderà conto che quel segmento, il secondo in questo caso, va posizionato prima dei successivi, che già possiede nel buffer. Allora tutti quelli successivi saranno sbloccati ed il prossimo ACK li includerà. Si parla quindi di ACK cumulativo.</a></li>
<li><a href="#org0601afb">Questa roba si chiama <b>fast retransmit</b>, ovvero la ritrasmissione di un singolo segmento.</a></li>
<li><a href="#orge177b33">Il timer è pensato per considerare il caso di perdita, anche abbastanza inusuale, sovradimensionato.</a></li>
<li><a href="#orgb041514">Si usa però anche una strategia del triplo ACK: al terzo ACK uguale ricevuto, viene inviato il segmento corrispondente.</a></li>
<li><a href="#org9b9e97d">Usando queste due strategie, si limita il danno sull'efficienza del timeout e si rende più veloce l'invio dei segmenti precedenti.</a>
<ul>
<li><a href="#orgfb44b2a">Ad esempio, si fa in modo che tutti i segmenti in coda nel buffer a cui serve quello perso per sbloccarsi, debbano aspettare al massimo T ma spesso anche di meno, così da ridurre lo spazio di memoria occupato.</a></li>
</ul>
</li>
<li><a href="#orgf68be73">Il timer è anche molto utile per gli ultimi (?)2 segmenti, dopo i quali non esistono 3 ack che facciano partire la ritrasmissione.</a>
<ul>
<li><a href="#org54a5a35"><span class="todo TODO">TODO</span> Per quanti segmenti vale questa proprietà</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb478123">Negle ha un utilità quando vogliamo garantire un utilizzo efficiente della rete.</a>
<ul>
<li><a href="#org141e552">Lo si usa al posto di mandare ogni carattere da solo, con un overhead altissimo dovuto allo header IP e TCP.</a>
<ul>
<li><a href="#org8a268e5">Per mandare un byte, mi servono 4 messaggi.</a></li>
<li><a href="#orgffa0f4b">Si usa il delay per diminuire i messaggi che vengono mandati, ma si paga troppo tempo per l'attesa del delay ogni volta, con piggy bagging in cui nei dati da comunicare si inserisce anche l'ack cumulativo</a></li>
<li><a href="#orga78f66a">Un compromesso e il nagle</a></li>
</ul>
</li>
<li><a href="#orge3a9a0f">Il Nagle viene in supporto quando abbiamo un quantitativo di dati dall'applicazione, ovvero nel SB (superiore) che è minore alla maximum segment size.</a>
<ul>
<li><a href="#org00f9aa1">Nagle innanzitutto guarda il TCP Sending Buffer (quello inferiore). Se è vuoto vuol dire che non sto aspettando nessun ACK.</a>
<ul>
<li><a href="#org9e2ce3c">In questo caso, invio direttamente il contenuto dell'SB, nonostante sia inferiore.</a></li>
</ul>
</li>
<li><a href="#org6c1250f">Se invece ci sono altri segmenti nel buffer inferiore, lo accoda.</a></li>
<li><a href="#orgf7e14b4">Uno dei lati negativi di Nagle è che sebbene utilizzi bene la rete, ovvero limitando l'overhead, (QUAL è L'ASPETTO NEGATIVO)?</a></li>
</ul>
</li>
<li><a href="#org37645da">Un altro aspetto è che tcp è orientato allo stream e ragiona in base ai bit.</a>
<ul>
<li><a href="#orgbaeb0a9">Una sequenza di dati presente nel sending buffer non dev'essere multiplo della max segment size. Il TCP suddivide in blocchetti della dimensione corretta.</a>
<ul>
<li><a href="#org84b554a">Se un ultimo blocchetto non raggiunge la max segment size, sta all'applicazione decidere se mandarlo subito o se aspettare nuovi dati, la cui prima parte verrà aggiunta all'ultimo segmento e mandata tutto insieme.</a></li>
</ul>
</li>
<li><a href="#orgb7ea857">Quindi si parla di segmento numero n come divisione logica, ma tutto è relativo al byte di inizio sequenza.</a></li>
<li><a href="#org4ed0d07">Il principio è che si occupa il meno possibile. L'eventuale padding è fatto ai livelli inferiori.</a></li>
</ul>
</li>
<li><a href="#org6458c34">Quando TCP invia un pacchetto ad IP, quest'ultimo, conoscendo perfettamente la max transfer unit del suo livello 2, frammenta ulteriormente se necessario.</a>
<ul>
<li><a href="#org4778987">IP stesso riassemblerà poi la serie di pacchetti e la fornirà a tcp</a></li>
<li><a href="#orgb15bb68">Se non ci riesce, a TCP non arriverà assolutamente nulla.</a>
<ul>
<li><a href="#org8acbae5">Inoltre, solo il primo pacchetto avrà lo header tcp.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org27f1c29">Come abbiamo già visto, il round trip time è il tempo necessario perchè un segmento venga inviato ed ackAto.</a>
<ul>
<li><a href="#orgb3426aa">Possiamo però anche inviare più segmenti nello stesso momento.</a></li>
<li><a href="#orgdb56aa7">Ogni segmento fa partire un timer, che dev'essere dimensionato correttamente e quindi non può essere statico.</a></li>
<li><a href="#org16fea8c">Esiste uno standard che ci spiega come calcolarlo</a>
<ul>
<li><a href="#orgfcebf8c">Diciamo che il round trip time in media impieghi 30 ms</a></li>
<li><a href="#orgcc4f4f5">La stima viene fatta considerandolo come un outlier della distribuzione.</a>
<ul>
<li><a href="#orga5a8d2b">Tipicamente si dice che un valore di +3sigma, quindi media più 4 deviazioni standard ci da una stima di un caso molto raro di outlier.</a></li>
<li><a href="#org7b33171">Quindi dobbiamo sapere la media e la deviazione standard in base ai dati del round trip time.</a>
<ul>
<li><a href="#orgc871c1e">INSERIRE FORMULA</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4d53229">Il controllo di flusso viene messo in atto quando il produttore produce molto più velocemente del ricevente.</a>
<ul>
<li><a href="#orgfeb543b">Infatti, il buffer di ricezione andrebbe poi in overflow.</a>
<ul>
<li><a href="#org91a8490">Immaginiamo di avere una situazione in cui il sending buffer è di 3000 e il receiving 2000. (mss sempre 500 (ma standard 512)).</a>
<ul>
<li><a href="#org9943032">L'informazione della dimensione dell'altro è nota ad entrambi.</a></li>
<li><a href="#orgd4520ac">Una volta che il sender ha mandato 2000 bit (in 4 tranche perchè la finestra è di 500), il receiving manda non solo un ACK per controllo errori, ma anche un WIN=0, per il controllo di flusso, che indica che lo spazio è finito.</a></li>
<li><a href="#org7e4e468">Quando avrà poi letto 1000 byte, manderà un ACK con lo stesso byte atteso del precedente, ma una window size di 1000.</a></li>
</ul>
</li>
<li><a href="#org2699e04">Il problema è che se il secondo ack di riapertura viene perso, il sender rimarrebbe bloccato per sempre, ovvero si avrebbe un deadlock.</a>
<ul>
<li><a href="#orgdd36fd1">Allo scadere di un Persist Timer nel receiver, viene mandato un segmento speciale vuoto, ovvero senza dati, a cui il receiver risponde con un reinvio dell'ack con nuova finestra.</a>
<ul>
<li><a href="#org3b8d575">Se anche quel nuovo ack è perso, allo scadere di un nuovo timer la connessione sarebbe chiusa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8918144">Il problema della silly window syndrome accade quando il receiver riempie la propria window e continua a notificare la nuova disponibilità ma per una quantità di byte minima.</a>
<ul>
<li><a href="#org00f083a">La soluzione è l'algoritmo di Clark, in cui l'aggiornamento della windows dev'essere almeno grande come la MSS o come la metà del buffer.</a></li>
</ul>
</li>
<li><a href="#orge052efd">La rete ignora completamente il controllo di flusso.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1189b9b"><span class="todo TODO">TODO</span> Riempire con ultime 2 lezioni di livello 4</a></li>
<li><a href="#org59aa199">Iniziamo il livello applicazione parlando del DNS, ovvero il Domain Name System.</a>
<ul>
<li><a href="#org535eda7">E' un sistema che permette di rendere più semplice raggiungere un host</a>
<ul>
<li><a href="#orgefc0859">Normalmente si usa un IP per raggiungere un host, ma è praticamente impossibile ricordare un IP.</a></li>
</ul>
</li>
<li><a href="#org627330b">Funziona associando un nome (dominio) all'ip di uno specifico host.</a>
<ul>
<li><a href="#org7c56b97">Permette anche di recuperare altre informazioni</a></li>
</ul>
</li>
<li><a href="#org4b8dc3a">L'idea è quella di disaccoppiare il modo in cui un essere umano raggiunga un certo servizio.</a>
<ul>
<li><a href="#orgea00ede">Ad esempio il servizio potrebbe cambiare indirizzo ip in modo trasparente agli utenti.</a>
<ul>
<li><a href="#orgb93e868">Questo è utilizzato anche per il load balancing, così che il traffico venga diviso su diversi server.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6547cee">Il fully qualified domain name (FQDN) contiene un punto alla fine che indica il root domain</a></li>
<li><a href="#org9c35d50">Il modo in cui avviene la risoluzione del FQDN fra due macchine, ovvero fra un host che richiede e il server che risponde, è sostituendo ad ogni punto il numero di caratteri che seguono quel punto prima di quello successivo, esempio 2DI5UNIMI2IT0.</a></li>
<li><a href="#org0366a4e">Una query DNS contiene uno header, il FQDN specifico, il tipo di query(A, AAAA, Mx), la classe (che indica la rete su cui si vuole risolvere, che di fatto è sempre internet)</a>
<ul>
<li><a href="#orge1e86ac">Il tipo può essere2 A per IPv4, AAAA per IPv6, MX per posta, CNAME (canonical name) che è un altro nome per lo stesso sito</a></li>
</ul>
</li>
<li><a href="#orga1fb851">La risposta ricopia i dati e inserisce l'indirizzo nell'ultimo campo.</a></li>
<li><a href="#orgdbf43d2">Un record DNS in cache può essere associato ad uno specifico TTL, dopo il quale il record scade e la prossima richiesta effettuata da qualunque client dovrà essere risoluta di nuovo</a>
<ul>
<li><a href="#org51f0932"><span class="todo TODO">TODO</span> Capire funzionamento in caso di record scaduto</a></li>
</ul>
</li>
<li><a href="#org07fdf14">Il resolving DNS avviene con un client che chiede la risoluzione di uno specifico FQDN al resolver all'interno della stessa macchina.</a>
<ul>
<li><a href="#orga3358f6">Il resolver usa UDP perchè non gli serve instaurare la connessione e parla con il Local DNS, che viene impostato in fase di configurazione.</a></li>
</ul>
</li>
<li><a href="#orgdd7a881">A livello globale ci sono dei root DNS servers che contengono soltanto i domini di primo livello, con gli IP corrispondenti dei NameServer.</a>
<ul>
<li><a href="#org2797fcb">Usiamo questi se non sappiamo come raggiungere il dominio di primo livello, che di solito però conosciamo già perchè rimane in cache</a></li>
<li><a href="#org0d1f268">Sul libro sono indicati due approcci, uno iterativo e uno ricorsivo, ma gli esempi sono tutti iterativi.</a>
<ul>
<li><a href="#org0156dfb">L'approccio ricorsivo funziona con il resolver che manda una query al local dns e quest'ultimo risponde con l'indirizzo già pronto.</a>
<ul>
<li><a href="#orgacd3876">Non è implementata nei server per questioni di scalabilità.</a></li>
<li><a href="#org27184f7">Il problema è che sebbene sia molto comoda per il client, il resolver dovrebbe mantenere tantissime informazioni di stato in attesa dei passi successivi.</a></li>
</ul>
</li>
<li><a href="#orge8f6ed2">L'approccio iterativo si applica dal local dns in poi, mentre fra resolver e local dns rimane ricorsivo, ovvero il local dns mantiene lo stato della richiesta fino all'invio della risposta al resolver.</a>
<ul>
<li><a href="#orgf9b5aec">Il client continua a ricevere una risposta valida già pronta.</a></li>
<li><a href="#org4bcf4cd">Il local DNS, però, gestisce in modo iterativo.</a>
<ul>
<li><a href="#org6e92a93">Manda l'intero dominio al root, che conosce però solo l'IP di primo livello e risponde con un informazione parziale, ovvero con l'indirizzo del NS di primo livello.</a></li>
<li><a href="#org3f3b8cd">Una volta conosciuto quello di primo livello, si chiede al corrispondente NameServer di risolvere la parte rimanente del dominio.</a>
<ul>
<li><a href="#orgb662367">Questo risponde con l'indirizzo del DNS Server del secondo livello.</a></li>
</ul>
</li>
<li><a href="#org7c92bc7">Se il dominio era composto da tre livelli, il DNS server di secondo livello risponde con l'IP specifico</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4281987">Anche l'approccio iterativo richidede un overhead per il primo step, che viene attenuato dall'utilizzo della cache.</a>
<ul>
<li><a href="#orgcb19c64">In questo modo, la prossima volta che verrà richiesto un dominio di terzo livello appartenente allo stesso secondo livello, la richiesta verrà effettuata direttamente al Name Server di secondo livello.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc7024da">Ultima lezione</a></li>
</ul>
</div>
</div>
<div id="outline-container-orga9ead05" class="outline-2">
<h2 id="orga9ead05">References</h2>
<div class="outline-text-2" id="text-orga9ead05">
<p>
<a href="https://computer.howstuffworks.com/ethernet.htm">How Ethernet works</a>
<a href="https://intronetworks.cs.luc.edu/1/html/index.html">Exercises from Chicago University</a>
</p>
</div>
</div>
<div id="outline-container-org89bc25b" class="outline-2">
<h2 id="org89bc25b">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orga35ed1f" class="outline-2">
<h2 id="orga35ed1f">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgc9a4cb3" class="outline-2">
<h2 id="orgc9a4cb3">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd32a61e" class="outline-2">
<h2 id="orgd32a61e">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orga34e53c" class="outline-2">
<h2 id="orga34e53c">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd63f4e1" class="outline-2">
<h2 id="orgd63f4e1">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org326c5a1" class="outline-2">
<h2 id="org326c5a1">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-orgce186af" class="outline-2">
<h2 id="orgce186af">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orga2be518" class="outline-2">
<h2 id="orga2be518">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgc6cff4d" class="outline-2">
<h2 id="orgc6cff4d">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org9608393" class="outline-2">
<h2 id="org9608393">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.</h2>
<div class="outline-text-2" id="text-org9608393">
</div>
<div id="outline-container-org930e134" class="outline-3">
<h3 id="org930e134">In una LAN (local a.. network) la rete è broadcast, ovvero c'è un dispositivo che comunica a tutti gli altri, compreso quello da cui ha ricevuto il segnale in entrata. Ovvero un HUB, chiamato anche <b>centro stella passivo</b></h3>
</div>
<div id="outline-container-org785f985" class="outline-3">
<h3 id="org785f985">Un terzo modo, che è come ethernet era fatto inizialmente, si ha una struttura a bus lineare, in cui tutti i dispositivi sono collegati in serie. Sia questa che la seconda sono chiamate <b>broadcast</b>.</h3>
</div>
<div id="outline-container-orgcbe6ec3" class="outline-3">
<h3 id="orgcbe6ec3">Il problema delle strutture broadcast è innanzitutto quello di creare l'equivalente semantico di una comunicazione fra due soli dispositivi, e si fa utilizzando header di mittente e destinatario, così che nel secondo driver di IO capiscono se salvano o buttano via i dati.</h3>
</div>
<div id="outline-container-orgda875f4" class="outline-3">
<h3 id="orgda875f4">Un altro problema è che trasmettere sull'hub o su bus lineare è critico e va quindi garantita la mutua esclusività per l'accesso a canale condiviso: non tutti i dispositivi possono trasmettere nello stesso momento.</h3>
<div class="outline-text-3" id="text-orgda875f4">
</div>
<div id="outline-container-org2adf6fe" class="outline-4">
<h4 id="org2adf6fe">Si può sfruttare un token unico e condiviso dalle stazioni. La struttura è fatta ad anello e chi lo riceve, lo estrae e trasmette. Una volta che la trasmissione torna al primo dispositivo, vuol dire che la comunicazione è arrivata a tutti e cede il token ad un altro.</h4>
<div class="outline-text-4" id="text-org2adf6fe">
</div>
<div id="outline-container-org549df2d" class="outline-5">
<h5 id="org549df2d">Da notare che bisogna fidarsi che il dispositivo ceda il token. Potrebbe non farlo, ed in quel caso nessun altro parlerebbe</h5>
</div>
<div id="outline-container-org1176b56" class="outline-5">
<h5 id="org1176b56">Questa è una soluzione deterministica, perchè in ogni momento so esattamente chi sta parlando.</h5>
</div>
<div id="outline-container-org81ebac9" class="outline-5">
<h5 id="org81ebac9">Questo approccio comporta dei problemi:</h5>
<div class="outline-text-5" id="text-org81ebac9">
<ul class="org-ul">
<li>il token deve fare il giro di tutto l'anello, ma quest'ultimo ha una dimensione variabile, potenzialmente molto grande.</li>
<li>quando una stazione si aggiunge, bisogna inserirla, sincronizzando gli altri nodi per notificarli dell'inserimento. Questo non può che essere fatto da una stazione master, da cui dipende tutto il sistema.</li>
<li>la stazione master serve anche per generare il token e garantire che sia unico</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd8a9f9b" class="outline-4">
<h4 id="orgd8a9f9b">Ethernet utilizza, invece, una soluzione <b>non deterministica</b>, fuzzy, in cui c'entra molto la probabilità ed in cui le collisioni sono ammesse, chiamato CSMA-CD.</h4>
<div class="outline-text-4" id="text-orgd8a9f9b">
</div>
<div id="outline-container-org8c047f2" class="outline-5">
<h5 id="org8c047f2">Un primo modo, chiamato ALOHA, precedente a quello finale, prevede che nel caso in cui ci sia una collisione, entrambi i mittenti non ricevono alcun ACK e ritrasmettono. Se avessero T uguale, ritrasmetterebbero nello stesso momento, generando una nuova collisione. Viene quindi introdotto un ritardo casuale. Questo diminuisce le probabilità di collisione.</h5>
<div class="outline-text-5" id="text-org8c047f2">
</div>
<div id="outline-container-orgde1a58f" class="outline-6">
<h6 id="orgde1a58f">Questa soluzione è vincente rispetto la precedente. Questo è un sistema distribuito, in cui un nuovo dispositivo può inserirsi immediatamente e trasmettere in una nuova rete.</h6>
<div class="outline-text-6" id="text-orgde1a58f">
</div>
<div id="outline-container-orgae59ca7" class="outline-7">
<h7 id="orgae59ca7">La prima volta nella storia in cui un approccio probabilistico vince con uno deterministico.</h7>
</div>
</div>
<div id="outline-container-org111db75" class="outline-6">
<h6 id="org111db75">Questa soluzione ha un'efficienza minima, intorno al 18%.</h6>
</div>
</div>
<div id="outline-container-org9754491" class="outline-5">
<h5 id="org9754491">L'innovazione adottata per il protocollo di Ethernet è l'operazione di ascolto, chiamata CS, ovvero Carrier Sense. Vedo se il canale è libero e solo in quel caso immette il proprio pacchetto.</h5>
<div class="outline-text-5" id="text-org9754491">
</div>
<div id="outline-container-orge1a1ac0" class="outline-6">
<h6 id="orge1a1ac0">Il rischio di collisione avviene nel caso in cui due stazioni facciano Carrier Sense nello stesso momento. Scopriranno che il Carrier si è liberato nello stesso momento e immetteranno i pacchetti.</h6>
<div class="outline-text-6" id="text-orge1a1ac0">
</div>
<div id="outline-container-orgd136b5d" class="outline-7">
<h7 id="orgd136b5d">Una soluzione per ridurre la probabilità di collisioni di questo tipo, potrebbe essere quella di introdurre un ritardo dal momento in cui viene notata la fine del pacchetto attraverso il Carrier Sense. Dato che la probabilità di questo tipo di collisione è considerata bassa in Ethernet, non viene introdotto un ulteriore ritardo. Si scommette che non avvenga di frequenza.</h7>
<div class="outline-text-7" id="text-orgd136b5d">
</div>
<div id="outline-container-org9c405f2" class="outline-8">
<h8 id="org9c405f2">Applicare il ritardo comporterebbe un protocollo Non-Persistent, ovvero le stazioni non sono competitive.</h8>
</div>
<div id="outline-container-orgf440642" class="outline-8">
<h8 id="orgf440642">La nostra scelta è 1Persistent, ovvero i pacchetti trasmettono con probabilità 1.</h8>
</div>
</div>
</div>
<div id="outline-container-orgef822ba" class="outline-6">
<h6 id="orgef822ba">La collisione viene gestita, però, in modo molto più rapido: se una stazione riceve qualcosa di diverso da quello che sta immettendo, c'è una collisione e blocca istantaneamente la trasmissione. Solo a quel punto inizia il timer random</h6>
<div class="outline-text-6" id="text-orgef822ba">
</div>
<div id="outline-container-orgbafd950" class="outline-7">
<h7 id="orgbafd950">BEB (binary exponential backoff) è un modo per calcolare il tempo di ritardo dopo una collisione</h7>
<div class="outline-text-7" id="text-orgbafd950">
</div>
<div id="outline-container-org345ba3c" class="outline-8">
<h8 id="org345ba3c">Ad ogni i-esima collisione, genero un ritardo randomicamente scelto fra 0 e 2<sup>i</sup>-1 * unità di tempo</h8>
<div class="outline-text-8" id="text-org345ba3c">
</div>
<div id="outline-container-org848887e" class="outline-9">
<h9 id="org848887e">Quindi la prima volta il ritardo può essere di 0 o 1 unità, la seconda 0,1,2,3, la terza tra 0 d e 7 è così via</h9>
</div>
<div id="outline-container-orgff46211" class="outline-9">
<h9 id="orgff46211">Il prof dice che 2<sup>i</sup>-1 è l'estremo dell'intervallo e non il numero di scelte.</h9>
</div>
</div>
<div id="outline-container-orgabd0d0f" class="outline-8">
<h8 id="orgabd0d0f"><span class="todo TODO">TODO</span> controllare cos'è</h8>
</div>
<div id="outline-container-org678c7b8" class="outline-8">
<h8 id="org678c7b8">L'unità di tempo viene dallo standard IEEE 802.3 che specifica il CSMA-CD 1Persistente.</h8>
<div class="outline-text-8" id="text-org678c7b8">
</div>
<div id="outline-container-org72909fa" class="outline-9">
<h9 id="org72909fa">Abbiamo un cavo di 2500 mt, diviso in 5 sezioni di 500mt da 4 repeater. Lunghezza per indice del rame, mi da un tempo di 12.5 microsecondi.</h9>
</div>
<div id="outline-container-org4ef8fde" class="outline-9">
<h9 id="org4ef8fde">Devo garantire che questo tempo, ovvero 2tp = 25 microsecondi, non pesi troppo rispetto al tx.</h9>
</div>
<div id="outline-container-org161fb57" class="outline-9">
<h9 id="org161fb57">Immaginiamo ci siano A e B, B alla fine del cavo di cui prima. Prima di 25microsecondi, se B facesse Carrier Sense, troverebbe la rete libera e colliderebbe. Lo stesso vale perchè A riconosca la presenza di bit corrotti e quindi la collisione.</h9>
</div>
<div id="outline-container-org2d77a32" class="outline-9">
<h9 id="org2d77a32">In una rete di questo tipo, per garantire la collision detection, è necessario che il primo trasmettitore trasmetta per un tempo almeno maggiore di 2tp, ovvero il tempo che la trasmissione arrivi a tutti gli altri, e la trasmissione di tutti gli altri ritorni.</h9>
</div>
<div id="outline-container-org0cc4c11" class="outline-9">
<h9 id="org0cc4c11">Si è quindi deciso di settare il parametro 2tp in 51,2 ms, che è il tempo richiesto ad ogni stazione per continuare a trasmettere, in modo da rilevare la collisione, questo diventa il tempo minimo di trasmissione in rete.</h9>
<div class="outline-text-9" id="text-org0cc4c11">
</div>
<div id="outline-container-orgd8412c7" class="outline-10">
<h10 id="orgd8412c7">Se la rete lavora con un clock a 10Mbit, in 51.2microsecondi trasmetto 512 bit, ovvero 64byte</h10>
</div>
<div id="outline-container-org1971e86" class="outline-10">
<h10 id="org1971e86">Questo parametro di 51,2 è l'unita di tempo fondamentale, che viene applicata anche per il BEB.</h10>
</div>
</div>
<div id="outline-container-org70910cf" class="outline-9">
<h9 id="org70910cf">Lo IEEE 802.11 è lo standard WiFi.</h9>
</div>
</div>
</div>
</div>
<div id="outline-container-org8a6ee56" class="outline-6">
<h6 id="org8a6ee56">Nel MAC, che è un layer di livello 2, multiple access control, che sarebbe lo stesso standard IEEE802.3, viene definito anche il formato del pacchetto, in cui si usa un header e un padding, che serve per raggiungere la dimensione minima.</h6>
</div>
<div id="outline-container-org5cbc8e5" class="outline-6">
<h6 id="org5cbc8e5">Il nome è Carrier Sense, Multiple Access, Collision Detection.</h6>
</div>
<div id="outline-container-org995fa15" class="outline-6">
<h6 id="org995fa15">La curva d'efficienza la ottiene nello sweet spot di stazioni ed è intorno al 95%.</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga7bb851" class="outline-2">
<h2 id="orga7bb851">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0</h2>
<div class="outline-text-2" id="text-orga7bb851">
</div>
<div id="outline-container-org276e162" class="outline-3">
<h3 id="org276e162">Con ethernet, però, abbiamo vari problemi. Uno è quello di disambiguare sequenze di bit uguali, un'altra è quella di far arrivare il valore in modo chiaro al ricevitore.</h3>
<div class="outline-text-3" id="text-org276e162">
</div>
<div id="outline-container-orgc96d620" class="outline-4">
<h4 id="orgc96d620">Ethernet utilizza quindi la codifica Manchester, che a differenza del solito, legge nel momento centrale del bit, che è il punto meno soggetto a distorsione.</h4>
<div class="outline-text-4" id="text-orgc96d620">
</div>
<div id="outline-container-org2229e52" class="outline-5">
<h5 id="org2229e52">Ciò che viene letto, però, non è il valore assoluto ma la transizione. Se vede che c'è una transizione verso l'alto, abbiamo un uno, altrimenti zero.</h5>
<div class="outline-text-5" id="text-org2229e52">
</div>
<div id="outline-container-org6f3389f" class="outline-6">
<h6 id="org6f3389f">Questo comporta che in caso di valori uguali consecutivi, bisogna cambiare la tensione appena si capisce che il prossimo bit è uguale, e poi nel momento centrale (quello letto), effettuare la transizione.</h6>
</div>
<div id="outline-container-org31d1d5b" class="outline-6">
<h6 id="org31d1d5b">Questo comporta anche che la trasmissione sia shiftata di mezzo ciclo di clock.</h6>
</div>
</div>
<div id="outline-container-org11a2666" class="outline-5">
<h5 id="org11a2666">Essendo un sistema a stato IDLE pre-trasmissione, prima che questa inizi, il ricevitore non conosce il clock di trasmissione, perchè i bit in entrata sono tutti uguali.</h5>
<div class="outline-text-5" id="text-org11a2666">
</div>
<div id="outline-container-org8e6cd71" class="outline-6">
<h6 id="org8e6cd71">La sfida è quella di tenere il clock del ricevitore sincronizzato, magari non fornendgli un clock indipendente, ma incorporando univocamente questa informazione nei dati</h6>
<div class="outline-text-6" id="text-org8e6cd71">
</div>
<div id="outline-container-org458fb1a" class="outline-7">
<h7 id="org458fb1a">Un primo problema è che il ricevitore non può a priori sapere se una transizione allo scattare del clock (quindi quella di preparazione), non sia una transizione valida "trasmittiva", ovvero quella mid-clock</h7>
</div>
</div>
<div id="outline-container-org86a7e82" class="outline-6">
<h6 id="org86a7e82">Introduciamo un preambolo, formato da 7 byte in cui i bit 0 e 1 si alternano, ed un ottavo byte così costituito [1010101011], che il ricevitore riceve per sincronizzarsi. Gli ultimi due uno, o in particolare l'ultimo, che prevede una doppia transizione, segnala l'inizio del vero frame.</h6>
</div>
</div>
<div id="outline-container-org0fe35bc" class="outline-5">
<h5 id="org0fe35bc">(non serve guardare la codifica Manchester differenziale)</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org26ebac9" class="outline-2">
<h2 id="org26ebac9">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)</h2>
<div class="outline-text-2" id="text-org26ebac9">
</div>
<div id="outline-container-org2b675d1" class="outline-3">
<h3 id="org2b675d1">Si dimostra che al tendere delle stazioni K all'infinito, 1/A tende a "e".</h3>
</div>
<div id="outline-container-orgbc99553" class="outline-3">
<h3 id="orgbc99553">Inoltre, si ricorda che abbiamo definito tx come dimFrame/velBanda e tp come Lunghezza/velCavo.</h3>
<div class="outline-text-3" id="text-orgbc99553">
</div>
<div id="outline-container-orgdcf2c9f" class="outline-4">
<h4 id="orgdcf2c9f">Allora divido tutto per tx e ottengo \(\frac{1}{1+2 \frac{BL}{CF}e }\). Quindi, all'aumentare della banda e della lunghezza, l'utilizzo diminuisce di tanto.</h4>
<div class="outline-text-4" id="text-orgdcf2c9f">
</div>
<div id="outline-container-orgce01ac8" class="outline-5">
<h5 id="orgce01ac8">Sembra inutile aumentare la banda, perchè diminuirebbe l'utilizzo.</h5>
</div>
<div id="outline-container-org4fb69d5" class="outline-5">
<h5 id="org4fb69d5">Diventa quindi necessario gestire il problema dell'aumento banda</h5>
<div class="outline-text-5" id="text-org4fb69d5">
</div>
<div id="outline-container-org3fdf0a8" class="outline-6">
<h6 id="org3fdf0a8">Ricordiamo che nelle reti moderne, la struttura è a centro stella passivo, con un hub a cui fanno riferimento vari dispositivi, in una struttura complessa ad albero, in cui i vari hub sono collegati fra loro.</h6>
<div class="outline-text-6" id="text-org3fdf0a8">
</div>
<div id="outline-container-org55d7b83" class="outline-7">
<h7 id="org55d7b83">Questa struttura causa problemi quando il numero di dispositivi diventa eccessivo</h7>
</div>
<div id="outline-container-orgfbe7126" class="outline-7">
<h7 id="orgfbe7126">Misurando il tasso di collisione di ritrasmissione, ci si rende conto che la rete è overcrowded</h7>
</div>
<div id="outline-container-org19dfe8d" class="outline-7">
<h7 id="org19dfe8d">Per ovviare al problema, si fa uso dei <b>bridge</b>.</h7>
<div class="outline-text-7" id="text-org19dfe8d">
</div>
<div id="outline-container-orgfb0721e" class="outline-8">
<h8 id="orgfb0721e">Immaginiamo di avere una rete locale composta da 6 stazioni, 3 per hub, su 2 hub collegati.</h8>
<div class="outline-text-8" id="text-orgfb0721e">
</div>
<div id="outline-container-orgf4df8e8" class="outline-9">
<h9 id="orgf4df8e8">Gli hub sono passivi e ogni stazione può trasmettere agli altri, e può anche collidere con essi.</h9>
<div class="outline-text-9" id="text-orgf4df8e8">
</div>
<div id="outline-container-org0b0b376" class="outline-10">
<h10 id="org0b0b376">Hub collegati comportano che tutte le stazioni facciano parte dello stesso dominio di collisione, ovvero lo spazio di rete in cui le stazioni competono per l'accesso al canale condiviso di trasmissione</h10>
</div>
</div>
</div>
<div id="outline-container-org126b4a2" class="outline-8">
<h8 id="org126b4a2">Il bridge non è totalmente passivo, ovvero che opera a livello soltanto fisico, ma un apparato intelligente che possiede un buffer e trasmette se utile e necessario secondo certi criteri.</h8>
<div class="outline-text-8" id="text-org126b4a2">
</div>
<div id="outline-container-org1e7a226" class="outline-9">
<h9 id="org1e7a226">Se il bridge riceve una trasmissione da parte di una stazione, verso la stazione nello stesso dominio, la scarta, perchè sa che è già arrivata a destinazione</h9>
</div>
<div id="outline-container-org0c5e33b" class="outline-9">
<h9 id="org0c5e33b">Se invece riceve una trasmissione verso un altro dominio a esso collegato, la inoltra verso il nuovo dominio.</h9>
</div>
<div id="outline-container-orgddb14e5" class="outline-9">
<h9 id="orgddb14e5">Queste operazioni prendono il nome di Store-and-Forward.</h9>
</div>
<div id="outline-container-orgfed2f6e" class="outline-9">
<h9 id="orgfed2f6e">Un bridge è fatto da tante schede Ethernet (Livelli MAC) quante sono le LAN a esso collegate, con corrispondenti MAC Address per entrambe.</h9>
<div class="outline-text-9" id="text-orgfed2f6e">
</div>
<div id="outline-container-org346da98" class="outline-10">
<h10 id="org346da98">Quindi si comporta esattamente come una stazione</h10>
</div>
</div>
<div id="outline-container-org574d549" class="outline-9">
<h9 id="org574d549">Chiaramente, deve contenere anche una tabella con le stazioni e la corrispondente porta attraverso cui è collegato con esse.</h9>
<div class="outline-text-9" id="text-org574d549">
</div>
<div id="outline-container-org16ee378" class="outline-10">
<h10 id="org16ee378">Per riempire la tabella, si fa in modo che il bridge impari poco alla volta dove si trovano le stazioni. Quando riceve un frame da una porta, salva la stazione nella tabella</h10>
</div>
<div id="outline-container-orgc784a03" class="outline-10">
<h10 id="orgc784a03">Se una frame è destinata ad una stazione a cui non è collegata una porta, si fa broadcast.</h10>
<div class="outline-text-10" id="text-orgc784a03">
</div>
<div id="outline-container-orgcaba892" class="outline-11">
<h11 id="orgcaba892">DOMANDA: Quindi ogni volta che trasmetto verso una porta non registrata, occupo tutti i domini di collisione? Se ho un bridge con tante porte, dovrò occuparle tutte, per raggiungerne una sola. E se la porta di destinazione non spedisse mai?</h11>
</div>
</div>
</div>
</div>
<div id="outline-container-org424d808" class="outline-8">
<h8 id="org424d808">Il bridge è il primo strumento di CSMA-CD che opera a <b>livello 2</b></h8>
</div>
</div>
<div id="outline-container-org0e124dc" class="outline-7">
<h7 id="org0e124dc">Un altro dispositivo è lo <b>switch</b>.</h7>
<div class="outline-text-7" id="text-org0e124dc">
</div>
<div id="outline-container-org2d72976" class="outline-8">
<h8 id="org2d72976">E' simile all'hub, ma siamo a livello 2 e contiene una tabella di store e forward.</h8>
</div>
<div id="outline-container-orgb3e4343" class="outline-8">
<h8 id="orgb3e4343">La differenza con il bridge è che le connessioni fra le stazioni e lo switch sono punto-punto, e quindi il CSMA-CD non è necessario. Lo switch smista le comunicazioni in modo intelligente.</h8>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org2a594fb" class="outline-2">
<h2 id="org2a594fb">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.</h2>
<div class="outline-text-2" id="text-org2a594fb">
</div>
<div id="outline-container-org322de27" class="outline-3">
<h3 id="org322de27">Una soluzione immediata sarebbe quella di usare 4 fili e dividere un bit in ognuno. In realtà, se ne usano solo 3 per la trasmissione, perchè il 2 è quello usato per CarrierSense e CollisionDetection.</h3>
</div>
<div id="outline-container-org2ca3f78" class="outline-3">
<h3 id="org2ca3f78">Come si raggiungono 1000Mbit, con solo 3 fili da 25Mbps? Si usa una codifica diversa, ternaria non binaria, chiamata 8B6T, ovvero "mappo 8 bit Binari su 6 Ternari".</h3>
<div class="outline-text-3" id="text-org2ca3f78">
</div>
<div id="outline-container-orge089f5a" class="outline-4">
<h4 id="orge089f5a">A questo punto abbiamo 100 * 10<sup>6</sup> Mbit *6/8 diviso i 3 fili, ottengo 25 bit ternari per filo, che corrispondono a 33 binari.</h4>
</div>
</div>
</div>
<div id="outline-container-org455acb6" class="outline-2">
<h2 id="org455acb6">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.</h2>
<div class="outline-text-2" id="text-org455acb6">
</div>
<div id="outline-container-org0ffab8c" class="outline-3">
<h3 id="org0ffab8c">flading, broadcast ma senza restituire alla porta da cui è arrivato.</h3>
</div>
<div id="outline-container-orgf40a4e2" class="outline-3">
<h3 id="orgf40a4e2">Un problema è che se un dispositivo, con un certo MAC address, si sposta da un dominio all'altro, la tabella non è più valida. Ogni entrata deve quindi avere un timer, Il flading è quindi parte integrante dell'apparato</h3>
</div>
</div>
<div id="outline-container-org3085c92" class="outline-2">
<h2 id="org3085c92">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.</h2>
</div>
<div id="outline-container-org889b0c2" class="outline-2">
<h2 id="org889b0c2">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.</h2>
<div class="outline-text-2" id="text-org889b0c2">
</div>
<div id="outline-container-org838601c" class="outline-3">
<h3 id="org838601c">E' stato deciso, in sede di standard, ogni tratta deve essere grande al massimo 200 metri, quindi 800 metri in tutto al massimo ( per andare sulle 2 tratte e tornare sulle stesse).</h3>
<div class="outline-text-3" id="text-org838601c">
</div>
<div id="outline-container-orgacbed02" class="outline-4">
<h4 id="orgacbed02">Su 800 metri, il tempo andata e ritorno è circa 4ms. Con 1Gbit, esce fuori 4000bit, ovvero 500bit, arrotondati a 512B.</h4>
</div>
<div id="outline-container-org40662ea" class="outline-4">
<h4 id="org40662ea">Se si fosse lasciato il tempo di 51.2 microsecondi, avremmo dovuto mandare 51200 bit per ogni minimo frame e sarebbe stato poco efficiente. Viene quindi ridotto il diametro, e anche la dimensione dei frame.</h4>
</div>
<div id="outline-container-orgce9bac8" class="outline-4">
<h4 id="orgce9bac8">Per evitare di cambiare anche la porta MAC, che fa il padding di solo 64Byte, il padding viene fatto a livello fisico.</h4>
<div class="outline-text-4" id="text-orgce9bac8">
</div>
<div id="outline-container-orgaf53c00" class="outline-5">
<h5 id="orgaf53c00">In ogni caso, il padding è eccessivo ed è il motivo per cui spopolano gli switch e il Gbit ethernet non ha fatto presa.</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org078c52e" class="outline-2">
<h2 id="org078c52e">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.</h2>
<div class="outline-text-2" id="text-org078c52e">
</div>
<div id="outline-container-org49105d6" class="outline-3">
<h3 id="org49105d6">C'è, però, anche un'interfaccia aggiuntiva, posizionata appena sopra il MAC, ma sempre a livello 2, chiamata <b>Logical Link Control</b>.</h3>
</div>
<div id="outline-container-org2ff1b73" class="outline-3">
<h3 id="org2ff1b73">Quello che facciamo con questo sottolivello serve a creare dei canali logici punto-punto fra sè e le altre stazioni.</h3>
<div class="outline-text-3" id="text-org2ff1b73">
</div>
<div id="outline-container-orgc6127cf" class="outline-4">
<h4 id="orgc6127cf">Quindi, a livello MAC gestisco la situazione Broadcast, e nel Logical Link Control, creo una sovrastruttura logica che modella i collegamenti come punto-punto. In questo modo, dal Logical Link Control in sù, ignoro qualunque ragionamento riguardo il MAC e le sue operazioni.</h4>
<div class="outline-text-4" id="text-orgc6127cf">
</div>
<div id="outline-container-org010fad7" class="outline-5">
<h5 id="org010fad7">Questi collegamenti logici, possono essere sia best-effort che affidabili, esattamente come fossimo su una rete magliata.</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-orgafdaba2" class="outline-2">
<h2 id="orgafdaba2">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.</h2>
<div class="outline-text-2" id="text-orgafdaba2">
</div>
<div id="outline-container-org568e3ef" class="outline-3">
<h3 id="org568e3ef">Stazioni che fanno parte di VLAN diverse, non possono comunicare fra loro, anche se fanno parte dello stesso hub. Serve uno switching intelligente per attivare questa funzione, perchè di base le comunicazioni sullo stesso hub girano liberamente</h3>
</div>
<div id="outline-container-org533205e" class="outline-3">
<h3 id="org533205e">Per permettere a macchine appartenenti a VLAN diversi, è necessario utilizzare il routing di livello 3, perchè la separazione introdotta, sebbene logica, è finale.</h3>
<div class="outline-text-3" id="text-org533205e">
</div>
<div id="outline-container-org063ecdf" class="outline-4">
<h4 id="org063ecdf">Gli switch avanzati posseggono una funzione di routing incorporata</h4>
</div>
</div>
<div id="outline-container-org0d8ef5c" class="outline-3">
<h3 id="org0d8ef5c">Le informazioni riguardo le VLAN sono contenute nello switch, che <b>tagga</b> le porte e le frame a esse corrispondenti</h3>
<div class="outline-text-3" id="text-org0d8ef5c">
</div>
<div id="outline-container-org456f7c5" class="outline-4">
<h4 id="org456f7c5">Quindi, le stazioni mandano i soliti frame 802.3, e lo switch si occupa di taggarli e smistarli secondo un nuovo standard, chiamato 802.1Q</h4>
<div class="outline-text-4" id="text-org456f7c5">
</div>
<div id="outline-container-org065a49c" class="outline-5">
<h5 id="org065a49c">Entrambi i formati, posseggono il DestinationAddress come primo campo. L'1Q, rimpiazza il campo della lunghezza con quello del protocol ID. Quindi, in quel campo, posso aspettarmi sia una lunghezza che l'ID, ed il secondo viene distinto dal fatto che contiene 8100H in hex, ovvero u numero maggiore di 1500 che è la lunghezza massima.</h5>
</div>
<div id="outline-container-orge36458a" class="outline-5">
<h5 id="orge36458a">Nei due byte successivi, si trovano info legate alle VLAN e, in particolare, 12 bit di VLAN identifier.</h5>
</div>
<div id="outline-container-org2106870" class="outline-5">
<h5 id="org2106870">Il cavo fra switch, su cui circolano soltanto frame <b>tagged</b>, si chiama <b>trunk</b></h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org9da70b4" class="outline-2">
<h2 id="org9da70b4">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.</h2>
<div class="outline-text-2" id="text-org9da70b4">
</div>
<div id="outline-container-org9220af4" class="outline-3">
<h3 id="org9220af4">Convergence sublayer e Physical-medium dependent layer per il physical layer, il cui primo serve per separare ulteriormente il livello fisico finale, che è fortemente dipendente dall'architettura</h3>
</div>
<div id="outline-container-orgb61ba7d" class="outline-3">
<h3 id="orgb61ba7d">LLC(Logical Link Control) e MAC(Multiple Access Control), il cui primo si occupa di rendere trasparente la gestione complicata del CSMA-CD da parte del MAC, gestendo apparentemente le connessioni come punto-punto.</h3>
</div>
</div>
<div id="outline-container-org3a35279" class="outline-2">
<h2 id="org3a35279">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.</h2>
<div class="outline-text-2" id="text-org3a35279">
</div>
<div id="outline-container-org0ebdf8e" class="outline-3">
<h3 id="org0ebdf8e">Chiaramente, il MAC address smette di avere valore, su questa scala, e viene introdotto l'IP, che identifica univocamente qualunque stazione appartenente a qualunque LAN.</h3>
</div>
<div id="outline-container-org5182586" class="outline-3">
<h3 id="org5182586">Nell'andare da una stazione ad un altra, quindi da un livello Application all'altro, attraversiamo un numero indefinito di macchine che operano al massimo a livello 3. Ognuna di esse deve occuparsi dell'Addressing, ovvero come gestire l'univocità dell'IP, ed il routing, ovvero come trovare una strada fra le stazioni in modo efficiente.</h3>
</div>
<div id="outline-container-org046ca30" class="outline-3">
<h3 id="org046ca30">Nel livello 3 non c'è solo un entità, ma 5, di cui analizzeremo due e IP in particolare, con il suo sottomodulo OSPF, per il routing. L'altro è ARP, con cui si mappa/risolve l'IP globale nel MAC.</h3>
</div>
</div>
<div id="outline-container-org2526aab" class="outline-2">
<h2 id="org2526aab">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.</h2>
<div class="outline-text-2" id="text-org2526aab">
</div>
<div id="outline-container-org6f9973f" class="outline-3">
<h3 id="org6f9973f">Il formato di un pacchetto IP è formato da 5 parole (ovvero 4 byte, 32 bit) ed un ultimo spazio opzionale, utilizzato ad esempio per il source routing.</h3>
<div class="outline-text-3" id="text-org6f9973f">
</div>
<div id="outline-container-orge4fcf43" class="outline-4">
<h4 id="orge4fcf43">Il primo campo è quello versione, che occupa i primi 4 bit e indica la versione del protocollo, di cui ne esistono due, la v4 e la v6.</h4>
</div>
<div id="outline-container-orge6da679" class="outline-4">
<h4 id="orge6da679">Dopodichè c'è la header length, che occupa altri 4 bit e specifica quanti byte è lungo l'header. Serve nel caso in cui il campo option venga utilizzato, perchè ha lunghezza variabile.</h4>
</div>
<div id="outline-container-org7a25431" class="outline-4">
<h4 id="org7a25431">Gli 8 bit successivi sono occupati dal Type Of Service (TOS),</h4>
<div class="outline-text-4" id="text-org7a25431">
</div>
<div id="outline-container-orgaaedf0c" class="outline-5">
<h5 id="orgaaedf0c">E' importantissimo soprattutto oggi, dato che viaggia traffico di tipo diverso (best-effort, audio, video, real time) ed ognuno richiede un servizio diverso.</h5>
<div class="outline-text-5" id="text-orgaaedf0c">
</div>
<div id="outline-container-org6717277" class="outline-6">
<h6 id="org6717277">Se arriva un flusso di contenuti real-time, in cui il gitter è importante, questo verrà processato per primo. Lo scheduler sceglie la coda d'uscita in cui imbucare in base a questo parametro, e chi lo decide è il livello superiore.</h6>
</div>
</div>
</div>
<div id="outline-container-orgb9e6b9c" class="outline-4">
<h4 id="orgb9e6b9c">I successivi 16 bit che completano la parola riguardano la Total Length, che quindi può arrivare a \(2^{16}\).</h4>
</div>
<div id="outline-container-orgc668eb5" class="outline-4">
<h4 id="orgc668eb5">Nella prossima parola, si inizia con 16 bit per l'ID, seguito da 3 bit, di cui il primo vuoto per futuro uso e due bit chiamati D (Do not fragment) e M (More fragment)</h4>
</div>
<div id="outline-container-org1473868" class="outline-4">
<h4 id="org1473868">Poi ci sono i restanti 13 bit della parola, che si chiama Fragment Offset</h4>
<div class="outline-text-4" id="text-org1473868">
</div>
<div id="outline-container-org221e879" class="outline-5">
<h5 id="org221e879">Gestisce la frammentazione all'interno del livello 3. Un'unità dati utente non può passare sulla rete nella sua interezza e va frammentata per essere trasmessa. Di solito questa è una funzionalità di livello 4. Questo è un altro tipo di frammentazione.</h5>
<div class="outline-text-5" id="text-org221e879">
</div>
<div id="outline-container-org3e60b51" class="outline-6">
<h6 id="org3e60b51">Un dato viene prodotto a livello 7 e frammentato in <b>segmenti</b> dal livello 4, che vengono poi singolarmente mandati al livello 3 attraverso il relativo servizio, che lo manda alla rete, che non è un concetto astratto ma una rete di qualche tipo, ad esempio Ethernet, la cui grandezza massima è 512 o ~1500 byte. Quindi il livello 3 deve frammentare a sua volta, che comunica direttamente con il livello 2 per capire la lunghezza massima e predispone sequenze da essa dipendenti.</h6>
</div>
</div>
</div>
<div id="outline-container-org07266a5" class="outline-4">
<h4 id="org07266a5">Nella terza parola, i primi 8 bit sono un timestamp, TTL (Time to live).</h4>
<div class="outline-text-4" id="text-org07266a5">
</div>
<div id="outline-container-org7677b6a" class="outline-5">
<h5 id="org7677b6a">Ogni pacchetto parte dalla sorgente, che decide quanto tempo può vivere il pacchetto in rete e se arriva alla destinazione con un valore nullo, verrà discardato. Sebbene si parli di Time, di fatto la misura è l'Hop, ovvero quanti step effettua. Se ne effettua troppi, potrebbe essersi trovato in un lungo loop.</h5>
</div>
</div>
<div id="outline-container-orgcbfd7d3" class="outline-4">
<h4 id="orgcbfd7d3">Il secondo campo di 8 bit si chiama Protocol selector.</h4>
<div class="outline-text-4" id="text-orgcbfd7d3">
</div>
<div id="outline-container-org3c9f9a9" class="outline-5">
<h5 id="org3c9f9a9">A livello 4 esistono diversi protocolli, ad esempio TCP ed UDP. Il pacchetto destinazione deve avere un modo per capire quale protocollo la sorgente abbia utilizzato per inviare il pacchetto.</h5>
</div>
</div>
<div id="outline-container-orgcf4a1a4" class="outline-4">
<h4 id="orgcf4a1a4">I restanti 16 sono di Header Checksum</h4>
<div class="outline-text-4" id="text-orgcf4a1a4">
</div>
<div id="outline-container-orga2eef85" class="outline-5">
<h5 id="orga2eef85">Internet è, per definizione, una rete best-effort. Non c'è nessun tipo di affidabilità implementata prima del livello 4. Sull'header, però, si utilizza una checksum in modo da controllare, limitatamente all'header, la validità, in modo da scartare i pacchetti non validi.</h5>
</div>
</div>
<div id="outline-container-orgad03c4a" class="outline-4">
<h4 id="orgad03c4a">Nella quarta e quinta parola troviamo rispettivamente il Source e il Destination address, che quindi sono di 32 bit ognuno.</h4>
</div>
</div>
<div id="outline-container-org3379a66" class="outline-3">
<h3 id="org3379a66">Immaginiamo di avere due stazioni che comunicano, passando attraverso vari gateway, che collegano stazioni attraverso tecnologie diverse.</h3>
<div class="outline-text-3" id="text-org3379a66">
</div>
<div id="outline-container-org8522137" class="outline-4">
<h4 id="org8522137">Ad esempio, immaginiamo che la source esca con un ring, con un limite di 4000 byte per frame, passi per due gateway, di cui il secondo è collegato ethernet, con un limite di 1500 byte per frame alla stazione di arrivo.</h4>
<div class="outline-text-4" id="text-org8522137">
</div>
<div id="outline-container-org04ac34a" class="outline-5">
<h5 id="org04ac34a">In questo caso, devo splittare il pacchetto in un certo modo all'uscita, sfruttando i campi che abbiamo visto prima, ovvero l'ID del pacchetto e il fragment offset (che è un array a scorrimento con info riguardo la posizione del pacchetto mandato).</h5>
</div>
<div id="outline-container-org6e57d70" class="outline-5">
<h5 id="org6e57d70">Innanzitutto, non posso utilizzare tutti i 4000, perchè 20 servono per l'header.</h5>
</div>
<div id="outline-container-org30d4d91" class="outline-5">
<h5 id="org30d4d91">Inoltre, la dimensione massima è a 16 bit, ma l'indice di fragment offset è su 13. Come si potrebbe indicare l'indice successivo a un pacchetto che già occupava la dimensione massima su 16 bit?</h5>
</div>
<div id="outline-container-org67d375a" class="outline-5">
<h5 id="org67d375a">Si decide di utilizzare ogni bit per indicare un ottetto. Questo comporta che ogni frammento deve avere una dimensione in byte che sia un multiplo di 8.</h5>
</div>
<div id="outline-container-org5064088" class="outline-5">
<h5 id="org5064088">Il primo frammento sarebbe quindi di una dimensione uguale al multiplo di 8 appena minore dello spazio rimasto oltre i byte.</h5>
<div class="outline-text-5" id="text-org5064088">
</div>
<div id="outline-container-org6176b54" class="outline-6">
<h6 id="org6176b54">L'ID è assegnato, la lunghezza totale pure. Nel primo frammento il fragment offset sarà a 0, e il bit More fragments a 1. Nel secondo pacchetto, invece, il fragment offset sarà uguale al numero di byte spediti in quello precedente, diviso 8. Così indico la posizione che il nuovo frammento occupa rispetto a quello precedente. Alla fine, il bit M verrà settato a 0 e si passerà al prossimo.</h6>
</div>
</div>
<div id="outline-container-org38b7b3d" class="outline-5">
<h5 id="org38b7b3d">Il riassemblamento viene effettuato soltanto dagli end system, quindi i pacchetti non vengono riassemblati per poi essere di nuovo frammentati per rispettare i nuovi protocolli, ma si lavora sui frammenti già presenti.</h5>
</div>
<div id="outline-container-org7d28129" class="outline-5">
<h5 id="org7d28129">In ogni tratta mi occupo di soddifare i requisiti della rete fisica di cui mi sto occupando, ma non ricompongo mai, scompongo soltanto ulteriormente.</h5>
</div>
</div>
</div>
<div id="outline-container-org69c3c2c" class="outline-3">
<h3 id="org69c3c2c">L'indirizzamento avviene attraverso l'IP address, che consiste in 4 sequenze di 8 bit, di cui viene rappresentato il valore decimale.</h3>
<div class="outline-text-3" id="text-org69c3c2c">
</div>
<div id="outline-container-org315705e" class="outline-4">
<h4 id="org315705e">L'indirizzo IP è unico a livello globale. Esiste un organismo internazionale, chiamato ICANN, ovvero "&#x2026; for Name and Numbers" e se voglio assegnare un nome al mio dispositivo, devo chiedere a loro.</h4>
</div>
<div id="outline-container-orga3a9e92" class="outline-4">
<h4 id="orga3a9e92">Abbiamo 5 modalità di addressing:</h4>
<div class="outline-text-4" id="text-orga3a9e92">
<ul class="org-ul">
<li>CLASS based</li>
<li>Subnetting</li>
<li>CIDR (Classless &#x2026;), molto usato</li>
<li>NAT, diffusissimo</li>
<li>IPv6, che riguarda un tipo diverso ai precedenti, ma che usa comunque il NAT ed il subnetting</li>
</ul>
</div>
<div id="outline-container-org268a7af" class="outline-5">
<h5 id="org268a7af">Tutte queste soluzioni sono rivolte a garantire l'unicità degli indirizzi IP</h5>
</div>
</div>
<div id="outline-container-orgab13f4f" class="outline-4">
<h4 id="orgab13f4f">Nel CLASS based, esistono 3 classi diverse, che gestiscono trasmissioni Unicast, ovvero punto-punto.</h4>
<div class="outline-text-4" id="text-orgab13f4f">
</div>
<div id="outline-container-org3a246aa" class="outline-5">
<h5 id="org3a246aa">Esistono anche una classe per Multicast e una Reserved.</h5>
</div>
<div id="outline-container-org15a52e1" class="outline-5">
<h5 id="org15a52e1">La classe A è caratterizzata dal primo bit settato a quindi il valore del primo byte è da 0 a 127</h5>
</div>
<div id="outline-container-org9b8448e" class="outline-5">
<h5 id="org9b8448e">La classe B ha il primo bit settato ad 1, quindi da 128 a 191</h5>
</div>
<div id="outline-container-orge975a40" class="outline-5">
<h5 id="orge975a40">La classe C ha i primi due bit, quindi da 192 a 255</h5>
</div>
<div id="outline-container-org4b9ce94" class="outline-5">
<h5 id="org4b9ce94">In ogni classe, una prima sezione riguarda l'ID della rete, mentre la seconda riguarda il singolo Host</h5>
<div class="outline-text-5" id="text-org4b9ce94">
</div>
<div id="outline-container-orge3d81c3" class="outline-6">
<h6 id="orge3d81c3">Se un router vede che la sezione iniziale è di passaggio, non si preoccupa neanche di controllare l'HostID.</h6>
</div>
<div id="outline-container-org7a8d469" class="outline-6">
<h6 id="org7a8d469">Più alta è la classe, meno reti univoche esistono, ma hanno più spazio per host.</h6>
</div>
</div>
<div id="outline-container-orge585120" class="outline-5">
<h5 id="orge585120">C'è un problema di frammentazione interna: è praticamente impossibile che un certo network ID utilizzi tutti gli Host ID ad esso associati</h5>
</div>
<div id="outline-container-org851a591" class="outline-5">
<h5 id="org851a591">Il subnetting riserva, a partire dalla divisione in classi precedente, una parte dell'HostID per creare delle subnet, utili all'amministratore per gestire ed organizzare logicamente le reti.</h5>
<div class="outline-text-5" id="text-org851a591">
</div>
<div id="outline-container-orga1b32ff" class="outline-6">
<h6 id="orga1b32ff">Prendiamo un indirizzo del tipo 130.50.15.6.</h6>
<div class="outline-text-6" id="text-orga1b32ff">
</div>
<div id="outline-container-org799c23b" class="outline-7">
<h7 id="org799c23b">Ignoriamo i primi 16 bit, che sono quelli del NetID, abbiamo 15.6, ovvero 00001111 00000110.</h7>
</div>
<div id="outline-container-org6b79aa6" class="outline-7">
<h7 id="org6b79aa6">Come fa il router a selezionare i 6 bit della subnet e i 10 bit dell'host?</h7>
<div class="outline-text-7" id="text-org6b79aa6">
</div>
<div id="outline-container-org9584ac3" class="outline-8">
<h8 id="org9584ac3">Bisogna in qualche modo istruire il router in modo che capisca che questo il modo in cui vanno letti e non quello originario, in cui tutti i bit sono Host.</h8>
</div>
<div id="outline-container-org21d2aa6" class="outline-8">
<h8 id="org21d2aa6">Viene quindi introdotta una subnet mask, che filtri via i 6 bit della subnet e lasci tutto il resto, venendo sovrapposta con un AND, dove i 6 bit della subnet, e tutti i bit precedenti, quelli del NetID sono settati a 1, in modo da lasciarli intatti, e il resto a 0, in modo da cancellare il restanti 10 bit dell'host.</h8>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgeb85436" class="outline-2">
<h2 id="orgeb85436">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.</h2>
<div class="outline-text-2" id="text-orgeb85436">
</div>
<div id="outline-container-orgf12c20e" class="outline-3">
<h3 id="orgf12c20e">Gli altri metodi, CIDR e NAT, sono usati per superare il problema della frammentazione interna degli IP e aumentare la longevità di IPv4.</h3>
<div class="outline-text-3" id="text-orgf12c20e">
</div>
<div id="outline-container-org3631536" class="outline-4">
<h4 id="org3631536">Prima o poi, gli indirizzi a 32 bit di v4 finiranno, e saremmo costretti a utilizzare i 128 bit del IPv6.</h4>
</div>
<div id="outline-container-orgc6fa437" class="outline-4">
<h4 id="orgc6fa437">CIDR sta per Classless Inter Domain Routing e invece di dividere in classi, lo fa in blocchi autonomi e indipendenti, geografici (europeo, nord-americano, asiatico, ecc.).</h4>
<div class="outline-text-4" id="text-orgc6fa437">
</div>
<div id="outline-container-org4de2b24" class="outline-5">
<h5 id="org4de2b24">Per esempio, in Europa gli indirizzi vanno da 194.0.0.0 a 194.255.255.255 e lo stesso per 195. Quindi abbiamo 3 sequenze da 8 bit, quindi ognuna da 256 indirizzi, con un totale di 16,777,216. Questo numero è per ogni sequenza iniziale di bit, quindi, moltiplicata per 2, ci porta ad un totale di 33,554,432 indirizzi per l'europa.</h5>
</div>
<div id="outline-container-org139b38d" class="outline-5">
<h5 id="org139b38d">Il vantaggio è che ogni operatore può scegliere un numero di subnet o host che preferisce.</h5>
<div class="outline-text-5" id="text-org139b38d">
</div>
<div id="outline-container-org30aea46" class="outline-6">
<h6 id="org30aea46">Fra paginazione e segmentazione, il vantaggio è che la seconda fa perdere frammentazione interna, ma può creare quella esterna.</h6>
<div class="outline-text-6" id="text-org30aea46">
</div>
<div id="outline-container-orga219dc0" class="outline-7">
<h7 id="orga219dc0">Infatti, nel momento in cui ogni spazio è occupato e uno degli spazi viene deallocato, bisogna trovare qualcuno che abbia bisogno di un numero massimo uguale a quello lasciato, altrimenti non trova posto e quello spazio rimane inallocato.</h7>
</div>
</div>
<div id="outline-container-org1e0db39" class="outline-6">
<h6 id="org1e0db39">Supponiamo che un organizzazione di Milano richieda 2048 indirizzi e gli viene assegnato l'indirizzo 194.24.0.___, fino a quello 194.24.7.___. L'ultima parte è interna e quindi non serve indicarla.</h6>
<div class="outline-text-6" id="text-org1e0db39">
</div>
<div id="outline-container-orge25c4c1" class="outline-7">
<h7 id="orge25c4c1">All'organizzazione viene assegnato l'indirizzo base, ovvero i primi 3 byte. Bisogna però dare al router un altro strumento di filtro, per evitare che vada ad utilizzare indirizzi fuori da questo slot.</h7>
</div>
</div>
<div id="outline-container-orgb27673f" class="outline-6">
<h6 id="orgb27673f">Una di roma chiede 2046 indirizzi, servono quindi 16 pagine da 256 indirizzi, allora 4 bit saranno cancellati</h6>
</div>
<div id="outline-container-org76d0abf" class="outline-6">
<h6 id="org76d0abf">Ogni router deve quindi far girare tutte le maschere che conosce in AND con l'indirizzo ricevuto, finchè non trova la base dello spazio di indirizzi che è stato assegnato.</h6>
</div>
<div id="outline-container-org70071e5" class="outline-6">
<h6 id="org70071e5">Questa soluzione allunga la vita a IPV4, ma non risolve completamente il problema. Fra l'altro, il numero massimo di IP è 30 milioni, molto minore della popolazione europea.</h6>
</div>
</div>
</div>
<div id="outline-container-org4174286" class="outline-4">
<h4 id="org4174286">Il NAT estende ulteriormente la vita di IPv4.</h4>
<div class="outline-text-4" id="text-org4174286">
</div>
<div id="outline-container-orgce555d4" class="outline-5">
<h5 id="orgce555d4">Ogni rete privata ha un NAT, che è un router, che fa da "firewall" fra il mondo di indirizzamento pubblico e quello di indirizzamento privato.</h5>
</div>
<div id="outline-container-org1bce080" class="outline-5">
<h5 id="org1bce080">Vengono riservati gli ip che iniziano con 10, 172 e 192 alle reti private.</h5>
</div>
<div id="outline-container-org3279665" class="outline-5">
<h5 id="org3279665">Ogni organizzazione viene raggiunta da un IP unico a livello globale, che poi smisterà il pacchetto agli IP, univoci solo a livello di organizzazione, degli host singoli.</h5>
</div>
<div id="outline-container-org2e36e20" class="outline-5">
<h5 id="org2e36e20">Ovviamente, è necessario che i pacchetti salvino sia l'IP globale che quello locale.</h5>
</div>
<div id="outline-container-orgb405482" class="outline-5">
<h5 id="orgb405482">Bisogna gestire il caso delle requeste da parte degli host locali: questi ultimi sanno dove passare per raggiungere il server, ovvero attraverso il NAT. Il server, invece, riceve una request soltanto dal NAT e risponderà ad esso, ma non ha informazione dell'host locale originario.</h5>
<div class="outline-text-5" id="text-orgb405482">
</div>
<div id="outline-container-org4df89f8" class="outline-6">
<h6 id="org4df89f8">Abbiamo bisogno di qualcosa di nuovo per salvare questa informazione, in modo che il NAT riesca ad associare i pacchetti in arrivo con gli specifici host.</h6>
</div>
<div id="outline-container-org9f9eca4" class="outline-6">
<h6 id="org9f9eca4">Un metodo per risolvere questo problema è attraverso il concetto di porta: il TCP è un identificatore numerico che vale solo nel sistema operativo, che associa all'interno della macchina il processo alla specifica entità TCP.</h6>
<div class="outline-text-6" id="text-org9f9eca4">
</div>
<div id="outline-container-orge2d8b64" class="outline-7">
<h7 id="orge2d8b64">Il numero della porta è restituito all'apertura di una socket, come per i file descriptor al momento della open o write in un SO.</h7>
</div>
<div id="outline-container-org71ae2fd" class="outline-7">
<h7 id="org71ae2fd">I server web di tutto il mondo parlano sulla porta 80, well-known-port.</h7>
</div>
<div id="outline-container-org35f37c4" class="outline-7">
<h7 id="org35f37c4">I server client hanno, invece, un numero di porta effimero assegnato mediante chiamata a primitiva socket e consistente durante la vita della socket.</h7>
</div>
<div id="outline-container-orgc91a547" class="outline-7">
<h7 id="orgc91a547">Immaginiamo ora che la host machine dietro NAT usi la porta 1500 ed il server la porta 80. Allora, ogni pacchetto conterrà, oltre ai 3 ip coinvolti (host, NAT, server), anche la porta sorgente e quella destinazione, così che la comunicazione avverrà tra le due porte in questione e il NAT avrà modo di associare il pacchetto in arrivo all'host originario.</h7>
</div>
<div id="outline-container-orgeb6545c" class="outline-7">
<h7 id="orgeb6545c">A questo punto, la gerarchia ben definita secondo cui ogni livello pensa solo a sè stesso, crolla.</h7>
<div class="outline-text-7" id="text-orgeb6545c">
</div>
<div id="outline-container-org774db56" class="outline-8">
<h8 id="org774db56">Infatti, IP porta in giro lo header di TCP, che sta a livello 4 e quindi dovrebbe essere completamente ignorato a livello 3.</h8>
</div>
<div id="outline-container-org14a8f7d" class="outline-8">
<h8 id="org14a8f7d">Invece, il router NAT a livello 3, per compiere le sue tipiche funzioni di instradamento nell'inviare il pacchetto alla sua macchina host, deve andare a leggere lo header TCP, in particolare la porta che quello ha assegnato all'host. Lo stesso vale per le comunicazioni in uscita.</h8>
</div>
<div id="outline-container-org4c97dc9" class="outline-8">
<h8 id="org4c97dc9">Insomma, lo svolgimento del livello 3 quando è coinvolto un NAT, è basato su risultati creati a livello 4.</h8>
</div>
</div>
</div>
<div id="outline-container-org3158f6d" class="outline-6">
<h6 id="org3158f6d">Questa soluzione porta ad un problema successivo: cosa accade se a due processi differenti, viene assegnato lo stesso numero di porta dalle primitive socket?</h6>
</div>
<div id="outline-container-org4008451" class="outline-6">
<h6 id="org4008451">L'unico modo diventa quello di rendere le porte univoche, ed il NAT lo fa utilizzando una numerazione propria e diversa per ogni processo.</h6>
<div class="outline-text-6" id="text-org4008451">
</div>
<div id="outline-container-org1de6dba" class="outline-7">
<h7 id="org1de6dba">Il NAT, quindi, accede allo header di livello 4 non soltanto per leggere, ma anche per sostituire la porta locale con quella NAT.</h7>
</div>
<div id="outline-container-org870be24" class="outline-7">
<h7 id="org870be24">Ovviamente, modifica anche l'IP.</h7>
</div>
<div id="outline-container-org3995b6e" class="outline-7">
<h7 id="org3995b6e">Di conseguenza, le reply arriveranno all'IP del NAT e alla specifica porta NAT, che quest'ultimo trasformerà nella porta host corretta.</h7>
</div>
<div id="outline-container-org10797e5" class="outline-7">
<h7 id="org10797e5">A cosa serve quindi tenere la porta originale? BHO</h7>
</div>
</div>
<div id="outline-container-org4c8ae1d" class="outline-6">
<h6 id="org4c8ae1d">Il NAT offre grandi garanzie in termini di sicurezza, perchè le macchine dietro di lui sono assolutamente invisibili ed inaccessibili dall'esterno, infatti fa anche da firewall.</h6>
</div>
<div id="outline-container-org39d8bd9" class="outline-6">
<h6 id="org39d8bd9">L'ultima questione da risolvere è quella di un server dietro NAT, dato che nessuno conosce la porta che mi porta ad esso.</h6>
<div class="outline-text-6" id="text-org39d8bd9">
</div>
<div id="outline-container-org257ffcf" class="outline-7">
<h7 id="org257ffcf">Un modo banale è quello di assegnargli un IP pubblico, ma perdendo i vantaggi dovuti all'utilizzo del NAT.</h7>
</div>
<div id="outline-container-org2153ee8" class="outline-7">
<h7 id="org2153ee8">Un secondo modo è quello di aprire la porta specifica del server. In questo modo, tutte le richieste verso quella porta vengono routate al server in questione.</h7>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org2ff2230" class="outline-2">
<h2 id="org2ff2230">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.</h2>
<div class="outline-text-2" id="text-org2ff2230">
</div>
<div id="outline-container-org2a0ef71" class="outline-3">
<h3 id="org2a0ef71">A livello 2, in una rete CSMA-CD l'indirizzo è il MAC</h3>
</div>
<div id="outline-container-org52dcd21" class="outline-3">
<h3 id="org52dcd21">A livello 3, l'indirizzo è quello IP, con tutte le considerazioni fatte in precedenza.</h3>
</div>
<div id="outline-container-orgb1a0474" class="outline-3">
<h3 id="orgb1a0474">Un problema che dobbiamo risolvere è quello di mappare l'IP al corrispondente MAC.</h3>
<div class="outline-text-3" id="text-orgb1a0474">
</div>
<div id="outline-container-org6b5c94a" class="outline-4">
<h4 id="org6b5c94a">Infatti, finora non c'è nessun modo per far arrivare un pacchetto a destinazione.</h4>
</div>
</div>
<div id="outline-container-orgbba1bd7" class="outline-3">
<h3 id="orgbba1bd7">Immaginiamo che A e B siano sulla stessa rete locale.</h3>
<div class="outline-text-3" id="text-orgbba1bd7">
</div>
<div id="outline-container-org4d5a1d2" class="outline-4">
<h4 id="org4d5a1d2">Se la macchina A manda un pacchetto al modulo B, chiede ad ARP di risolvere l'IP in un MAC address, così che possa mandarglielo attraverso il livello 2</h4>
</div>
<div id="outline-container-orgd7d9458" class="outline-4">
<h4 id="orgd7d9458">In pratica l'ARP, per conto di IP, manda ai livelli sottostanti una richiesta, ARPRequest, così che il dispositivo in questione risponda con un ARPReply, rispondendo con il proprio MAC, che ARP fornirà al livello IP della macchina sorgente.</h4>
<div class="outline-text-4" id="text-orgd7d9458">
</div>
<div id="outline-container-org16c6367" class="outline-5">
<h5 id="org16c6367">Le due macchine, nell'esempio, si trovano nella stessa rete. Ovviamente, nella richiesta non si sa chi sia l'host destinazione, quindi è necessario fare una richiesta broadcast. La risposta sarà, invece, punto-punto.</h5>
</div>
</div>
</div>
<div id="outline-container-org455c2e2" class="outline-3">
<h3 id="org455c2e2">Immaginiamo adesso che siano su macchine diverse.</h3>
<div class="outline-text-3" id="text-org455c2e2">
</div>
<div id="outline-container-org7adf358" class="outline-4">
<h4 id="org7adf358">A manda richiesta a Z, su un'altra rete.</h4>
</div>
<div id="outline-container-orgec01aea" class="outline-4">
<h4 id="orgec01aea">Il site access gateway leggerà il NETID e vedrà che non appartiene alla rete locale e che quindi va cercato al di fuori. Prenderà lui in carico l'operazione.</h4>
</div>
<div id="outline-container-org973da04" class="outline-4">
<h4 id="org973da04">A questo punto, risponderà con il proprio MAC, in modo che A mandi le richieste al gateway.</h4>
</div>
<div id="outline-container-org20d2028" class="outline-4">
<h4 id="org20d2028">Il gateway aspetterà autonomamente per la ARPReply della macchina remota e salverà il risultato.</h4>
</div>
<div id="outline-container-orgfe7eff2" class="outline-4">
<h4 id="orgfe7eff2">Questo servizio si chiama ProxyARP.</h4>
</div>
</div>
<div id="outline-container-orgeed7755" class="outline-3">
<h3 id="orgeed7755">ARP in ogni dispositivo terrà una ARP Cache, in cui salverà tutte le associazioni IP-MAC, così che le volte successive non servirà una nuova richiesta.</h3>
</div>
<div id="outline-container-orge7adf3a" class="outline-3">
<h3 id="orge7adf3a">Quindi uso ARP per fare una discovery delle macchine che sono raggiungibili in rete.</h3>
</div>
<div id="outline-container-org01b062a" class="outline-3">
<h3 id="org01b062a">Anche in questo caso, abbiamo un livello 3 che per funzionare (anzi, il suo obiettivo) è di livello 2. Deve infatti andare a toccare il MAC, indirizzo di livello 2, ma in questo caso almeno fa una richiesta</h3>
</div>
<div id="outline-container-org19284db" class="outline-3">
<h3 id="org19284db">Notiamo che nello header di livello 3, il campo type è usato anche per identificare se la richiesta sia IPv4 o ARP</h3>
</div>
</div>
<div id="outline-container-org0fc631e" class="outline-2">
<h2 id="org0fc631e">Introduciamo il DHCP</h2>
<div class="outline-text-2" id="text-org0fc631e">
</div>
<div id="outline-container-org7fd68ab" class="outline-3">
<h3 id="org7fd68ab">Abbiamo tante macchine collegate ad una LAN, che possono essere nostre oppure di ospiti che arrivano transitoriamente. Come assegniamo l'IP privato alle macchine?</h3>
<div class="outline-text-3" id="text-org7fd68ab">
</div>
<div id="outline-container-org4861a87" class="outline-4">
<h4 id="org4861a87">La LAN potrebbe essere Wireless, collegata tramite un Access Point ad una Lan fisica, che tramite il suo Access Gateway è collegata alla rete fisica.</h4>
</div>
</div>
<div id="outline-container-org15d33a8" class="outline-3">
<h3 id="org15d33a8">Il Gateway riesce a fare Address Resolution e quindi è anche un NAT. Ovvero, riesce a mascherare un indirizzo interno.</h3>
<div class="outline-text-3" id="text-org15d33a8">
</div>
<div id="outline-container-orgd0df152" class="outline-4">
<h4 id="orgd0df152">Ci presenta con un IP pubblico alla rete, ma poi smista alle macchine singole con gli indirizzi privati.</h4>
</div>
</div>
<div id="outline-container-org7c811c1" class="outline-3">
<h3 id="org7c811c1">Questi indirizzi potrebbero esere statici, ma questo è scomodo. (Perchè?).</h3>
</div>
<div id="outline-container-org6e23884" class="outline-3">
<h3 id="org6e23884">E' più comodo se al momento della prima connessione alla rete, venga assegnato un IP dinamico al dispositivo, che rimanga fino allo spegnimento.</h3>
</div>
<div id="outline-container-orga63ba45" class="outline-3">
<h3 id="orga63ba45">Per assegnare l'IP dinamico, usiamo il server DHCP (eventualmente molteplici)</h3>
<div class="outline-text-3" id="text-orga63ba45">
</div>
<div id="outline-container-orgc13eb47" class="outline-4">
<h4 id="orgc13eb47">Appena una macchina cliente viene bootata, fa un operazione di Request DHCP al server, che farà a sua volta una Reply.</h4>
</div>
<div id="outline-container-orgc1f6590" class="outline-4">
<h4 id="orgc1f6590">La reply assegna un IP privato, valido per tutto il tempo necessario.</h4>
<div class="outline-text-4" id="text-orgc1f6590">
</div>
<div id="outline-container-orga4eafcb" class="outline-5">
<h5 id="orga4eafcb">Addirittura, un DHCP address ha un TimeToLeave, poi viene buttato e refreshato.</h5>
</div>
<div id="outline-container-org90b5814" class="outline-5">
<h5 id="org90b5814">Al punto che quando arriva un ospite (abilitato ad accedere alla rete), loro parlano con DHCP e diventano a tutti gli effetti parte della rete.</h5>
</div>
</div>
<div id="outline-container-orga3df222" class="outline-4">
<h4 id="orga3df222">La RequestForComment che lo definisce è la 2131.</h4>
</div>
<div id="outline-container-org28eaab0" class="outline-4">
<h4 id="org28eaab0">Il client triggera la richiesta, che nello specifico si chiama DHCP Discover.</h4>
<div class="outline-text-4" id="text-org28eaab0">
</div>
<div id="outline-container-org918919e" class="outline-5">
<h5 id="org918919e">Questa discover è un pacchetto IP che viaggia con sorgente 0.0.0.0, perchè non so scriverlo ed è proprio per questo che mando la richiesta.</h5>
</div>
<div id="outline-container-org1ef64ea" class="outline-5">
<h5 id="org1ef64ea">La destinazione è 255.255.255.255. Un pacchetto broadcast all'interno della LAN. Non va direttamente al server DHCP. Il motivo è che se io voglio un assegnamento dinamico per ogni macchina, anche non appartenenti alla mia rete, non posso assumere che questi sappiano l'indirizzo del server DHCP.</h5>
</div>
<div id="outline-container-org165f9d0" class="outline-5">
<h5 id="org165f9d0">Inoltre, se io mettessi un singolo IP, perderei la possiblità di avere molteplici DHCP server, utilizi banalmente per ridondanza.</h5>
</div>
<div id="outline-container-org805ec63" class="outline-5">
<h5 id="org805ec63">Poi c'è un campo Time To Live,  con un Transaction ID, che viene associato all'indirizzo della macchina.</h5>
<div class="outline-text-5" id="text-org805ec63">
</div>
<div id="outline-container-orgf527c15" class="outline-6">
<h6 id="orgf527c15">Questo serve per associare le request alle response</h6>
</div>
<div id="outline-container-org6a429c0" class="outline-6">
<h6 id="org6a429c0">Per identificare questo Time To Live con il client della richiesta, non può essere utilizzato l'IP, ma necessariamente il MAC di livello 2.</h6>
</div>
</div>
</div>
<div id="outline-container-org7bc0665" class="outline-4">
<h4 id="org7bc0665">Il server riceve la richiesta e reagisce con una DHCP Offer.</h4>
<div class="outline-text-4" id="text-org7bc0665">
</div>
<div id="outline-container-org11b6d41" class="outline-5">
<h5 id="org11b6d41">Quello che offre il DHCP server è l'IP address.</h5>
</div>
<div id="outline-container-org77d9008" class="outline-5">
<h5 id="org77d9008">Sarà sempre un pacchetto con sorgente IP del Server, broadcast e lo stesso transactionID della richiesta.</h5>
<div class="outline-text-5" id="text-org77d9008">
</div>
<div id="outline-container-org882b60a" class="outline-6">
<h6 id="org882b60a">Deve necessariamente essere broadcast.</h6>
</div>
</div>
<div id="outline-container-org3383704" class="outline-5">
<h5 id="org3383704">Prima di fare la offer, il server fa un check. Il check dell'IP prevede che tramite ICMP il server sia in grado di verificare se per caso quell'IP non sia stato già assegnato a qualcuno per errore.</h5>
<div class="outline-text-5" id="text-org3383704">
</div>
<div id="outline-container-org7fda429" class="outline-6">
<h6 id="org7fda429">In pratica fa un ping, che prevede un echo se la stazione è raggiungibile. Se l'echo è assente, l'IP non è stato associato a nessuno. Altrimenti l'IP va aggiornato.</h6>
</div>
</div>
</div>
<div id="outline-container-org9da067d" class="outline-4">
<h4 id="org9da067d">A questo punto il client ha <b>apparentemente</b> risolto il suo problema.</h4>
<div class="outline-text-4" id="text-org9da067d">
</div>
<div id="outline-container-org2cc334f" class="outline-5">
<h5 id="org2cc334f">Si può immaginare che il client abbia un timeout in modo che non trascorra troppo prima dell'arrivo di una offer. (Stesso principio dell'ACK).</h5>
</div>
<div id="outline-container-org3cdb5b0" class="outline-5">
<h5 id="org3cdb5b0">Il problema è che un algoritmo di questo tipo funzionerebbe se e solo se ammettesse uno e un solo server DHCP operativo per ogni rete, ma il protocollo è fatto per funzionare con un numero arbitrario di server.</h5>
<div class="outline-text-5" id="text-org3cdb5b0">
</div>
<div id="outline-container-orgd7223c2" class="outline-6">
<h6 id="orgd7223c2">Infatti, la discover è in broadcast e arriva a tutti i server, che si adopereranno tutti per offrire un IP.</h6>
</div>
</div>
<div id="outline-container-org3220e03" class="outline-5">
<h5 id="org3220e03">Bisogna garantire che venga accettata l'offerta di un solo server.</h5>
</div>
</div>
<div id="outline-container-org3ce8f92" class="outline-4">
<h4 id="org3ce8f92">Diventa necessaria un ulteriore fase, una commit, chiamata DHCP Request.</h4>
<div class="outline-text-4" id="text-org3ce8f92">
</div>
<div id="outline-container-org13ec8d2" class="outline-5">
<h5 id="org13ec8d2">Questa viaggia con stesse sorgente e destinazione della discover (0 e 1Broadcast), ma con un ulteriore campo scelta, che contiene un ID del server la cui offerta è stata accettata.</h5>
</div>
</div>
<div id="outline-container-org6e3f09a" class="outline-4">
<h4 id="org6e3f09a">A questo punto, si chiude il commitment con una DHCP Ack, che è una validazione della request. Anche questo è mandato in broadcast secondo IP.</h4>
<div class="outline-text-4" id="text-org6e3f09a">
</div>
<div id="outline-container-org85058d6" class="outline-5">
<h5 id="org85058d6">Ricordare che tutte queste comunicazioni di risposta da parte del server, utilizzano il MAC di livello 2 e sono quindi Unicast.</h5>
</div>
</div>
<div id="outline-container-org340a788" class="outline-4">
<h4 id="org340a788">Questo protocollo è un protocollo a 4 vie, a causa della necessità di selezionare fra i vari server.</h4>
</div>
<div id="outline-container-org47d7302" class="outline-4">
<h4 id="org47d7302">Servono inoltre dei check per verificare la validità degli IP, anche dal punto di vista del client.</h4>
<div class="outline-text-4" id="text-org47d7302">
</div>
<div id="outline-container-org91c88e9" class="outline-5">
<h5 id="org91c88e9">Viene utilizzato ARP, che è perfetto per questo lavoro, ovvero risolvere un IP in un MAC.</h5>
<div class="outline-text-5" id="text-org91c88e9">
</div>
<div id="outline-container-orge906ec6" class="outline-6">
<h6 id="orge906ec6">Facendo una ARP request con l'IP appena assegnato al server, in caso di risposta positiva si capisce che l'IP è già assegnato.</h6>
</div>
</div>
</div>
<div id="outline-container-org12d787b" class="outline-4">
<h4 id="org12d787b">Esistono dei meccanismi di ricovero, per gestire i casi in cui i messaggi vengano persi. Si utilizza ad esempio un timer T, che viene eseguito massimo K volte (numero di retry). Una volta aver provato K volte, si ritorna alle origini e si ricomincia da capo.</h4>
</div>
</div>
</div>
<div id="outline-container-orgc358057" class="outline-2">
<h2 id="orgc358057">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).</h2>
</div>
<div id="outline-container-org45d723d" class="outline-2">
<h2 id="org45d723d">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente</h2>
<div class="outline-text-2" id="text-org45d723d">
</div>
<div id="outline-container-org6548db2" class="outline-3">
<h3 id="org6548db2">Immaginiamo di avere due macchine con porte I/O e un forwarder in mezzo, che contiene una tabella e fa un lookup per capire su quale porta trasmettere il messaggio entrato.</h3>
<div class="outline-text-3" id="text-org6548db2">
</div>
<div id="outline-container-orgf74c36a" class="outline-4">
<h4 id="orgf74c36a">A livello 2, questo è fatto dal bridge, che popola e spopola le tabelle periodicamente per lasciar spostare le macchine.</h4>
</div>
<div id="outline-container-orge4ace56" class="outline-4">
<h4 id="orge4ace56">Se saliamo di un piano, quello che cambia radicalmente è che non è più vero che la macchina destinazione sia attaccata al link. La validità di un forwarding livello 2, a livello 3 non è più sufficiente.</h4>
<div class="outline-text-4" id="text-orge4ace56">
</div>
<div id="outline-container-orgf1b141b" class="outline-5">
<h5 id="orgf1b141b">Il forwarding deve avere la capacità di scegliere la porta che conduce alla destinazione in futuro, e in un modo oscuro alla singola macchina.</h5>
</div>
</div>
</div>
<div id="outline-container-org290eec7" class="outline-3">
<h3 id="org290eec7">A livello 3, la tabella viene popolata da un secondo processo, che chiamiamo <b>router</b>, che lavora con i suoi pacchetti di controllo, utili soltanto a lui, tramite i quali impara la topologia della rete e popola la tabella in modo da permettere di raggiungere ogni host in un modo efficiente, possibilmente il cammino minimo.</h3>
<div class="outline-text-3" id="text-org290eec7">
</div>
<div id="outline-container-orgbf325b6" class="outline-4">
<h4 id="orgbf325b6">La cosa interessante è che abbiamo una separazione netta fra tutto ciò che è gestione dei dati utente e la gestione di controllo di tutto ciò che serve alla rete autonomamente perchè funzioni.</h4>
</div>
<div id="outline-container-orgdde5dca" class="outline-4">
<h4 id="orgdde5dca">Con il routing questa diventa chiara.</h4>
<div class="outline-text-4" id="text-orgdde5dca">
</div>
<div id="outline-container-orga4899b9" class="outline-5">
<h5 id="orga4899b9">Finora i messaggi di controllo e i dati erano mescolati, anche fisicamente.</h5>
</div>
<div id="outline-container-org3ee6554" class="outline-5">
<h5 id="org3ee6554">Adesso, il router lavora in modo assolutamente autonomo.</h5>
</div>
</div>
</div>
<div id="outline-container-orgda4ce45" class="outline-3">
<h3 id="orgda4ce45">Il router opera attraverso 3 tecniche:</h3>
<div class="outline-text-3" id="text-orgda4ce45">
<ul class="org-ul">
<li>Distance vector - RIP, vecchio e residuale</li>
<li>OSPF, link state, più diffuso</li>
<li>BGP, Border Gateway Protocol, evoluzione del distance vector, utilizzato per la comunicazione ad alto livello, intercontinentale</li>
</ul>
</div>
<div id="outline-container-org1d16bcf" class="outline-4">
<h4 id="org1d16bcf">Il protocollo con Distance vector opera assegnando due etichette con numero del link e corrispondente peso su ogni arco bidirezionale.</h4>
<div class="outline-text-4" id="text-org1d16bcf">
</div>
<div id="outline-container-orgb4b1f44" class="outline-5">
<h5 id="orgb4b1f44">Ogni nodo produce la tabella delle adiacenze. Questa contiene Router, Link e Cost.</h5>
<div class="outline-text-5" id="text-orgb4b1f44">
</div>
<div id="outline-container-org3266fd5" class="outline-6">
<h6 id="org3266fd5">Sè stesso è raggiungibile da sè stesso (no link) con costo 0.</h6>
</div>
<div id="outline-container-orgd2c4f15" class="outline-6">
<h6 id="orgd2c4f15">Ogni altro router, è raggiungibile attraverso un certo link, con un costo uguale alla somma delle etichette dei pesi di tutti gli archi che vengono attraversati.</h6>
</div>
</div>
<div id="outline-container-org7f64ae1" class="outline-5">
<h5 id="org7f64ae1">Con queste costruiamo la conoscenza locale, ovvero tutti i router appena adiacenti attraverso soltanto un filo, insieme al loro costo.</h5>
<div class="outline-text-5" id="text-org7f64ae1">
</div>
<div id="outline-container-org0d970d7" class="outline-6">
<h6 id="org0d970d7">Ancora non abbiamo una visione topologica della rete. Abbiamo solo una visione delle adiacenze.</h6>
<div class="outline-text-6" id="text-org0d970d7">
</div>
<div id="outline-container-org7f79420" class="outline-7">
<h7 id="org7f79420">Un singolo nodo nono ha idea di quali nodi possa raggiungere oltre le adiacenze.</h7>
</div>
</div>
</div>
<div id="outline-container-orgb591f16" class="outline-5">
<h5 id="orgb591f16">Il modo per passare da una conoscenza locale a quella globale sfrutta la comunicazione fra nodi.</h5>
</div>
<div id="outline-container-org8f6eb0c" class="outline-5">
<h5 id="org8f6eb0c">Periodicamente viene trasferito agli altri il distance vector, ovvero l'associazione Router-Costo</h5>
<div class="outline-text-5" id="text-org8f6eb0c">
</div>
<div id="outline-container-org5e0b404" class="outline-6">
<h6 id="org5e0b404">Ogni router ha un proprio timer, alla scadenza del quale trasferisce il vettore delle distanze ai suoi vicini.</h6>
</div>
</div>
<div id="outline-container-orgfb8f511" class="outline-5">
<h5 id="orgfb8f511">Quando un nodo riceve il vettore delle distanze del vicino, aggiorna il proprio vettore con i nuovi nodi raggiungibili attraverso il vicino, la cui distanza è la somma fra il primo nodo è quello appena collegato e quest'ultimo con il nuovo.</h5>
</div>
<div id="outline-container-orgd023831" class="outline-5">
<h5 id="orgd023831">Ogni vettore delle distanze nuovo che arriva, un router calcola anche tutte le nuove distanze per le destinazioni che già conosce, in modo da aggiornare nuove distanze minime.</h5>
</div>
<div id="outline-container-org6045df6" class="outline-5">
<h5 id="org6045df6">Il tempo necessario per conoscere tutta la rete è lineare con il suo diametro.</h5>
</div>
<div id="outline-container-orgeafbb6d" class="outline-5">
<h5 id="orgeafbb6d">Viene inoltre utilizzato il trigger update con cui i nodi vicini possono richiedere informazioni alla variazione dello stato. Ad esempio usano il trigger update i router appena accesi così chiamano velocemente informazioni nuove.</h5>
</div>
<div id="outline-container-orgc3c4d60" class="outline-5">
<h5 id="orgc3c4d60">Il problema di questo protocollo è che non c'è modo di aggiornare in caso di peggioramenti e questo causa un malfunzionamento abbastanza grave.</h5>
<div class="outline-text-5" id="text-orgc3c4d60">
</div>
<div id="outline-container-orgf48bd30" class="outline-6">
<h6 id="orgf48bd30">Immaginiamo che un link su un certo nodo si guasti.</h6>
<div class="outline-text-6" id="text-orgf48bd30">
</div>
<div id="outline-container-orgf0ea541" class="outline-7">
<h7 id="orgf0ea541">Il nodo stesso lo riconosce subito e aggiorna la propria tabella con valore <b>infinito</b> per il nodo dietro quel link.</h7>
</div>
<div id="outline-container-org2200a2b" class="outline-7">
<h7 id="org2200a2b">Gli altri nodi però non lo sanno e continuano a mandare su quel link, se la loro tabella dice che è quella la strada minore.</h7>
</div>
<div id="outline-container-org9adc9cf" class="outline-7">
<h7 id="org9adc9cf">Questa situazione finisce soltanto nel momento in cui B propaga il suo distance vector con costo infinito.</h7>
</div>
<div id="outline-container-orgf6553ef" class="outline-7">
<h7 id="orgf6553ef">Cosa succede se però nel frattempo un altro nodo, non ancora informato del guasto, manda il proprio distance vector al nodo che ha appena notato il guasto?</h7>
<div class="outline-text-7" id="text-orgf6553ef">
</div>
<div id="outline-container-orgbfa0b8c" class="outline-8">
<h8 id="orgbfa0b8c">Siano A, B e C i nodi, con A che vuole raggiungere C attraverso B, e il collegamento fra B e C guasto.</h8>
<div class="outline-text-8" id="text-orgbfa0b8c">
</div>
<div id="outline-container-org45e2cf9" class="outline-9">
<h9 id="org45e2cf9">Allora la distanza fra A e C è uguale alla distanza fra A e B più quella fra B e C</h9>
</div>
<div id="outline-container-org7c0c7aa" class="outline-9">
<h9 id="org7c0c7aa">Il problema è che adesso la distanza fra B e C è infinita, ma quella fra A e C considera ancora il valore da B e C precedente.</h9>
</div>
<div id="outline-container-orgfc69b28" class="outline-9">
<h9 id="orgfc69b28">Allora B aggiorna la sua stessa distanza fra B e C come quella suggerita da A, che però già contiene la distanza B-C non aggiornata, più la distanza fra A e B.</h9>
<div class="outline-text-9" id="text-orgfc69b28">
</div>
<div id="outline-container-orgb1415f3" class="outline-10">
<h10 id="orgb1415f3">In pratica, B rimpiazza l'infinito con la distanza B-A più A-B più B-C vecchia.</h10>
</div>
<div id="outline-container-org13e90b8" class="outline-10">
<h10 id="org13e90b8">Alla update successiva, A vede che B ha aumentato la propria distanza di un valore uguale alla distanza A-B e aggiorna il suo valore a quella distanza, più B-A</h10>
<div class="outline-text-10" id="text-org13e90b8">
</div>
<div id="outline-container-org9747441" class="outline-11">
<h11 id="org9747441">Quindi A rimpiazza A-B + old(B-C) con A</h11>
</div>
<div id="outline-container-org3adbad8" class="outline-11">
<h11 id="org3adbad8">Quello che succede è questo (indico la distanza fra i nodi A o B e C):</h11>
<div class="outline-text-11" id="text-org3adbad8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">stato</td>
</tr>

<tr>
<td class="org-left">[A-B]+[B-C]</td>
<td class="org-left">[B-C]</td>
<td class="org-left">Iniziale</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">Inf</td>
<td class="org-left">Collegamento rotto e DVB viene perso</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">[B-A]+[A-B]+[B-C]</td>
<td class="org-left">B acquisisce la distanza da A</td>
</tr>

<tr>
<td class="org-left">[A-B]+[B-A]+[A-B]+[B-C]</td>
<td class="org-left">//</td>
<td class="org-left">A acquisisce da B</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">[B-A]+"same as top left"</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org0e97308" class="outline-10">
<h10 id="org0e97308">Si inizierà un <b>count to infinity</b> in cui ad ogni step la distanza verso quel collegamento aumenta della distanza fra i due nodi in questione.</h10>
</div>
<div id="outline-container-org8844df2" class="outline-10">
<h10 id="org8844df2">Questo accade perchè le distanze di sia A che B verso quello guasto C contengono al loro interno la distanza A-B. Ovvero, B raggiunge C tramite A (o almeno crede di fare così) e A raggiunge C tramite B.Il sistema è innescato da B, che normalmente non dovrebbe aggiornare la propria distanza per includere quella di A, perchè il collegamento diretto con C è banalmente più breve di quello che compie un ciclo tramite A e poi ripercorre il collegamento diretto.</h10>
<div class="outline-text-10" id="text-org8844df2">
</div>
<div id="outline-container-orgbf68a92" class="outline-11">
<h11 id="orgbf68a92">Quando però il link con C è danneggiato, accade che il ciclo attraverso A più la vecchia distanza B-C è sicuramente più breve dell'infinito e B aggiorna, senza sapere che A fa affidamento su di lui.</h11>
</div>
<div id="outline-container-org30716ce" class="outline-11">
<h11 id="org30716ce">A aggiorna, senza sapere che B fa affidamento su di lui.</h11>
</div>
<div id="outline-container-org55f9a5e" class="outline-11">
<h11 id="org55f9a5e">MAIN</h11>
<div class="outline-text-11" id="text-org55f9a5e">
<p>
Maybe the solution is that the distance vector also contains the link that leads to a node.
If a new value comes from a distance vector, and that value is HIGHER than the one a node already had, but it is on the same link, the node updates it.
</p>

<p>
Yes, exactly! That's the key insight that explains why count to infinity actually occurs. The distance vector protocol also keeps track of the next hop (the link or neighbor through which a destination is reached), not just the distances.
</p>

<p>
So in the A-B-C scenario:
</p>

<p>
Initially A reaches C through B (next hop = B)
When B-C link fails:
    B sets its distance to C as infinity
    When A receives B's update, even though it's a larger value, A MUST accept it because B is its next hop to C
    A can't keep its old shorter value because that path was dependent on going through B
</p>

<p>
This is why it's crucial that nodes update their routes when they receive updates from their next hop neighbor, even if the new distance is larger. The node must trust its next hop's information about destinations reached through that path.
</p>

<p>
This is also why solutions like split horizon work - they prevent nodes from advertising routes back through the path they learned them from, breaking this cycle of increasing distances.
</p>

<p>
Your observation about the importance of the link/next hop information is spot-on and explains the actual mechanism behind count to infinity much more accurately than the oversimplified "only accept shorter paths" explanation.
SPIEGAZIONE DEL PERCHÈ UN NODO ACCETTA UN VALORE PIÙ ALTO
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9a09d34" class="outline-9">
<h9 id="org9a09d34">Le due cause del problema sono il fatto che l'informazione dello specifico nodo utilizzato per raggiungere una destinazione è persa, e che i disstance vector viaggiano in modo asincrono e possono anche essere smarriti.</h9>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org6900f70" class="outline-5">
<h5 id="org6900f70">Il count to infinity da luogo al bouncing effect, in cui i pacchetti fra i nodi A e B dell'esempio precedente rimangono bloccati rimbalzando fra gli stessi.</h5>
</div>
<div id="outline-container-org9e6f3fd" class="outline-5">
<h5 id="org9e6f3fd">Una soluzione al <b>count to infinity</b> è lo <b>split horizon</b></h5>
<div class="outline-text-5" id="text-org9e6f3fd">
</div>
<div id="outline-container-orge624ded" class="outline-6">
<h6 id="orge624ded">Il distance vector riporterà costo infinito per il link corrispondente a quello utilizzato per inviare lo stesso distance vector.</h6>
<div class="outline-text-6" id="text-orge624ded">
</div>
<div id="outline-container-org929fe8a" class="outline-7">
<h7 id="org929fe8a">Di conseguenza, quando l'infinito inizia a propagarsi,</h7>
</div>
<div id="outline-container-org459d63c" class="outline-7">
<h7 id="org459d63c">Con questo trucco, il distance vector non potrà contenere loop perchè un nodo non sceglierà mai di utilizzare il link che conduce ad un loop.</h7>
</div>
<div id="outline-container-org30a9b3b" class="outline-7">
<h7 id="org30a9b3b">Esiste un caso in cui il problema del count to infinity avviene anche in questo caso.</h7>
<div class="outline-text-7" id="text-org30a9b3b">
</div>
<div id="outline-container-org0c21baa" class="outline-8">
<h8 id="org0c21baa">In particolare, lo split horizon non aiuta nel caso in cui ci siano più di due router coinvolti. Infatti, in questo caso, il nodo appena adiacente a quello su cui è avvenuto il guasto non direbbe a questùltimo di conoscere la strada, ma la direbbe ad un nodo ancora successivo e collegato al primo, su cui è avvenuto il guasto. il terzo nodo della catena avviserebbe il primo di conoscere una strada, la quale sebbene non passi per il link diretto con il nodo che ha un link guasto, passa per un ciclo che eventualmente arriverà a quel nodo. La conseguenza è la stessa.</h8>
<div class="outline-text-8" id="text-org0c21baa">
<pre class="example" id="orgc012043">
Consider three routers A, B, and C in a loop
If the link between A and destination D fails
Router A marks D as unreachable (16)
However, B might still tell C it can reach D
C might then tell A it can reach D
A might then choose this alternative path, not knowing it's part of a loop
The metric will keep increasing until it reaches infinity
</pre>
</div>
</div>
<div id="outline-container-orgd8c0c75" class="outline-8">
<h8 id="orgd8c0c75">Si può dunque dire che lo split horizon abbia un orizzonte di risoluzione di massimo 2 nodi, oltre i quali il problema è irrisolvibile.</h8>
</div>
</div>
</div>
<div id="outline-container-org6b3f7e1" class="outline-6">
<h6 id="org6b3f7e1">I difetti sono che: 1 passo solo il peso ma non il percorso seguito ,2 non ho la topologia magliata, ma conosco solo i miei vicini,3 la propagazione è asincrona e potrei perdere qualche informazione, ovvero le tabele non sempre divergono.</h6>
</div>
<div id="outline-container-org80a496c" class="outline-6">
<h6 id="org80a496c">Quindi le tre tecniche usate per migliorare l'efficienza di questa tecnica sono le seguenti:</h6>
<div class="outline-text-6" id="text-org80a496c">
<ul class="org-ul">
<li>Triggered update</li>
<li>Split horizon</li>
<li>Ogni tempo T flusho le tabelle e risolvo tutte le situazioni difficili che si erano create.</li>
<li>L'infinito è appena maggiore di 16</li>
<li>Storm di update
<ul class="org-ul">
<li>Quando c'è un guasto, tutti i nodi coinvolti farebbero update, con seguente congestione. Viene quindi introdotto un random fra 1 e 5 secondi, così da ridurre la storm ma aumentando la probabilità di count to infinity</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgde5b09b" class="outline-2">
<h2 id="orgde5b09b">Ci rifacciamo alla stessa struttura riguardante il routing, con un router che contiene un forwarder con porte IO di ingresso ed uscita e che opera su una tabella di routing, facendo un lookup e stabilendo la corretta porta di output. Chi scrive sulla tabella è il router, che ha i propri pacchetti di controllo e opera come un processo totalmente asincrono ed indipendente.</h2>
<div class="outline-text-2" id="text-orgde5b09b">
</div>
<div id="outline-container-orgfb2876c" class="outline-3">
<h3 id="orgfb2876c">Il router è attivato periodicamente, mentre il forwarder è attivato alla presenza di un pacchetto in coda di input.</h3>
</div>
<div id="outline-container-org36d7e3f" class="outline-3">
<h3 id="org36d7e3f">Vogliamo sviluppare una soluzione alternativa in cui oltre al peso e alla destinazione del cammino, si dice anche il link che si vuole utilizzare</h3>
</div>
<div id="outline-container-org0824d4e" class="outline-3">
<h3 id="org0824d4e">La gran parte delle reti fondamentali di internet, ovvero quelle intermedie fra LAN, utilizza un protocollo chiamato OSPF Link State</h3>
<div class="outline-text-3" id="text-org0824d4e">
</div>
<div id="outline-container-orgb083c23" class="outline-4">
<h4 id="orgb083c23">Voglio costruirmi il grafo della connettività, con i costi di ogni arco, dopo aver scambiato abbastanza informazioni fra nodi.</h4>
</div>
<div id="outline-container-orgb0e8592" class="outline-4">
<h4 id="orgb0e8592">Ogni nodo manda la distanza sui suoi link a TUTTI gli altri nodi, quindi esistono N(N-1) messaggi di controllo</h4>
<div class="outline-text-4" id="text-orgb0e8592">
</div>
<div id="outline-container-org508c8b9" class="outline-5">
<h5 id="org508c8b9">Questa strategia si chiama FLOODING.</h5>
<div class="outline-text-5" id="text-org508c8b9">
</div>
<div id="outline-container-orge2f5b53" class="outline-6">
<h6 id="orge2f5b53">Ogni link state viene mandato su tutte le porte IO diverse da quella di arrivo.</h6>
</div>
</div>
<div id="outline-container-orge419df0" class="outline-5">
<h5 id="orge419df0">Il link state di uno specifico nodo continuerebbe a girare all'infinito. Allora viene introdotto un buffer che tiene l'ultimo state link e informazioni aggiuntive tipo header, contenenti l'indirizzo del mittente, un numero di sequenza associato allo specifico mittente, un TTL, ovvero un numero massimo di hops che possono essere effettuati e alla fine l'informazione vera e propria</h5>
<div class="outline-text-5" id="text-orge419df0">
</div>
<div id="outline-container-orgd254c40" class="outline-6">
<h6 id="orgd254c40">Ogni LS inviato nel flooding prevede anche un ACK</h6>
<div class="outline-text-6" id="text-orgd254c40">
</div>
<div id="outline-container-org0258f9b" class="outline-7">
<h7 id="org0258f9b">Questo comporta che nella rete sia occupata da tanto traffico di controllo di livello 2</h7>
</div>
</div>
<div id="outline-container-orga3508ff" class="outline-6">
<h6 id="orga3508ff">Per calcolare le distanze, si usa ICMP con il ping, calcolando la distanza con un cronometro fra l'invio ed il ritorno di un pacchetto.</h6>
</div>
</div>
<div id="outline-container-org2e6ed3d" class="outline-5">
<h5 id="org2e6ed3d">Le cose positive del link state sono che si conosce la topologia della rete nella sua interezza, così che attraverso Dijkstra si stabiliscano tutti i cammini minimi.</h5>
</div>
<div id="outline-container-org41b97ec" class="outline-5">
<h5 id="org41b97ec">L'implementazione dei LinkState viene effettuata da OSPF, ovvero open shortest path first.</h5>
<div class="outline-text-5" id="text-org41b97ec">
</div>
<div id="outline-container-org9095176" class="outline-6">
<h6 id="org9095176">Il problema è che questo calcolo andrebbe fatto da ogni nodo nella rete, con un certo carico computazionale.</h6>
</div>
<div id="outline-container-org588b3dd" class="outline-6">
<h6 id="org588b3dd">La routing table conterrà la destinazione da raggiungere, il link attraverso cui si raggiunge e il costo, costruito tramite Dijkstra.</h6>
</div>
<div id="outline-container-orgf4601f3" class="outline-6">
<h6 id="orgf4601f3">Questo protocollo è MULTIPATH, ovvero salva i casi in cui due path diverse abbiano lo stesso peso, in modo da fare load balancing.</h6>
</div>
<div id="outline-container-org7fe2375" class="outline-6">
<h6 id="org7fe2375">Addirittura posso obbligare un pacchetto a passare attraverso uno specifico nodo, imbullonandolo nello header.</h6>
</div>
</div>
</div>
<div id="outline-container-org4e2c2a3" class="outline-4">
<h4 id="org4e2c2a3">Adesso immaginiamo di avere una topologia di nodi con due nodi, R1 ed R3, connessi ad una rete (ad esempio lan, ma qualunque) con netID rispettivamente 1 e 3, che contengono al loro interno uno degli host H1 e H3.</h4>
<div class="outline-text-4" id="text-org4e2c2a3">
</div>
<div id="outline-container-orgfb8fc9f" class="outline-5">
<h5 id="orgfb8fc9f">Ogni nodo contiene anche una tabella di adiacenze, in cui ad ogni nodo è associato il link che serve per raggiungerlo</h5>
</div>
<div id="outline-container-org6a1a9c1" class="outline-5">
<h5 id="org6a1a9c1">Queste reti si chiamano stub, ovvero reti foglia, e contengono una tabella a loro volta, in cui è salvata la coppia netID-nodo a cui è collegata.</h5>
<div class="outline-text-5" id="text-org6a1a9c1">
</div>
<div id="outline-container-orgb594973" class="outline-6">
<h6 id="orgb594973"><span class="todo TODO">TODO</span> Capire chi salva quali tabelle e in particolare chi tiene la netId table</h6>
</div>
<div id="outline-container-orged311ed" class="outline-6">
<h6 id="orged311ed">Ad esempio, nella rete con netId 1 c'è scritto che la 1 è raggiungibile direttamente e la 3 attraverso il nodo R3.</h6>
</div>
<div id="outline-container-org0507a53" class="outline-6">
<h6 id="org0507a53">Quando H1 manda un pacchetto a H3, traduce H3 in R3. Il router R1 manda verso R1 mandando sul router successivo secondo la sua routing table, in particolare sul link associato a quel router.</h6>
</div>
</div>
</div>
<div id="outline-container-org73978ad" class="outline-4">
<h4 id="org73978ad">OSPF ruota sicuramente sulla area 0, ovvero il backbone dello Autonomous System. All'area 0 sono collegate sotto-aree che per comunicare da loro devono necessariamente passare attraverso l'area 0. L'area 0 contiene dei border-router attraverso cui passa TUTTO il traffico, intra area ed extra area.</h4>
</div>
<div id="outline-container-org6a40b1d" class="outline-4">
<h4 id="org6a40b1d">Per mettere in comunicazione AS diversi, serve avere dei link che li collegano e i router fra essi utilizzano un altro protocollo, BGP.</h4>
</div>
</div>
<div id="outline-container-org3248d18" class="outline-3">
<h3 id="org3248d18">Per migliorare la efficienza e generare le tabelle di routing vengono messe in atto delle tecniche avanzate, fra cui centralizzare il calcolo dei cammini minimi. Un router specifico, chiamato Designated Router, che calcola i cammini minimi per tutte i nodi e gli rimanda le tabelle già calcolate.</h3>
<div class="outline-text-3" id="text-org3248d18">
</div>
<div id="outline-container-org087996a" class="outline-4">
<h4 id="org087996a">Si riduce un po' il traffico, ma si ha lo svantaggio di congestionare i link verso lo stesso, su cui convergono le comunicazioni.</h4>
</div>
<div id="outline-container-org5d88f61" class="outline-4">
<h4 id="org5d88f61">Ormai tutte le reti lo usano.</h4>
</div>
<div id="outline-container-org0ff55f6" class="outline-4">
<h4 id="org0ff55f6">Lo spunto di eleggere un designated router è stato preso tanto bene che invece di eleggere uno dei router, si è deciso di portarlo in cloud, inventando il Software Designed Network SDN.</h4>
<div class="outline-text-4" id="text-org0ff55f6">
</div>
<div id="outline-container-orgb8aa70e" class="outline-5">
<h5 id="orgb8aa70e">Nella gran parte dei casi quel router si trova su cloud.</h5>
</div>
<div id="outline-container-org770f256" class="outline-5">
<h5 id="org770f256">Tutto ciò è possibile perchè noi fin dall'inizio abbiamo stabilito che il piano di controllo, routing, è separato dal piano di dati, forwarding.</h5>
</div>
<div id="outline-container-org814f64a" class="outline-5">
<h5 id="org814f64a">Esiste un protocollo, Open Flow, che regola le comunicazioni con il Designated Router, anche cercando di risolvere problemi di sicurezza.</h5>
</div>
<div id="outline-container-orge166cb7" class="outline-5">
<h5 id="orge166cb7">A questo punto il flooding non esiste più, ma avviene una comunicazione punto punto con l'SDN o Designated Router.</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-orgda7d1eb" class="outline-2">
<h2 id="orgda7d1eb">Supponiamo di avere due macchina che ha uno strato applicativo, seguito da TCP, IP ecc&#x2026;, attaccata ad una rete IP.</h2>
<div class="outline-text-2" id="text-orgda7d1eb">
</div>
<div id="outline-container-orgc6d9e25" class="outline-3">
<h3 id="orgc6d9e25">Ora immaginiamo che una macchina in mezzo a queste macchine ci sia una rete non IP.</h3>
</div>
<div id="outline-container-orgb96e679" class="outline-3">
<h3 id="orgb96e679">La macchina centrale deve avere IP per riuscire a prendere i pacchetti e poi l'altro network per processarli correttamente. Poi andranno reinviati in IP</h3>
</div>
<div id="outline-container-org47e9877" class="outline-3">
<h3 id="org47e9877">Il TUNNELLING è il modo di gestire lo header durante il passaggio in quella macchina</h3>
</div>
<div id="outline-container-orgcd3a420" class="outline-3">
<h3 id="orgcd3a420">La soluzione banale è che l'intero pacchetto, compreso header, viene incapsulato e lo header dell'altro protocollo viene semplicemente aggiunto, per poi essere rimosso dopo</h3>
</div>
</div>
<div id="outline-container-orge3eaf51" class="outline-2">
<h2 id="orge3eaf51">TRANSPORT LAYER NUOVE LEZIONI</h2>
</div>
<div id="outline-container-org3edddd8" class="outline-2">
<h2 id="org3edddd8">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).</h2>
<div class="outline-text-2" id="text-org3edddd8">
</div>
<div id="outline-container-org16987d8" class="outline-3">
<h3 id="org16987d8">Offre dei servizi che abbiamo già visto nel data-link.</h3>
</div>
<div id="outline-container-org76a9343" class="outline-3">
<h3 id="org76a9343">Varie funzionalità possono essere attivate o disattivate.</h3>
</div>
<div id="outline-container-org1a21a51" class="outline-3">
<h3 id="org1a21a51">TCP e UDP sono ortogonali fra loro. La prima offre disponibilità, mentre la seconda è best-effort e non aggiunge nulla ai livelli superiori.</h3>
</div>
<div id="outline-container-org8f4eca4" class="outline-3">
<h3 id="org8f4eca4">A livello data-link, tra due porte di rete abbiamo una trasmissione può essere affidabile, avere controllo degli errori ecc.</h3>
<div class="outline-text-3" id="text-org8f4eca4">
</div>
<div id="outline-container-org37c38e5" class="outline-4">
<h4 id="org37c38e5">Quello che non è considerato a livello data-link è se qualcosa va perso a livello network.</h4>
<div class="outline-text-4" id="text-org37c38e5">
</div>
<div id="outline-container-org8029c73" class="outline-5">
<h5 id="org8029c73">Un esempio è che abbiamo il nostro host con il suo livello IP.</h5>
<div class="outline-text-5" id="text-org8029c73">
</div>
<div id="outline-container-org5ee070a" class="outline-6">
<h6 id="org5ee070a">Poi abbiamo tutti questi router intermedi con i loro livelli IP e un protocollo che li leghi (non ci interessa quale).</h6>
</div>
<div id="outline-container-org511a5fb" class="outline-6">
<h6 id="org511a5fb">In ogni nodo ci sono delle code di ricezione \(RX\) e di trasmissione \(RT\) che hanno una capacità limitata.</h6>
</div>
<div id="outline-container-org4471539" class="outline-6">
<h6 id="org4471539">Nonostante possiamo dare affidabilità al data-link, a questo livello IP, se il RT è in overflow, scarta un pacchetto e questo viene perso del tutto.</h6>
<div class="outline-text-6" id="text-org4471539">
</div>
<div id="outline-container-orga092b16" class="outline-7">
<h7 id="orga092b16">Nonostante ci sia una somma di link affidabili, questa non garantisca che tutta la comunicazione end-to-end sia affidabile.</h7>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org7db1462" class="outline-3">
<h3 id="org7db1462">In Transport viene riimplementata l'affidabilità in modo che quando un segmento venga perso, venga gestita la ritrasmissione.</h3>
<div class="outline-text-3" id="text-org7db1462">
</div>
<div id="outline-container-orgb278cbb" class="outline-4">
<h4 id="orgb278cbb">La trasmissione su cavo è molto affidabile e quindi l'affidabilità a livello data link è passata in secondo piano e diventa più importante quella su tratte più lunghe, con tutta la rete in mezzo, che coinvolgono i router di livello 3.</h4>
</div>
</div>
<div id="outline-container-orgb6e60f8" class="outline-3">
<h3 id="orgb6e60f8">Le unità base di comunicazione a livello 4 sono chiamate <b>messaggi</b> o <b>segmenti</b>.</h3>
</div>
<div id="outline-container-org8b78be0" class="outline-3">
<h3 id="org8b78be0">Il livello di trasporto ha anche un suo indirizzamento (naming) utilizzando le porte, che servono per identificare l'applicazione che sta utilizzando il collegamento di livello 4.</h3>
<div class="outline-text-3" id="text-org8b78be0">
</div>
<div id="outline-container-orgdf628fa" class="outline-4">
<h4 id="orgdf628fa">Mentre l'indirizzo IP serve per identificare l'host di rete</h4>
</div>
<div id="outline-container-org2e4de53" class="outline-4">
<h4 id="org2e4de53">Immaginiamo di avere un client ed un server con TCP o UDP a livello 4, IP sotto e poi una rete completamente trasparente.</h4>
<div class="outline-text-4" id="text-org2e4de53">
</div>
<div id="outline-container-org21f3f34" class="outline-5">
<h5 id="org21f3f34">Abbiamo poi delle applicazioni che comunicano, ad esempio app client e web server con db.</h5>
</div>
<div id="outline-container-org695f51d" class="outline-5">
<h5 id="org695f51d">Immaginiamo arrivi un pacchetto IP a livello server.</h5>
<div class="outline-text-5" id="text-org695f51d">
</div>
<div id="outline-container-orgb606275" class="outline-6">
<h6 id="orgb606275">Il server legge il suo header e con il suo destination address sa che è destinato a lui.</h6>
</div>
<div id="outline-container-orgb53fdbf" class="outline-6">
<h6 id="orgb53fdbf">Nello campo "protocol" ci sarà scritto se il pacchetto è da mandare ad IP o UDP.</h6>
</div>
<div id="outline-container-org37ba146" class="outline-6">
<h6 id="org37ba146">Le applicazioni ascoltano su una specifica porta (80 per http ecc.)</h6>
</div>
<div id="outline-container-org027c20a" class="outline-6">
<h6 id="org027c20a">TCP si chiede: a quale di queste operazioni appartiene questo segmento? in modo da smistarlo correttamente.</h6>
<div class="outline-text-6" id="text-org027c20a">
</div>
<div id="outline-container-org50d1a5f" class="outline-7">
<h7 id="org50d1a5f">Quindi l'IP address identifica tutto l'host, il PROTOCOL indica il protocollo di transport e la porta(?) indica l'applicazione specifica che usa i dati.</h7>
</div>
</div>
</div>
<div id="outline-container-orge6ed47c" class="outline-5">
<h5 id="orge6ed47c">Anche dal lato client, si parte dall'Application layer e si sceglie il corretto protocollo (TCP/UDP) da utilizzare.</h5>
<div class="outline-text-5" id="text-orge6ed47c">
</div>
<div id="outline-container-org3648eae" class="outline-6">
<h6 id="org3648eae">Quindi l'IP e il protocollo da utilizzare sono informazioni necessarie per aprire la comunicazione.</h6>
</div>
</div>
</div>
<div id="outline-container-org8d99b0a" class="outline-4">
<h4 id="org8d99b0a">A livello di Trasporto si usano le socket.</h4>
<div class="outline-text-4" id="text-org8d99b0a">
</div>
<div id="outline-container-org1f0cddb" class="outline-5">
<h5 id="org1f0cddb">Una socket è fatta così (stessa dell'immagine sul libro):</h5>
<div class="outline-text-5" id="text-org1f0cddb">
</div>
<div id="outline-container-orge047a10" class="outline-6">
<h6 id="orge047a10">Abbiamo un ClientAP e un ServerAP (access point), che noi richiediamo semplicemente e sono offerte dal sistema operativo.</h6>
</div>
<div id="outline-container-org4682d89" class="outline-6">
<h6 id="org4682d89">Fra i due AP abbiamo una transport entity</h6>
</div>
<div id="outline-container-org96a8729" class="outline-6">
<h6 id="org96a8729">Ogni applicazione contiene due buffer che sono RecevingBuffer e SendingBuffer.</h6>
</div>
<div id="outline-container-org220ab9e" class="outline-6">
<h6 id="org220ab9e">Le socket berkeley sono lo standard de facto, di Unix, che non è altro che un descrittore di file su cui si può effettuare scrittura e lettura.</h6>
<div class="outline-text-6" id="text-org220ab9e">
</div>
<div id="outline-container-org94975e7" class="outline-7">
<h7 id="org94975e7">Una write scrive sull'SB e la read sull'RB</h7>
</div>
</div>
<div id="outline-container-orga5c2cf8" class="outline-6">
<h6 id="orga5c2cf8">Poi abbiamo un istanza del protocollo TCP che se vede che va tutto bene (poi vedremo cosa vuol dire), prende carico dei dati e li trasmette in rete.</h6>
</div>
<div id="outline-container-org50561e9" class="outline-6">
<h6 id="org50561e9">C'è poi un altro livello di buffer, uno per ingresso e uno per uscita, aree di memoria temporanee che TCP riserva per tenere temporaneamente i pezzi di unità di informazione che devono essere ancora trasmessi.</h6>
<div class="outline-text-6" id="text-org50561e9">
</div>
<div id="outline-container-orgb75fde7" class="outline-7">
<h7 id="orgb75fde7">TCP lavora a stream di byte e c'è un ordinamento assoluto di essi e va garantito che il ricevitore le riceva nello stesso ordine.</h7>
</div>
<div id="outline-container-org77703c9" class="outline-7">
<h7 id="org77703c9">Immaginiamo ad esempio di inviare 1, 2 e 3 e che 2 venga perso.</h7>
</div>
<div id="outline-container-orga27fad7" class="outline-7">
<h7 id="orga27fad7">Dopo aver ricevuto il 3, il TCP lato client si rende conto che manca qualcosa.</h7>
</div>
<div id="outline-container-org3da9cb5" class="outline-7">
<h7 id="org3da9cb5">Il blocchetto 3 rimane temporaneamente in buffer e quando il blocchetto 2 arriva a destinazione, verrà sbloccato anche il successivo.</h7>
</div>
<div id="outline-container-orga6ec256" class="outline-7">
<h7 id="orga6ec256">Il buffer tcp d'uscita serve invece per tenere gli stream da mandare fino alla ricezione di un ACK.</h7>
</div>
</div>
<div id="outline-container-orge39458c" class="outline-6">
<h6 id="orge39458c">Adesso, la velocità di lettura e scrittura sono diverse fra loro, diventa necessario mettere un buffer al centro.</h6>
<div class="outline-text-6" id="text-orge39458c">
</div>
<div id="outline-container-orgb9a5593" class="outline-7">
<h7 id="orgb9a5593">Se una macchina genera in modo troppo veloce e l'altra troppo lenta, chiederà di rallentare la trasmissione.</h7>
</div>
<div id="outline-container-org5ceaf8d" class="outline-7">
<h7 id="org5ceaf8d">Siamo a livello kernel e non abbiamo tanta memoria.</h7>
<div class="outline-text-7" id="text-org5ceaf8d">
</div>
<div id="outline-container-orge9c3d2f" class="outline-8">
<h8 id="orge9c3d2f">Se non mettessimo un limite alla memoria, i buffer si saturerebbero e non rispetteremmo le specifiche di TCP che ci offre la totale affidabilità nella trasmissione.</h8>
</div>
</div>
</div>
</div>
<div id="outline-container-org281533f" class="outline-5">
<h5 id="org281533f">Con le socket si interagisce in questo modo, ovvero le API da utilizzare sono:</h5>
<div class="outline-text-5" id="text-org281533f">
</div>
<div id="outline-container-org3b91f28" class="outline-6">
<h6 id="org3b91f28">Abbiamo ancora i due access point client e server che si interfacciano con il TCP/UDP.</h6>
<div class="outline-text-6" id="text-org3b91f28">
</div>
<div id="outline-container-org9e1273e" class="outline-7">
<h7 id="org9e1273e">Il livello 7 (application) è implementato nello user space.</h7>
</div>
<div id="outline-container-org0b265c2" class="outline-7">
<h7 id="org0b265c2">Il livello 4 è implementato nel kernel, quindi nel sistema operativo.</h7>
</div>
<div id="outline-container-orgca0a34c" class="outline-7">
<h7 id="orgca0a34c">Il livello 3 anche</h7>
</div>
<div id="outline-container-orge886396" class="outline-7">
<h7 id="orge886396">Il livello 2 sulla scheda di rete, quindi a livello firmware</h7>
</div>
<div id="outline-container-org2e6fc47" class="outline-7">
<h7 id="org2e6fc47">Il livello 1 è il cavo.</h7>
</div>
</div>
<div id="outline-container-org5772987" class="outline-6">
<h6 id="org5772987">Nel server, ci sono:</h6>
<div class="outline-text-6" id="text-org5772987">
</div>
<div id="outline-container-orgf018546" class="outline-7">
<h7 id="orgf018546">Una prima chiamata, bidirezionale, è <code>socket()</code>. Questa restituisce un descrittore di file aperto e bidirezionale, ovvero su cui si può leggere e scrivere.</h7>
</div>
<div id="outline-container-orge6930b4" class="outline-7">
<h7 id="orge6930b4">Poi c'è l'operazione di <code>bind()</code> a cui passiamo un indirizzo IP e una porta, che lega la socket a un indirizzo IP (0.0.0.0 se ascolti su tutti gli IP della macchina). O conosciamo l'IP o utilizziamo un indirizzo DNS e la porta o la sappiamo già o è una porta well-known, come 80 o 8080 per HTTP, 443 e 8443 per HTTPS, ssh sulla 22, DNS sulla 53UDP.</h7>
</div>
<div id="outline-container-orgc5faa1c" class="outline-7">
<h7 id="orgc5faa1c">Poi abbiamo <code>listen()</code> che dice alla socket di mettersi in ascolto sull'indirizzo indicato al <code>bind()</code>. Crea inoltre una coda di richieste.</h7>
<div class="outline-text-7" id="text-orgc5faa1c">
</div>
<div id="outline-container-orgad3ed85" class="outline-8">
<h8 id="orgad3ed85">Anche qua, questa coda è finita e se arriva un bombardamento di richieste ovviamente il buffer si riempie e le successive richieste non saranno più gestite.</h8>
</div>
</div>
<div id="outline-container-orgcbade44" class="outline-7">
<h7 id="orgcbade44">L'ultima chiamata è la <code>accept()</code>. Questa si blocca in attesa di una richiesta. Quindi è una richiesta bloccante. Aspetta che qualcuno arrivi per aprire una connessione.</h7>
</div>
<div id="outline-container-org195f3e7" class="outline-7">
<h7 id="org195f3e7">A questo punto, TCP non è ancora intervenuto ma ha stabilito tutte le parti necessarie per ottenere una comunicazione</h7>
</div>
</div>
<div id="outline-container-orga340f78" class="outline-6">
<h6 id="orga340f78">Nel client ci sono:</h6>
<div class="outline-text-6" id="text-orga340f78">
</div>
<div id="outline-container-org3f3c245" class="outline-7">
<h7 id="org3f3c245"><code>socket</code> come prima</h7>
</div>
<div id="outline-container-orge74b90b" class="outline-7">
<h7 id="orge74b90b"><code>connect()</code>, bloccante, in cui, come nella <code>bind()</code> specifichiamo un IP e una porta per recapitare correttamente un messaggio.</h7>
<div class="outline-text-7" id="text-orge74b90b">
</div>
<div id="outline-container-orgf3ed9be" class="outline-8">
<h8 id="orgf3ed9be">Questa connect scatena un'apertura di connessione, (o il recapito di un messaggio in UDP), che sblocca il server attraverso la unlock, fa una <code>fork</code> che da luogo ad una nuova <code>socket()</code>, che effettuerà una nuova <code>bind()</code>.</h8>
</div>
<div id="outline-container-org44d8963" class="outline-8">
<h8 id="org44d8963">Solo a questo punto viene tirata su la struttura del TCP con i 4 buffer.</h8>
</div>
<div id="outline-container-org9ab46da" class="outline-8">
<h8 id="org9ab46da">Quando viene effettuata la prima chiamata <code>socket</code> nel server, viene creata solo la coda di richieste.</h8>
</div>
<div id="outline-container-orga831c54" class="outline-8">
<h8 id="orga831c54">Solo la seconda chiamata tira su tutto il sistema TCP indicato prima</h8>
</div>
<div id="outline-container-org7d9af1a" class="outline-8">
<h8 id="org7d9af1a">La porta della sorgente è scelta randomicamente.</h8>
</div>
</div>
<div id="outline-container-org920211e" class="outline-7">
<h7 id="org920211e">Alla ricezione dell'ok della socket pronta dall'altra parte, si sblocca anche il client e da lì in poi la comunicazione è aperta e si possono utilizzare le system call tipiche dei file, ovvero <code>send()</code> e <code>receive()</code></h7>
</div>
</div>
<div id="outline-container-orgbfc9cc6" class="outline-6">
<h6 id="orgbfc9cc6">Quando voglio chiudere, una delle due chiama una <code>close()</code></h6>
<div class="outline-text-6" id="text-orgbfc9cc6">
</div>
<div id="outline-container-org924038a" class="outline-7">
<h7 id="org924038a">Questa chiusura coinvolge anche l'entità TCP, ma finora abbiamo soltanto osservato TCP dall'esterno.</h7>
</div>
</div>
<div id="outline-container-orgd682439" class="outline-6">
<h6 id="orgd682439">Con la quintupla [protocol, ipsrc, ipdst, portsrc, portdst] posso identificare la singola comunicazione che è stata tirata su dopo la serie di procedure appena indicata.</h6>
</div>
</div>
</div>
<div id="outline-container-org1ebb98e" class="outline-4">
<h4 id="org1ebb98e">Il TCP garantisce che la comunicazione sia <b>affidabile</b> e <b>ordinata</b>.</h4>
<div class="outline-text-4" id="text-org1ebb98e">
</div>
<div id="outline-container-org4eb9892" class="outline-5">
<h5 id="org4eb9892">Opera inoltre un controllo di flusso, ovvero un controllo orizzontale, con un app sorgente che scrive e una dest che legge, entrambe ad un certo rate, in modo che non ci sia overflow.</h5>
<div class="outline-text-5" id="text-org4eb9892">
</div>
<div id="outline-container-org7c1bd59" class="outline-6">
<h6 id="org7c1bd59">Questo avviene basandosi sul rate minore.</h6>
</div>
</div>
<div id="outline-container-org9f6cced" class="outline-5">
<h5 id="org9f6cced">Opera poi un controllo errori.</h5>
<div class="outline-text-5" id="text-org9f6cced">
</div>
<div id="outline-container-org1e865b8" class="outline-6">
<h6 id="org1e865b8">Mentre UDP avverte in caso di errori, TCP si occupa anche di risolverli, gestendo la ritrasmissione.</h6>
</div>
</div>
<div id="outline-container-org2f20f13" class="outline-5">
<h5 id="org2f20f13">Opera poi un controllo di congestione, questa volta verticale.</h5>
<div class="outline-text-5" id="text-org2f20f13">
</div>
<div id="outline-container-org374de05" class="outline-6">
<h6 id="org374de05">E' vero che TCP nasconde la rete sottostante, ma sa che c'è una rete e sa che questa è potenzialmente inaffidabile.</h6>
</div>
<div id="outline-container-orgf751188" class="outline-6">
<h6 id="orgf751188">Sa che se vengono immessi troppi pacchetti su una rete, questa possa essere congestionata.</h6>
</div>
<div id="outline-container-orgdf96212" class="outline-6">
<h6 id="orgdf96212">TCP prova ad intuire la congestione della rete e prevenire la perdita di pacchetti della rete, diminuendo il rate di trasmissione di questi ultimi.</h6>
</div>
</div>
<div id="outline-container-org2097b4d" class="outline-5">
<h5 id="org2097b4d">Inoltre, è orientata allo stream.</h5>
<div class="outline-text-5" id="text-org2097b4d">
</div>
<div id="outline-container-org280b599" class="outline-6">
<h6 id="org280b599">Il concetto su cui lavora è dello stream di byte, che devono arrivare tutti.</h6>
</div>
</div>
<div id="outline-container-org5024442" class="outline-5">
<h5 id="org5024442">Poi, è orientato alla connessione.</h5>
<div class="outline-text-5" id="text-org5024442">
</div>
<div id="outline-container-orgc83666d" class="outline-6">
<h6 id="orgc83666d">Prima di utilizzare le socket, leggervi e scrivervi, dobbiamo instaurare una connessione, aprendola, che mantiene un certo stato.</h6>
<div class="outline-text-6" id="text-orgc83666d">
</div>
<div id="outline-container-orga35583f" class="outline-7">
<h7 id="orga35583f">Il drawback è che è necessario tenere lo stato e tutte le info per la connessione in memoria nel kernel, e dev'essere occupato durante tutta la comunicazione.</h7>
</div>
</div>
</div>
</div>
<div id="outline-container-org72cc359" class="outline-4">
<h4 id="org72cc359">Lo header TCP è rappresentato in pagine larghe 32 bit.</h4>
<div class="outline-text-4" id="text-org72cc359">
</div>
<div id="outline-container-org366f059" class="outline-5">
<h5 id="org366f059">Alla prima riga abbiamo 16 bit per porta sorgente e 16 per la destinazione</h5>
</div>
<div id="outline-container-orgf494994" class="outline-5">
<h5 id="orgf494994">Alla seconda riga abbiamo i 32 bit per il numero di sequenza</h5>
<div class="outline-text-5" id="text-orgf494994">
</div>
<div id="outline-container-orge8f11f2" class="outline-6">
<h6 id="orge8f11f2">Il numero di sequenza indica il primo byte della lunghezza variabile di byte che compone il segmento.</h6>
</div>
<div id="outline-container-orge2fac03" class="outline-6">
<h6 id="orge2fac03">Viene inizializzato al momento dell'istanziamento della connessione.</h6>
</div>
</div>
<div id="outline-container-org28faaf4" class="outline-5">
<h5 id="org28faaf4">Poi abbiamo il campo ACK number, strettamente legato al precedente.</h5>
<div class="outline-text-5" id="text-org28faaf4">
</div>
<div id="outline-container-org3d7b6eb" class="outline-6">
<h6 id="org3d7b6eb">Identifica il numero di byte che la destinazione di questa connessione ha correttamente ricevuto e qual è l'indice del prossimo byte che mi aspetto.</h6>
</div>
<div id="outline-container-orgdebbc30" class="outline-6">
<h6 id="orgdebbc30">I due campi superiori vengono utilizzati per gestire i casi in cui ci sia una perdita di segmenti e gestire correttamente la trasmissione.</h6>
</div>
</div>
<div id="outline-container-orgdbcec34" class="outline-5">
<h5 id="orgdbcec34">Nella terza pagina abbiamo:</h5>
<div class="outline-text-5" id="text-orgdbcec34">
</div>
<div id="outline-container-org94a366d" class="outline-6">
<h6 id="org94a366d">Poi c'è il campo TCP Header Length da 4 bit</h6>
<div class="outline-text-6" id="text-org94a366d">
</div>
<div id="outline-container-org71b55f4" class="outline-7">
<h7 id="org71b55f4">La dimensione dell'header è variabile, sebbene esista una lunghezza solitamente usata.</h7>
</div>
</div>
<div id="outline-container-org5a1d2d3" class="outline-6">
<h6 id="org5a1d2d3">Poi 4 bit non utilizzati</h6>
</div>
<div id="outline-container-orge6b1499" class="outline-6">
<h6 id="orge6b1499">Poi c'è una serie di 8 bit di controllo</h6>
<div class="outline-text-6" id="text-orge6b1499">
</div>
<div id="outline-container-org75dbfe9" class="outline-7">
<h7 id="org75dbfe9">Prima il CWR, Congestion Window Reduced, che serve alla rete congestionata per notificare la situazione</h7>
</div>
<div id="outline-container-org0f2ea42" class="outline-7">
<h7 id="org0f2ea42">Poi lo ECE, &#x2026;. echo.</h7>
<div class="outline-text-7" id="text-org0f2ea42">
</div>
<div id="outline-container-org0aa8a33" class="outline-8">
<h8 id="org0aa8a33">Solo i due superiori sono presenti sul Tanenbaum ma non sull'Halsall</h8>
</div>
</div>
<div id="outline-container-org6b38581" class="outline-7">
<h7 id="org6b38581">Poi c'è un bit URGent, per indicare che certi dati sono urgenti e devono essere processati ASAP, superando l'ordinamento solito.</h7>
</div>
<div id="outline-container-org3b1b6dc" class="outline-7">
<h7 id="org3b1b6dc">Poi c'è il campo ACK</h7>
</div>
<div id="outline-container-org2410174" class="outline-7">
<h7 id="org2410174">Poi PUSH, che serve per mandaare via i dati contenuti nel buffer della socket.</h7>
<div class="outline-text-7" id="text-org2410174">
</div>
<div id="outline-container-org83e8b2a" class="outline-8">
<h8 id="org83e8b2a">Ad esempio, immaginiamo che stiamo mandando dei dati e scrivendo nel SendingBuffer.</h8>
</div>
<div id="outline-container-orgbe23d97" class="outline-8">
<h8 id="orgbe23d97">Il TCP riempie un segmento di una certa dimensione e poi lo manda quando ha una certa dimensione.</h8>
</div>
<div id="outline-container-org21deb82" class="outline-8">
<h8 id="org21deb82">In alcuni casi, può essere necessario che tutti i dati vengano salvati immediatamente</h8>
</div>
<div id="outline-container-orga8a7c50" class="outline-8">
<h8 id="orga8a7c50">La differenza con lo urgent è che in questo caso il valore viene mandato da solo ma rispettando l'ordine.</h8>
</div>
</div>
<div id="outline-container-orgf027d5c" class="outline-7">
<h7 id="orgf027d5c">Poi ci sono RST, SYN e FIN che non ho ascoltato. Reset, sincronizzazione e chiudi connessione.</h7>
</div>
</div>
<div id="outline-container-org4ae4aa4" class="outline-6">
<h6 id="org4ae4aa4">I restanti 16 bit di Window Size indicano lo spazio ancora disponibile nel ricevitore.</h6>
<div class="outline-text-6" id="text-org4ae4aa4">
</div>
<div id="outline-container-org146da1d" class="outline-7">
<h7 id="org146da1d">Chi sta trasmettendo, leggendo questo campo può capire se l'altra macchina sostiene il rate o deve rallentare.</h7>
</div>
</div>
</div>
<div id="outline-container-org21e6425" class="outline-5">
<h5 id="org21e6425">Nella quarta pagina:</h5>
<div class="outline-text-5" id="text-org21e6425">
</div>
<div id="outline-container-orgf58c69d" class="outline-6">
<h6 id="orgf58c69d">Un checksum a 16 bit, che poi vedremo come viene calcolato, che ci permette di capire se tutto è corretto e viene collegato sulla base dello pseudoheader e tiene anche conto della conformità del payload (controllo degli errori)</h6>
<div class="outline-text-6" id="text-orgf58c69d">
</div>
<div id="outline-container-org131bb25" class="outline-7">
<h7 id="org131bb25">Lo pseudoheader è una versione ridotta dello header.</h7>
</div>
</div>
<div id="outline-container-org2cdb64f" class="outline-6">
<h6 id="org2cdb64f">Poi uno Urgent Pointer, che viene letto se e solo se il frame urgent è a 1, altrimenti non ce ne frega perchè viene trascurato.</h6>
<div class="outline-text-6" id="text-org2cdb64f">
</div>
<div id="outline-container-org935e9b7" class="outline-7">
<h7 id="org935e9b7">Indica l'offset all'interno del campo data oltre il quale i dati sono urgent.</h7>
</div>
<div id="outline-container-orgc84c6d2" class="outline-7">
<h7 id="orgc84c6d2">Per convenzione, i dati urgent vengono messi alla fine del segmento e quindi non spazio per la fine della parte urgente.</h7>
</div>
</div>
</div>
<div id="outline-container-org608b1b3" class="outline-5">
<h5 id="org608b1b3">Dopodichè abbiamo le options, parole di 16 bit di cui può esserci un numero variabile.</h5>
</div>
<div id="outline-container-orgf134439" class="outline-5">
<h5 id="orgf134439">Dopo le n options, c'è il payload.</h5>
</div>
</div>
<div id="outline-container-org231cfb4" class="outline-4">
<h4 id="org231cfb4">Come si diceva, TCP è orientato alla connessione.</h4>
<div class="outline-text-4" id="text-org231cfb4">
</div>
<div id="outline-container-org5527702" class="outline-5">
<h5 id="org5527702">La connessione è bidirezionale, ma noi analizzeremo solo un lato della connessione, perchè analizzare entrambe sarebbe molto confuso.</h5>
<div class="outline-text-5" id="text-org5527702">
</div>
<div id="outline-container-orgd7a3a1e" class="outline-6">
<h6 id="orgd7a3a1e">Ognuno trasmette e riceve in modo di indipendente. Quindi la sequence e lo ACK sono relativi solo ad una direzione della connessione.</h6>
</div>
</div>
<div id="outline-container-orge93f944" class="outline-5">
<h5 id="orge93f944">All'apertura della connessione, da entrambe le macchine viene generato un sequence number ISN casuale, per ragioni di sicurezza</h5>
<div class="outline-text-5" id="text-orge93f944">
</div>
<div id="outline-container-orgaf0e093" class="outline-6">
<h6 id="orgaf0e093">Altrimenti si potrebbe indovinare un numero ed inserirsi nella connessione</h6>
</div>
<div id="outline-container-orgb4e13a1" class="outline-6">
<h6 id="orgb4e13a1">I due flussi, e quindi i due numeri di sequenza, sono indipendenti.</h6>
</div>
</div>
<div id="outline-container-orgcc0fa6d" class="outline-5">
<h5 id="orgcc0fa6d">A chiede di aprire una connessione e manda un segmento con il frame SYN = 1 e il Seq = X (quello generato casualmente da A).</h5>
</div>
<div id="outline-container-orgd05f642" class="outline-5">
<h5 id="orgd05f642">B riceve il segmento e ne manda uno di risposta in cui SYN = 1, ACK = 1, Seq = Y (quello generato casualmente da B) e Ack = x + 1.</h5>
<div class="outline-text-5" id="text-orgd05f642">
</div>
<div id="outline-container-org1667949" class="outline-6">
<h6 id="org1667949">Il bit di ACK attivato indica che il valore in Ack è significativo è può essere letto.</h6>
</div>
<div id="outline-container-org33fe6f3" class="outline-6">
<h6 id="org33fe6f3">Lo ack a x+1 indica che si è pronti ad andare avanti con la trasmissione. Il primo segmento parte da x ed è lungo 1, quindi il prossimo che sono pronto ad ascoltare è il successivo.</h6>
</div>
</div>
<div id="outline-container-orga43f893" class="outline-5">
<h5 id="orga43f893">A riceve il segmento e risponde con ACK=1 e Ack = y+1</h5>
</div>
<div id="outline-container-orgc871f10" class="outline-5">
<h5 id="orgc871f10">In tutti i 3 segmenti superiori, il valore del resto dello header e payload non importano.</h5>
</div>
<div id="outline-container-org796aee0" class="outline-5">
<h5 id="org796aee0">La procedura prende il nome di three-way handshake.</h5>
</div>
<div id="outline-container-org64accaf" class="outline-5">
<h5 id="org64accaf">Gestione casi delicati</h5>
<div class="outline-text-5" id="text-org64accaf">
</div>
<div id="outline-container-orge082c68" class="outline-6">
<h6 id="orge082c68">Viene introdotto un Timer, RTO, che gestisce il caso in cui uno fra i primi due segmenti di handshake vengano persi.</h6>
<div class="outline-text-6" id="text-orge082c68">
</div>
<div id="outline-container-org720b357" class="outline-7">
<h7 id="org720b357">Come nel data link, se il timer scade perchè uno qualunque dei primi frame è scomparso, si prova ad aprire nuovamente la connessione.</h7>
</div>
</div>
<div id="outline-container-orga2ee710" class="outline-6">
<h6 id="orga2ee710">Il timer gestisce anche i casi in cui l'handshake di risposta ci impieghi troppo ad arrivare ( o si può dire che dopo il tempo \(T\) si assuma che la connessione è persa e bisogna gestire il caso in cui la risposta invece arrivi)</h6>
<div class="outline-text-6" id="text-orga2ee710">
</div>
<div id="outline-container-org585ecc0" class="outline-7">
<h7 id="org585ecc0">Ogni nuova riapertura aggiorna il SEQ casuale</h7>
</div>
<div id="outline-container-orgb482d36" class="outline-7">
<h7 id="orgb482d36">Se arriva una risposta per un apertura precedente, è facile dal numero di sequenza capire che non sia la risposta corretta</h7>
</div>
<div id="outline-container-org2659b63" class="outline-7">
<h7 id="org2659b63">In tal caso, si manda un messaggio con RST e si chiude la connessione.</h7>
</div>
</div>
</div>
<div id="outline-container-orgf9a5e4f" class="outline-5">
<h5 id="orgf9a5e4f">Utilizzando lo stesso concetto di base del port scanning, si può fare SYN FLOOD.</h5>
<div class="outline-text-5" id="text-orgf9a5e4f">
</div>
<div id="outline-container-org79f6e8a" class="outline-6">
<h6 id="org79f6e8a">Mando tanti messaggi di SYN sulle varie porte.</h6>
</div>
<div id="outline-container-org3d98af6" class="outline-6">
<h6 id="org3d98af6">Il server mi risponde genuinamente e attende per la mia 3 risposta, finale, di handshake.</h6>
</div>
<div id="outline-container-orgdcfee01" class="outline-6">
<h6 id="orgdcfee01">Io non rispondo e il server deve allocare risorse per tanti syn aperti contemporaneamente.</h6>
</div>
<div id="outline-container-orge68b5d4" class="outline-6">
<h6 id="orge68b5d4">Se invece rispondo con un RST, non effettuo un attacco e non peso sulle risorse, ma analizzo soltanto le porte aperte.</h6>
<div class="outline-text-6" id="text-orge68b5d4">
<p>
lesgoski
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfca29ed" class="outline-2">
<h2 id="orgfca29ed">Quindi siamo arrivati al SYN che uno manda per aprire la connessione, con un numero di sequenza generato in numero casuale. Il canale è bidirezionale e quindi avviene tutto nello stesso modo in entrambi gli host.</h2>
<div class="outline-text-2" id="text-orgfca29ed">
</div>
<div id="outline-container-org2c16f37" class="outline-3">
<h3 id="org2c16f37">Il SYN parte a 1, in risposta il SYN è a uno e anche l'ACK, che indica che il campo Ack è significativo e tale campo è numDiSequenza +1, per indicare che quello è il prossimo bit che si è pronti a ricevere.</h3>
<div class="outline-text-3" id="text-org2c16f37">
</div>
<div id="outline-container-org91460ba" class="outline-4">
<h4 id="org91460ba">Ovviamente manda anche il proprio numero di sequenza.</h4>
</div>
</div>
<div id="outline-container-org50cde1f" class="outline-3">
<h3 id="org50cde1f">Se tutto va a buon fine, la terza risposta dal sender è uguale alla seconda dal receiver e da lì in poi la connessione è aperta.</h3>
</div>
<div id="outline-container-org331e1bc" class="outline-3">
<h3 id="org331e1bc">C'è un timer che garantisce che se l'ACK viene perso, o impiega troppo tempo ad arrivare, venga mandato un messaggio con RESET a 1 che annulla l'handshake, che va rieffettuato</h3>
<div class="outline-text-3" id="text-org331e1bc">
<pre class="example" id="org00becf2">
Let me explain why starting sequence numbers in the Transport layer are random:

    Security: Random initial sequence numbers help prevent TCP sequence prediction attacks. If sequence numbers were predictable, attackers could potentially hijack TCP connections by guessing the next sequence number.

    Connection Uniqueness: Random sequence numbers reduce the likelihood of old segments from previous connections being mistakenly accepted as valid in new connections between the same endpoints.

    Prevents Segment Mix-up: If multiple connections are established between the same hosts, random sequence numbers help ensure segments from different connections don't get mixed up.

    Protection against Spoofing: Random initial sequence numbers make it harder for attackers to inject fake segments into an existing connection since they would need to guess the correct sequence number.

    Avoids Overlap: In case of delayed segments from previous connections, random sequence numbers help prevent confusion between old and new data streams.

This randomization is a crucial security measure in modern TCP implementations and helps maintain the integrity and reliability of network communications.
</pre>
</div>
</div>
<div id="outline-container-orgdf5a725" class="outline-3">
<h3 id="orgdf5a725">In ogni header è indicato il Max Segment Size, che indica la dimensione massima di segmento che l'host può gestire senza andare in overflow.</h3>
<div class="outline-text-3" id="text-orgdf5a725">
</div>
<div id="outline-container-org8daff48" class="outline-4">
<h4 id="org8daff48">La dimensione Standard, quando il campo è vuoto, il segmento è di 536 byte.</h4>
</div>
</div>
<div id="outline-container-org60a393f" class="outline-3">
<h3 id="org60a393f">L'obiettivo di TCP è trasferire i dati nel miglior modo, garantendo affidabilità, gest.errori, ordine ecc., e anche farlo in modo efficiente, evitando un overhead eccessivo</h3>
</div>
<div id="outline-container-org75dd47a" class="outline-3">
<h3 id="org75dd47a">Il motivo per cui viene scelta 536 byte è che siamo sicuri che il livello IP non frammenterà tale segmento in più pacchetti.</h3>
<div class="outline-text-3" id="text-org75dd47a">
</div>
<div id="outline-container-org19494b3" class="outline-4">
<h4 id="org19494b3">Per ogni frammentazione effettuata dall'IP, serve copiare sia header TCP che IP, introducendo overhead.</h4>
</div>
<div id="outline-container-orgc1d2fdb" class="outline-4">
<h4 id="orgc1d2fdb">Inoltre, essendo la rete best-effort, quanti più sotto-segmenti vengono mandati quanto più è probabile che avvengano dei problemi che dovranno essere poi gestiti</h4>
</div>
</div>
<div id="outline-container-org7a93b65" class="outline-3">
<h3 id="org7a93b65">Immaginiamo di avere una connessione A-B in TCP, necessariamente bidirezionale.</h3>
<div class="outline-text-3" id="text-org7a93b65">
</div>
<div id="outline-container-orga0aef7c" class="outline-4">
<h4 id="orga0aef7c">Dato che noi analizziamo solo i casi "unidirezionali", noi valutiamo solo SendingBuffer e TcpSendingBuffer nel sender, e i corrispondenti ma per il receiver nel receiver.</h4>
</div>
<div id="outline-container-orgd685284" class="outline-4">
<h4 id="orgd685284">Assumiamo che la segment size sia 500.</h4>
</div>
<div id="outline-container-org25298f6" class="outline-4">
<h4 id="org25298f6">L'applicazione lato sender scrive 2000 byte nell'SB della socket esposto.</h4>
</div>
<div id="outline-container-org145e1a5" class="outline-4">
<h4 id="org145e1a5">Ovviamente, va eseguita una frammentazione a livello trasporto.</h4>
<div class="outline-text-4" id="text-org145e1a5">
</div>
<div id="outline-container-orgef72f07" class="outline-5">
<h5 id="orgef72f07">Assumiamo per ora che non avvengano problemi nella trasmissione.</h5>
</div>
</div>
<div id="outline-container-orgc5fd3b1" class="outline-4">
<h4 id="orgc5fd3b1">Nel sending buffer della TCP, nascosto al livello applicazione, vengono copiati e segmentati opportunamente i byte del buffer superiore.</h4>
</div>
<div id="outline-container-org142d680" class="outline-4">
<h4 id="org142d680">Nello header è presente l'informazione SEQ=X. Il payload sarà dal byte X a quello X + 499</h4>
<div class="outline-text-4" id="text-org142d680">
</div>
<div id="outline-container-orge8d44f1" class="outline-5">
<h5 id="orge8d44f1">X è in realtà X+1 se la connessione è appena stata instaurata, ma per semplicità si considera X il valore corrente.</h5>
</div>
</div>
<div id="outline-container-orgd771a2a" class="outline-4">
<h4 id="orgd771a2a">Nel frattempo, il receiver si aspettava il Sequence Number = X e così si accerta che l'ordine sia corretto.</h4>
</div>
<div id="outline-container-org9cf0370" class="outline-4">
<h4 id="org9cf0370">I dati arrivano nel buffer inferiore, ma dato che l'ordine è corretto, vengono subito copiati nel buffer superiore.</h4>
</div>
<div id="outline-container-orge26a815" class="outline-4">
<h4 id="orge26a815">Lo header risposta del receiving buffer contiene il campo ACK a 1 e quello Ack a X + 500, che è il primo byte successivo a quello ricevuto.</h4>
<div class="outline-text-4" id="text-orge26a815">
</div>
<div id="outline-container-org4972a9a" class="outline-5">
<h5 id="org4972a9a">Implicitamente vuol dire che il segmento precedente è correttamente ricevuto.</h5>
</div>
</div>
<div id="outline-container-orgc5bf764" class="outline-4">
<h4 id="orgc5bf764">Il sender elimina dal buffer del TCP il segmento corrispondente.</h4>
</div>
<div id="outline-container-orgf58968e" class="outline-4">
<h4 id="orgf58968e">Allora, il prossimo segmento mandato è quello che parte da X+500 e questo valore è nel SEQ dello header.</h4>
</div>
<div id="outline-container-orgfb83806" class="outline-4">
<h4 id="orgfb83806">Anche questo pacchetto è in ordine e quindi va subito spostato nel buffer superiore.</h4>
<div class="outline-text-4" id="text-orgfb83806">
</div>
<div id="outline-container-org488b6d5" class="outline-5">
<h5 id="org488b6d5">Il TCP tiene tutti i segmenti non in ordine nel buffer inferiore.</h5>
</div>
<div id="outline-container-orge08dd9d" class="outline-5">
<h5 id="orge08dd9d">Ogni segmento correttamente ricevuto, ma successivo ad un segmento non ricevuto, rimane nel buffer inferiore.</h5>
</div>
</div>
<div id="outline-container-org8a39074" class="outline-4">
<h4 id="org8a39074">Analogamente al messaggio precedente, il receiver risponde con un Ack = X+1000.</h4>
<div class="outline-text-4" id="text-org8a39074">
</div>
<div id="outline-container-orgf9ce911" class="outline-5">
<h5 id="orgf9ce911">Anche adesso, il sender si libera del segmento.</h5>
</div>
</div>
<div id="outline-container-orga70d403" class="outline-4">
<h4 id="orga70d403">Procedo così fino allo svuotamento del buffer di invio.</h4>
</div>
</div>
<div id="outline-container-org47be07b" class="outline-3">
<h3 id="org47be07b">Nella configurazione precedente, c'è un problema nel caso in cui ho bisogno di (real-time?) ad esempio ssh su una console remota.</h3>
<div class="outline-text-3" id="text-org47be07b">
</div>
<div id="outline-container-org6a66ce7" class="outline-4">
<h4 id="org6a66ce7">Voglio che i dati vengano processati byte per byte</h4>
</div>
<div id="outline-container-org7bbb9b5" class="outline-4">
<h4 id="org7bbb9b5">Allora uso la flag PUSH, in modo che TCP spedisca il singolo byte, senza arrivare ad una dimensione del segmento di 500 byte come prima</h4>
</div>
<div id="outline-container-org987a8b5" class="outline-4">
<h4 id="org987a8b5">Quando PUSH viene usata, il receiver manda un regolare ACK, con Ack X+1</h4>
</div>
<div id="outline-container-org568ceed" class="outline-4">
<h4 id="org568ceed">In questo caso, però, viene fatta una eco dello stesso byte, questa volta</h4>
</div>
<div id="outline-container-org3cb54f1" class="outline-4">
<h4 id="org3cb54f1">Il motivo per cui viene fatta la eco è che il sender prende input a tastiera ma non mostra direttamente a schermo, perchè non è sicuro che dall'altra parte sia correttamente ricevuto. Solo quando si è sicuri che dall'altra parte sia stato ricevuto, viene stampato a tastiera</h4>
<div class="outline-text-4" id="text-org3cb54f1">
<pre class="example" id="org58f8990">
Let me explain why TCP echoes bytes with the PUSH flag:

    Data Acknowledgment vs Echo:

    The ACK simply acknowledges receipt of data
    The echo (sending the same byte back) serves a different purpose: it confirms the connection is still alive and functioning in both directions

    Key Benefits of Echoing:

    Tests bi-directional data flow
    Helps detect half-open connections
    Provides an additional validation mechanism beyond simple acknowledgment
    Useful for interactive applications where immediate response is needed

    Relationship to PUSH Flag:

    The PUSH flag indicates that data should be delivered to the application immediately
    Echoing PUSH-flagged bytes ensures the urgent nature of the data is maintained in both directions
    This is particularly important for interactive protocols like Telnet where character-by-character feedback is needed

The echo mechanism complements ACKs rather than duplicating them - ACKs confirm receipt, while echoes validate the full duplex nature of the connection and maintain interactive responsiveness.
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbb83a8f" class="outline-3">
<h3 id="orgbb83a8f">Per garantire&#x2026;(?) viene introdotto il delay acknowledgment.</h3>
<div class="outline-text-3" id="text-orgbb83a8f">
</div>
<div id="outline-container-orgfd6240e" class="outline-4">
<h4 id="orgfd6240e">La questione è che TCP ignora l'obiettivo delle applicazioni, ma loro lo sanno e potrebbero voler inserire più informazioni nello header.</h4>
</div>
<div id="outline-container-org59697c6" class="outline-4">
<h4 id="org59697c6">Immaginiamo una situazione come prima: si riceve un byte pushato.</h4>
</div>
<div id="outline-container-orgd2349e0" class="outline-4">
<h4 id="orgd2349e0">Il receiver, però, non risponde subito con un Ack, ma aspetta un tempo (standard 200ms).</h4>
</div>
<div id="outline-container-orge04c101" class="outline-4">
<h4 id="orge04c101">Se in quel tempo arriva qualcosa nel buffer di invio del ricevitore, quei dati vengono incorporati nel messaggio di Ack.</h4>
<div class="outline-text-4" id="text-orge04c101">
</div>
<div id="outline-container-org4e43150" class="outline-5">
<h5 id="org4e43150">In questo caso, sia sequence che ack number sono considerati. Seq è quello che ti do, ack quello che prendo.</h5>
<div class="outline-text-5" id="text-org4e43150">
</div>
<div id="outline-container-orgb4874d9" class="outline-6">
<h6 id="orgb4874d9">Prima invece, il campo sequence non era mai impostato</h6>
</div>
</div>
</div>
<div id="outline-container-org4e350bb" class="outline-4">
<h4 id="org4e350bb">In questo caso, quando la eco viene aggiunta nel buffer di invio della ricezione, viene inserita nello stesso frame di Ack. Così ri risparmia un messaggio TCP.</h4>
<div class="outline-text-4" id="text-org4e350bb">
<pre class="example" id="orgbcc8ae7">
Let me explain a common TCP optimization technique from computer networking. This technique is called "Delayed Acknowledgment" or "Delayed ACK."

The Delayed ACK technique involves:

    Deliberately waiting for a short period (typically around 200ms) before sending an ACK
    During this wait period, if the receiving host has data to send back to the sender, it can combine (piggyback) the ACK with this outgoing data
    The wait period also allows the receiver to potentially combine multiple ACKs into a single response if more segments arrive during the delay

This technique helps improve network efficiency by:

    Reducing protocol overhead
    Minimizing the number of small packets on the network
    Taking advantage of bi-directional data flow
    Optimizing bandwidth usage by combining ACKs with data when possible

However, Delayed ACK is not used in all cases - for example, every second full-sized segment must be acknowledged immediately to maintain TCP's flow control mechanisms.
</pre>
</div>
<div id="outline-container-org26498ba" class="outline-5">
<h5 id="org26498ba">Il prossimo messaggio del sender sarà sia un ACK della echo che un send del byte successivo.</h5>
</div>
</div>
<div id="outline-container-orgc8affb2" class="outline-4">
<h4 id="orgc8affb2">Questa soluzione è efficiente dal punto di vista di rete, ma inefficiente dal punto di vista della user-experience.</h4>
<div class="outline-text-4" id="text-orgc8affb2">
</div>
<div id="outline-container-org1167623" class="outline-5">
<h5 id="org1167623">Per trovare un compromesso fra rete e user-experience, si utilizza la tecnica del <b>NAGLE</b>.</h5>
<div class="outline-text-5" id="text-org1167623">
</div>
<div id="outline-container-org4aea034" class="outline-6">
<h6 id="org4aea034">Ho un sender con una serie di segmenti composti da un singolo byte da pushare.</h6>
</div>
<div id="outline-container-orge7af1fb" class="outline-6">
<h6 id="orge7af1fb">Come prima, mando un segmento con il byte, il receiver lo riceve e aspetta 200ms.</h6>
<div class="outline-text-6" id="text-orge7af1fb">
</div>
<div id="outline-container-orga706c56" class="outline-7">
<h7 id="orga706c56">L'applicazione riceve il byte e fa la ACK + echo, con SEQ = Y, PUSH attivato, ACK attivato e Ack = X + 1</h7>
</div>
</div>
<div id="outline-container-orged6549e" class="outline-6">
<h6 id="orged6549e">I successivi byte vengono impacchettati in un singolo segmento e mandati tutti insieme. Il receiver risponde con l'ack.</h6>
<div class="outline-text-6" id="text-orged6549e">
</div>
<div id="outline-container-org7ab79cc" class="outline-7">
<h7 id="org7ab79cc"><span class="todo TODO">TODO</span> Capire se viene effettuata la echo dei byte in blocco e se viene fatta byte per byte o cumulativa.</h7>
<div class="outline-text-7" id="text-org7ab79cc">
<pre class="example" id="org86ef219">
No, when using Nagle's algorithm, the block of bytes in the second segment is not echoed, and the ACK does not contain an echo of the whole block. Here's why:

    First byte behavior:

    The first byte is sent immediately (Nagle allows this)
    This byte gets acknowledged and echoed (typical for interactive data)

    Block of bytes behavior:

    The subsequent block is sent as a single segment due to Nagle's algorithm
    The receiver only sends an ACK for this data
    The block is NOT echoed back

The reason for this difference is:

    Single byte echoing is typically used for interactive traffic (like telnet) where immediate feedback is needed
    Larger blocks of data don't need character-by-character echo feedback
    Echoing large blocks would be inefficient and isn't necessary for bulk data transfer
    The ACK alone is sufficient to confirm receipt of the block

This behavior helps optimize network performance by:

    Reducing unnecessary network traffic
    Preventing excessive echoing of bulk data
    Maintaining interactivity where needed (single bytes)
    Providing reliable delivery confirmation through ACKs
</pre>

<pre class="example" id="org034a172">
The echo of the first byte in Nagle's algorithm serves these specific purposes:

    Connection Validation:

    The echo of the first byte confirms that the connection is fully functional in both directions
    It quickly verifies that the remote end is responsive and processing data

    Interactive Feedback:

    For interactive applications (like telnet or ssh), the first byte often represents a keystroke
    Users need immediate feedback for this first input to confirm their interaction
    The echo provides visual confirmation that the connection is working

    Fast Start Verification:

    Rather than waiting for the full data transfer to verify connection quality
    The single byte echo serves as a quick initial test of the connection

    Protocol Efficiency:

    Only echoing the first byte (not the subsequent block) is a compromise between:
        Providing necessary interactive feedback
        Avoiding unnecessary network overhead for bulk data
    After the initial verification, regular ACKs are sufficient for bulk data transfer

This selective echoing behavior combines the benefits of interactive responsiveness for the initial byte with efficient bulk transfer for subsequent data.
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org2a7effa" class="outline-4">
<h4 id="org2a7effa"></h4>
</div>
</div>
<div id="outline-container-org9579bb8" class="outline-3">
<h3 id="org9579bb8">In caso di errori, è lo stesso TCP che se ne accorge e cerca di sanarlo.</h3>
<div class="outline-text-3" id="text-org9579bb8">
</div>
<div id="outline-container-orgc66099b" class="outline-4">
<h4 id="orgc66099b">TCP è orientato allo stream.</h4>
<div class="outline-text-4" id="text-orgc66099b">
</div>
<div id="outline-container-org18854a4" class="outline-5">
<h5 id="org18854a4">Abbiamo già visto che a livello 2 ogni pacchetto è identificato da un numero che viene utilizzato per riconoscere i frame su cui avviene l'errore.</h5>
</div>
<div id="outline-container-org6fcfb70" class="outline-5">
<h5 id="org6fcfb70">In TCP l'idea del sequence number è che, conoscendo la dimensione del file \(N\), il segmento va da \(X\) a \(X+N\).</h5>
</div>
<div id="outline-container-orgcf0a6a7" class="outline-5">
<h5 id="orgcf0a6a7">Ci interessa capire fino a che punto dello stream è stato ricevuto tutto correttamente.</h5>
<div class="outline-text-5" id="text-orgcf0a6a7">
</div>
<div id="outline-container-org946b841" class="outline-6">
<h6 id="org946b841">Ovvero, l'indice \(K<N\) fino a cui è assicurata la comunicazione avvenuta correttamente.</h6>
</div>
</div>
<div id="outline-container-org487b1f3" class="outline-5">
<h5 id="org487b1f3">Quindi il sequence number sommato al payload, mi da il nuovo numero di sequenza.</h5>
</div>
<div id="outline-container-orga191249" class="outline-5">
<h5 id="orga191249">Immaginiamo di avere una situazione in cui l'app sender debba spedire 2400 byte con una dimensione del segmento di 500.</h5>
</div>
<div id="outline-container-orgd000467" class="outline-5">
<h5 id="orgd000467">Il primo segmento viene spedito con SEQ=X.</h5>
</div>
<div id="outline-container-org25d3a98" class="outline-5">
<h5 id="org25d3a98">Il secondo viene spedito senza aspettare l'ACK, con SEQ=X+500</h5>
</div>
<div id="outline-container-org6276068" class="outline-5">
<h5 id="org6276068">Si immagini adesso che il secondo segmento venga perso.</h5>
</div>
<div id="outline-container-orgf703eaf" class="outline-5">
<h5 id="orgf703eaf">Nel frattempo, il receiver risponde con un ACK per il primo segmento, ovvero con Ack X + 500 e dato che il segmento è nell'ordine corretto, questo viene spedito al buffer superiore.</h5>
</div>
<div id="outline-container-orgcac1e5b" class="outline-5">
<h5 id="orgcac1e5b">Quando il secondo segmento è spedito ma non è stato ricevuto l'ack corrispondente, il segmento è ancora nel sending buffer del tcp del sender.</h5>
</div>
<div id="outline-container-org62501c9" class="outline-5">
<h5 id="org62501c9">Comunque non aspetto l'ACK del secondo, perchè essendoci la rete per mezzo, non posso sapere se arriverà a breve o non arriverà.</h5>
</div>
<div id="outline-container-orgee9a478" class="outline-5">
<h5 id="orgee9a478">Quindi mando il terzo, con SEQ=X+1000.</h5>
</div>
<div id="outline-container-org72c646f" class="outline-5">
<h5 id="org72c646f">Quando il receiver riceve questo segmento, lo mette nel suo buffer, ma risponde con lo stesso ACK di prima.</h5>
<div class="outline-text-5" id="text-org72c646f">
</div>
<div id="outline-container-org7830648" class="outline-6">
<h6 id="org7830648">Ovvero, si intende che sebbene qualcosa sia ricevuto, non "riempie lo spazio" di ciò che non era stato ricevuto.</h6>
</div>
</div>
<div id="outline-container-org474dd1c" class="outline-5">
<h5 id="org474dd1c">La questione è che ogni segmento attiva un timer. Finchè il timer non scade, TCP prosegue con <b>tutti</b> i segmenti successivi in buffer d'invio.</h5>
</div>
<div id="outline-container-org8d90805" class="outline-5">
<h5 id="org8d90805">Quando il timer scade, soltanto quello specifico segmento viene inviato.</h5>
</div>
<div id="outline-container-org038561b" class="outline-5">
<h5 id="org038561b">A questo punto, il ricevitore si renderà conto che quel segmento, il secondo in questo caso, va posizionato prima dei successivi, che già possiede nel buffer. Allora tutti quelli successivi saranno sbloccati ed il prossimo ACK li includerà. Si parla quindi di ACK cumulativo.</h5>
</div>
<div id="outline-container-org0601afb" class="outline-5">
<h5 id="org0601afb">Questa roba si chiama <b>fast retransmit</b>, ovvero la ritrasmissione di un singolo segmento.</h5>
</div>
<div id="outline-container-orge177b33" class="outline-5">
<h5 id="orge177b33">Il timer è pensato per considerare il caso di perdita, anche abbastanza inusuale, sovradimensionato.</h5>
</div>
<div id="outline-container-orgb041514" class="outline-5">
<h5 id="orgb041514">Si usa però anche una strategia del triplo ACK: al terzo ACK uguale ricevuto, viene inviato il segmento corrispondente.</h5>
</div>
<div id="outline-container-org9b9e97d" class="outline-5">
<h5 id="org9b9e97d">Usando queste due strategie, si limita il danno sull'efficienza del timeout e si rende più veloce l'invio dei segmenti precedenti.</h5>
<div class="outline-text-5" id="text-org9b9e97d">
</div>
<div id="outline-container-orgfb44b2a" class="outline-6">
<h6 id="orgfb44b2a">Ad esempio, si fa in modo che tutti i segmenti in coda nel buffer a cui serve quello perso per sbloccarsi, debbano aspettare al massimo T ma spesso anche di meno, così da ridurre lo spazio di memoria occupato.</h6>
</div>
</div>
<div id="outline-container-orgf68be73" class="outline-5">
<h5 id="orgf68be73">Il timer è anche molto utile per gli ultimi (?)2 segmenti, dopo i quali non esistono 3 ack che facciano partire la ritrasmissione.</h5>
<div class="outline-text-5" id="text-orgf68be73">
</div>
<div id="outline-container-org54a5a35" class="outline-6">
<h6 id="org54a5a35"><span class="todo TODO">TODO</span> Per quanti segmenti vale questa proprietà</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb478123" class="outline-2">
<h2 id="orgb478123">Negle ha un utilità quando vogliamo garantire un utilizzo efficiente della rete.</h2>
<div class="outline-text-2" id="text-orgb478123">
</div>
<div id="outline-container-org141e552" class="outline-3">
<h3 id="org141e552">Lo si usa al posto di mandare ogni carattere da solo, con un overhead altissimo dovuto allo header IP e TCP.</h3>
<div class="outline-text-3" id="text-org141e552">
</div>
<div id="outline-container-org8a268e5" class="outline-4">
<h4 id="org8a268e5">Per mandare un byte, mi servono 4 messaggi.</h4>
</div>
<div id="outline-container-orgffa0f4b" class="outline-4">
<h4 id="orgffa0f4b">Si usa il delay per diminuire i messaggi che vengono mandati, ma si paga troppo tempo per l'attesa del delay ogni volta, con piggy bagging in cui nei dati da comunicare si inserisce anche l'ack cumulativo</h4>
</div>
<div id="outline-container-orga78f66a" class="outline-4">
<h4 id="orga78f66a">Un compromesso e il nagle</h4>
</div>
</div>
<div id="outline-container-orge3a9a0f" class="outline-3">
<h3 id="orge3a9a0f">Il Nagle viene in supporto quando abbiamo un quantitativo di dati dall'applicazione, ovvero nel SB (superiore) che è minore alla maximum segment size.</h3>
<div class="outline-text-3" id="text-orge3a9a0f">
</div>
<div id="outline-container-org00f9aa1" class="outline-4">
<h4 id="org00f9aa1">Nagle innanzitutto guarda il TCP Sending Buffer (quello inferiore). Se è vuoto vuol dire che non sto aspettando nessun ACK.</h4>
<div class="outline-text-4" id="text-org00f9aa1">
</div>
<div id="outline-container-org9e2ce3c" class="outline-5">
<h5 id="org9e2ce3c">In questo caso, invio direttamente il contenuto dell'SB, nonostante sia inferiore.</h5>
</div>
</div>
<div id="outline-container-org6c1250f" class="outline-4">
<h4 id="org6c1250f">Se invece ci sono altri segmenti nel buffer inferiore, lo accoda.</h4>
</div>
<div id="outline-container-orgf7e14b4" class="outline-4">
<h4 id="orgf7e14b4">Uno dei lati negativi di Nagle è che sebbene utilizzi bene la rete, ovvero limitando l'overhead, (QUAL è L'ASPETTO NEGATIVO)?</h4>
</div>
</div>
<div id="outline-container-org37645da" class="outline-3">
<h3 id="org37645da">Un altro aspetto è che tcp è orientato allo stream e ragiona in base ai bit.</h3>
<div class="outline-text-3" id="text-org37645da">
</div>
<div id="outline-container-orgbaeb0a9" class="outline-4">
<h4 id="orgbaeb0a9">Una sequenza di dati presente nel sending buffer non dev'essere multiplo della max segment size. Il TCP suddivide in blocchetti della dimensione corretta.</h4>
<div class="outline-text-4" id="text-orgbaeb0a9">
</div>
<div id="outline-container-org84b554a" class="outline-5">
<h5 id="org84b554a">Se un ultimo blocchetto non raggiunge la max segment size, sta all'applicazione decidere se mandarlo subito o se aspettare nuovi dati, la cui prima parte verrà aggiunta all'ultimo segmento e mandata tutto insieme.</h5>
</div>
</div>
<div id="outline-container-orgb7ea857" class="outline-4">
<h4 id="orgb7ea857">Quindi si parla di segmento numero n come divisione logica, ma tutto è relativo al byte di inizio sequenza.</h4>
</div>
<div id="outline-container-org4ed0d07" class="outline-4">
<h4 id="org4ed0d07">Il principio è che si occupa il meno possibile. L'eventuale padding è fatto ai livelli inferiori.</h4>
</div>
</div>
<div id="outline-container-org6458c34" class="outline-3">
<h3 id="org6458c34">Quando TCP invia un pacchetto ad IP, quest'ultimo, conoscendo perfettamente la max transfer unit del suo livello 2, frammenta ulteriormente se necessario.</h3>
<div class="outline-text-3" id="text-org6458c34">
</div>
<div id="outline-container-org4778987" class="outline-4">
<h4 id="org4778987">IP stesso riassemblerà poi la serie di pacchetti e la fornirà a tcp</h4>
</div>
<div id="outline-container-orgb15bb68" class="outline-4">
<h4 id="orgb15bb68">Se non ci riesce, a TCP non arriverà assolutamente nulla.</h4>
<div class="outline-text-4" id="text-orgb15bb68">
</div>
<div id="outline-container-org8acbae5" class="outline-5">
<h5 id="org8acbae5">Inoltre, solo il primo pacchetto avrà lo header tcp.</h5>
</div>
</div>
</div>
<div id="outline-container-org27f1c29" class="outline-3">
<h3 id="org27f1c29">Come abbiamo già visto, il round trip time è il tempo necessario perchè un segmento venga inviato ed ackAto.</h3>
<div class="outline-text-3" id="text-org27f1c29">
</div>
<div id="outline-container-orgb3426aa" class="outline-4">
<h4 id="orgb3426aa">Possiamo però anche inviare più segmenti nello stesso momento.</h4>
</div>
<div id="outline-container-orgdb56aa7" class="outline-4">
<h4 id="orgdb56aa7">Ogni segmento fa partire un timer, che dev'essere dimensionato correttamente e quindi non può essere statico.</h4>
</div>
<div id="outline-container-org16fea8c" class="outline-4">
<h4 id="org16fea8c">Esiste uno standard che ci spiega come calcolarlo</h4>
<div class="outline-text-4" id="text-org16fea8c">
</div>
<div id="outline-container-orgfcebf8c" class="outline-5">
<h5 id="orgfcebf8c">Diciamo che il round trip time in media impieghi 30 ms</h5>
</div>
<div id="outline-container-orgcc4f4f5" class="outline-5">
<h5 id="orgcc4f4f5">La stima viene fatta considerandolo come un outlier della distribuzione.</h5>
<div class="outline-text-5" id="text-orgcc4f4f5">
</div>
<div id="outline-container-orga5a8d2b" class="outline-6">
<h6 id="orga5a8d2b">Tipicamente si dice che un valore di +3sigma, quindi media più 4 deviazioni standard ci da una stima di un caso molto raro di outlier.</h6>
</div>
<div id="outline-container-org7b33171" class="outline-6">
<h6 id="org7b33171">Quindi dobbiamo sapere la media e la deviazione standard in base ai dati del round trip time.</h6>
<div class="outline-text-6" id="text-org7b33171">
</div>
<div id="outline-container-orgc871c1e" class="outline-7">
<h7 id="orgc871c1e">INSERIRE FORMULA</h7>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org4d53229" class="outline-3">
<h3 id="org4d53229">Il controllo di flusso viene messo in atto quando il produttore produce molto più velocemente del ricevente.</h3>
<div class="outline-text-3" id="text-org4d53229">
</div>
<div id="outline-container-orgfeb543b" class="outline-4">
<h4 id="orgfeb543b">Infatti, il buffer di ricezione andrebbe poi in overflow.</h4>
<div class="outline-text-4" id="text-orgfeb543b">
</div>
<div id="outline-container-org91a8490" class="outline-5">
<h5 id="org91a8490">Immaginiamo di avere una situazione in cui il sending buffer è di 3000 e il receiving 2000. (mss sempre 500 (ma standard 512)).</h5>
<div class="outline-text-5" id="text-org91a8490">
</div>
<div id="outline-container-org9943032" class="outline-6">
<h6 id="org9943032">L'informazione della dimensione dell'altro è nota ad entrambi.</h6>
</div>
<div id="outline-container-orgd4520ac" class="outline-6">
<h6 id="orgd4520ac">Una volta che il sender ha mandato 2000 bit (in 4 tranche perchè la finestra è di 500), il receiving manda non solo un ACK per controllo errori, ma anche un WIN=0, per il controllo di flusso, che indica che lo spazio è finito.</h6>
</div>
<div id="outline-container-org7e4e468" class="outline-6">
<h6 id="org7e4e468">Quando avrà poi letto 1000 byte, manderà un ACK con lo stesso byte atteso del precedente, ma una window size di 1000.</h6>
</div>
</div>
<div id="outline-container-org2699e04" class="outline-5">
<h5 id="org2699e04">Il problema è che se il secondo ack di riapertura viene perso, il sender rimarrebbe bloccato per sempre, ovvero si avrebbe un deadlock.</h5>
<div class="outline-text-5" id="text-org2699e04">
</div>
<div id="outline-container-orgdd36fd1" class="outline-6">
<h6 id="orgdd36fd1">Allo scadere di un Persist Timer nel receiver, viene mandato un segmento speciale vuoto, ovvero senza dati, a cui il receiver risponde con un reinvio dell'ack con nuova finestra.</h6>
<div class="outline-text-6" id="text-orgdd36fd1">
</div>
<div id="outline-container-org3b8d575" class="outline-7">
<h7 id="org3b8d575">Se anche quel nuovo ack è perso, allo scadere di un nuovo timer la connessione sarebbe chiusa.</h7>
</div>
</div>
</div>
</div>
<div id="outline-container-org8918144" class="outline-4">
<h4 id="org8918144">Il problema della silly window syndrome accade quando il receiver riempie la propria window e continua a notificare la nuova disponibilità ma per una quantità di byte minima.</h4>
<div class="outline-text-4" id="text-org8918144">
</div>
<div id="outline-container-org00f083a" class="outline-5">
<h5 id="org00f083a">La soluzione è l'algoritmo di Clark, in cui l'aggiornamento della windows dev'essere almeno grande come la MSS o come la metà del buffer.</h5>
</div>
</div>
<div id="outline-container-orge052efd" class="outline-4">
<h4 id="orge052efd">La rete ignora completamente il controllo di flusso.</h4>
</div>
</div>
</div>
<div id="outline-container-org1189b9b" class="outline-2">
<h2 id="org1189b9b"><span class="todo TODO">TODO</span> Riempire con ultime 2 lezioni di livello 4</h2>
</div>
<div id="outline-container-org59aa199" class="outline-2">
<h2 id="org59aa199">Iniziamo il livello applicazione parlando del DNS, ovvero il Domain Name System.</h2>
<div class="outline-text-2" id="text-org59aa199">
</div>
<div id="outline-container-org535eda7" class="outline-3">
<h3 id="org535eda7">E' un sistema che permette di rendere più semplice raggiungere un host</h3>
<div class="outline-text-3" id="text-org535eda7">
</div>
<div id="outline-container-orgefc0859" class="outline-4">
<h4 id="orgefc0859">Normalmente si usa un IP per raggiungere un host, ma è praticamente impossibile ricordare un IP.</h4>
</div>
</div>
<div id="outline-container-org627330b" class="outline-3">
<h3 id="org627330b">Funziona associando un nome (dominio) all'ip di uno specifico host.</h3>
<div class="outline-text-3" id="text-org627330b">
</div>
<div id="outline-container-org7c56b97" class="outline-4">
<h4 id="org7c56b97">Permette anche di recuperare altre informazioni</h4>
</div>
</div>
<div id="outline-container-org4b8dc3a" class="outline-3">
<h3 id="org4b8dc3a">L'idea è quella di disaccoppiare il modo in cui un essere umano raggiunga un certo servizio.</h3>
<div class="outline-text-3" id="text-org4b8dc3a">
</div>
<div id="outline-container-orgea00ede" class="outline-4">
<h4 id="orgea00ede">Ad esempio il servizio potrebbe cambiare indirizzo ip in modo trasparente agli utenti.</h4>
<div class="outline-text-4" id="text-orgea00ede">
</div>
<div id="outline-container-orgb93e868" class="outline-5">
<h5 id="orgb93e868">Questo è utilizzato anche per il load balancing, così che il traffico venga diviso su diversi server.</h5>
</div>
</div>
</div>
<div id="outline-container-org6547cee" class="outline-3">
<h3 id="org6547cee">Il fully qualified domain name (FQDN) contiene un punto alla fine che indica il root domain</h3>
</div>
<div id="outline-container-org9c35d50" class="outline-3">
<h3 id="org9c35d50">Il modo in cui avviene la risoluzione del FQDN fra due macchine, ovvero fra un host che richiede e il server che risponde, è sostituendo ad ogni punto il numero di caratteri che seguono quel punto prima di quello successivo, esempio 2DI5UNIMI2IT0.</h3>
</div>
<div id="outline-container-org0366a4e" class="outline-3">
<h3 id="org0366a4e">Una query DNS contiene uno header, il FQDN specifico, il tipo di query(A, AAAA, Mx), la classe (che indica la rete su cui si vuole risolvere, che di fatto è sempre internet)</h3>
<div class="outline-text-3" id="text-org0366a4e">
</div>
<div id="outline-container-orge1e86ac" class="outline-4">
<h4 id="orge1e86ac">Il tipo può essere2 A per IPv4, AAAA per IPv6, MX per posta, CNAME (canonical name) che è un altro nome per lo stesso sito</h4>
</div>
</div>
<div id="outline-container-orga1fb851" class="outline-3">
<h3 id="orga1fb851">La risposta ricopia i dati e inserisce l'indirizzo nell'ultimo campo.</h3>
</div>
<div id="outline-container-orgdbf43d2" class="outline-3">
<h3 id="orgdbf43d2">Un record DNS in cache può essere associato ad uno specifico TTL, dopo il quale il record scade e la prossima richiesta effettuata da qualunque client dovrà essere risoluta di nuovo</h3>
<div class="outline-text-3" id="text-orgdbf43d2">
</div>
<div id="outline-container-org51f0932" class="outline-4">
<h4 id="org51f0932"><span class="todo TODO">TODO</span> Capire funzionamento in caso di record scaduto</h4>
</div>
</div>
<div id="outline-container-org07fdf14" class="outline-3">
<h3 id="org07fdf14">Il resolving DNS avviene con un client che chiede la risoluzione di uno specifico FQDN al resolver all'interno della stessa macchina.</h3>
<div class="outline-text-3" id="text-org07fdf14">
</div>
<div id="outline-container-orga3358f6" class="outline-4">
<h4 id="orga3358f6">Il resolver usa UDP perchè non gli serve instaurare la connessione e parla con il Local DNS, che viene impostato in fase di configurazione.</h4>
</div>
</div>
<div id="outline-container-orgdd7a881" class="outline-3">
<h3 id="orgdd7a881">A livello globale ci sono dei root DNS servers che contengono soltanto i domini di primo livello, con gli IP corrispondenti dei NameServer.</h3>
<div class="outline-text-3" id="text-orgdd7a881">
</div>
<div id="outline-container-org2797fcb" class="outline-4">
<h4 id="org2797fcb">Usiamo questi se non sappiamo come raggiungere il dominio di primo livello, che di solito però conosciamo già perchè rimane in cache</h4>
</div>
<div id="outline-container-org0d1f268" class="outline-4">
<h4 id="org0d1f268">Sul libro sono indicati due approcci, uno iterativo e uno ricorsivo, ma gli esempi sono tutti iterativi.</h4>
<div class="outline-text-4" id="text-org0d1f268">
</div>
<div id="outline-container-org0156dfb" class="outline-5">
<h5 id="org0156dfb">L'approccio ricorsivo funziona con il resolver che manda una query al local dns e quest'ultimo risponde con l'indirizzo già pronto.</h5>
<div class="outline-text-5" id="text-org0156dfb">
</div>
<div id="outline-container-orgacd3876" class="outline-6">
<h6 id="orgacd3876">Non è implementata nei server per questioni di scalabilità.</h6>
</div>
<div id="outline-container-org27184f7" class="outline-6">
<h6 id="org27184f7">Il problema è che sebbene sia molto comoda per il client, il resolver dovrebbe mantenere tantissime informazioni di stato in attesa dei passi successivi.</h6>
</div>
</div>
<div id="outline-container-orge8f6ed2" class="outline-5">
<h5 id="orge8f6ed2">L'approccio iterativo si applica dal local dns in poi, mentre fra resolver e local dns rimane ricorsivo, ovvero il local dns mantiene lo stato della richiesta fino all'invio della risposta al resolver.</h5>
<div class="outline-text-5" id="text-orge8f6ed2">
</div>
<div id="outline-container-orgf9b5aec" class="outline-6">
<h6 id="orgf9b5aec">Il client continua a ricevere una risposta valida già pronta.</h6>
</div>
<div id="outline-container-org4bcf4cd" class="outline-6">
<h6 id="org4bcf4cd">Il local DNS, però, gestisce in modo iterativo.</h6>
<div class="outline-text-6" id="text-org4bcf4cd">
</div>
<div id="outline-container-org6e92a93" class="outline-7">
<h7 id="org6e92a93">Manda l'intero dominio al root, che conosce però solo l'IP di primo livello e risponde con un informazione parziale, ovvero con l'indirizzo del NS di primo livello.</h7>
</div>
<div id="outline-container-org3f3b8cd" class="outline-7">
<h7 id="org3f3b8cd">Una volta conosciuto quello di primo livello, si chiede al corrispondente NameServer di risolvere la parte rimanente del dominio.</h7>
<div class="outline-text-7" id="text-org3f3b8cd">
</div>
<div id="outline-container-orgb662367" class="outline-8">
<h8 id="orgb662367">Questo risponde con l'indirizzo del DNS Server del secondo livello.</h8>
</div>
</div>
<div id="outline-container-org7c92bc7" class="outline-7">
<h7 id="org7c92bc7">Se il dominio era composto da tre livelli, il DNS server di secondo livello risponde con l'IP specifico</h7>
</div>
</div>
</div>
<div id="outline-container-org4281987" class="outline-5">
<h5 id="org4281987">Anche l'approccio iterativo richidede un overhead per il primo step, che viene attenuato dall'utilizzo della cache.</h5>
<div class="outline-text-5" id="text-org4281987">
</div>
<div id="outline-container-orgcb19c64" class="outline-6">
<h6 id="orgcb19c64">In questo modo, la prossima volta che verrà richiesto un dominio di terzo livello appartenente allo stesso secondo livello, la richiesta verrà effettuata direttamente al Name Server di secondo livello.</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc7024da" class="outline-2">
<h2 id="orgc7024da">Ultima lezione</h2>
<div class="outline-text-2" id="text-orgc7024da">
<p>
Gli esercizi su livello 2 e calcolo di RTT sono fondamentali. Ce ne sono di solito 2.
Scrivere a rossi@di.unimi.it per problemi.
Le domande sono più o meno metà su livelli bassi e metà su quelli alti.
TCP è molto gettonato.
Non usare tante parole ma fare gli schemi.
Ad esempio, per la chiusura della comunicazione TCP, inserire i messaggi scambiati, compreso l'ACK e possibilmente mettere i timer a lato.
Bisogna essere specifici, ad esempio se viene chiesta la chiusura asimmetrica, non serve descrivere anche quella simmetrica.
Decidere che livello di dettaglio usare per la domanda.
Anche per una domanda sul distance vector e split horizon, sarebbe bene fare un esempio e descrivere bene che il problema è che non viene indicato il link che si usa per raggiungere una destinazione
Il prof non sa esattamente quali sono i valori di alfa e beta, comunque basta indicare quali sono stati usati vicino l'esercizio
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-01-22 Wed 20:15</p>
</div>
</body>
</html>
