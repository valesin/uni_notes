<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-01-28 Tue 20:16 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retibozza</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Retibozza</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org08bb564">References</a></li>
<li><a href="#org29180fd">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org2228452">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd6cc51b">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org5df9786">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgaf438d0">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org950ccae">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org3605f48">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org763e335">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orge526da8">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org84cbc5f">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org36124a3">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgb0469e7">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgbc3728a">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org1eb8280">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd77b681">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orge6c8b46">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org2af6a5a">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd2c93e7">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org71205b8">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org98d5d71">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgd570d63">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org90fd521">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org56b2f6c">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org660452f">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.</a>
<ul>
<li><a href="#org204fbd7">A livello 2, in una rete CSMA-CD l'indirizzo è il MAC</a></li>
<li><a href="#org8d5798d">A livello 3, l'indirizzo è quello IP, con tutte le considerazioni fatte in precedenza.</a></li>
<li><a href="#org6ba3a9a">Un problema che dobbiamo risolvere è quello di mappare l'IP al corrispondente MAC.</a>
<ul>
<li><a href="#org26357e9">Infatti, finora non c'è nessun modo per far arrivare un pacchetto a destinazione.</a></li>
</ul>
</li>
<li><a href="#org5afbdb1">Immaginiamo che A e B siano sulla stessa rete locale.</a>
<ul>
<li><a href="#org6f09a11">Se la macchina A manda un pacchetto al modulo B, chiede ad ARP di risolvere l'IP in un MAC address, così che possa mandarglielo attraverso il livello 2</a></li>
<li><a href="#org410d6bd">In pratica l'ARP, per conto di IP, manda ai livelli sottostanti una richiesta, ARPRequest, così che il dispositivo in questione risponda con un ARPReply, rispondendo con il proprio MAC, che ARP fornirà al livello IP della macchina sorgente.</a>
<ul>
<li><a href="#org8df1b1b">Le due macchine, nell'esempio, si trovano nella stessa rete. Ovviamente, nella richiesta non si sa chi sia l'host destinazione, quindi è necessario fare una richiesta broadcast. La risposta sarà, invece, punto-punto.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org35e506c">Immaginiamo adesso che siano su macchine diverse.</a>
<ul>
<li><a href="#org1883350">A manda richiesta a Z, su un'altra rete.</a></li>
<li><a href="#org8dc75cf">Il site access gateway leggerà il NETID e vedrà che non appartiene alla rete locale e che quindi va cercato al di fuori. Prenderà lui in carico l'operazione.</a></li>
<li><a href="#org11706b8">A questo punto, risponderà con il proprio MAC, in modo che A mandi le richieste al gateway.</a></li>
<li><a href="#org735f945">Il gateway aspetterà autonomamente per la ARPReply della macchina remota e salverà il risultato.</a></li>
<li><a href="#orga026032">Questo servizio si chiama ProxyARP.</a></li>
</ul>
</li>
<li><a href="#org63d2c82">ARP in ogni dispositivo terrà una ARP Cache, in cui salverà tutte le associazioni IP-MAC, così che le volte successive non servirà una nuova richiesta.</a></li>
<li><a href="#org1687419">Quindi uso ARP per fare una discovery delle macchine che sono raggiungibili in rete.</a></li>
<li><a href="#org05de959">Anche in questo caso, abbiamo un livello 3 che per funzionare (anzi, il suo obiettivo) è di livello 2. Deve infatti andare a toccare il MAC, indirizzo di livello 2, ma in questo caso almeno fa una richiesta</a></li>
<li><a href="#orgb1aedc9">Notiamo che nello header di livello 3, il campo type è usato anche per identificare se la richiesta sia IPv4 o ARP</a></li>
</ul>
</li>
<li><a href="#org8527999">Introduciamo il DHCP</a>
<ul>
<li><a href="#org51adb1a">Abbiamo tante macchine collegate ad una LAN, che possono essere nostre oppure di ospiti che arrivano transitoriamente. Come assegniamo l'IP privato alle macchine?</a>
<ul>
<li><a href="#orge3c1718">La LAN potrebbe essere Wireless, collegata tramite un Access Point ad una Lan fisica, che tramite il suo Access Gateway è collegata alla rete fisica.</a></li>
</ul>
</li>
<li><a href="#org20921fd">Il Gateway riesce a fare Address Resolution e quindi è anche un NAT. Ovvero, riesce a mascherare un indirizzo interno.</a>
<ul>
<li><a href="#org914f990">Ci presenta con un IP pubblico alla rete, ma poi smista alle macchine singole con gli indirizzi privati.</a></li>
</ul>
</li>
<li><a href="#org6435daf">Questi indirizzi potrebbero esere statici, ma questo è scomodo. (Perchè?).</a></li>
<li><a href="#orgbd0dcf3">E' più comodo se al momento della prima connessione alla rete, venga assegnato un IP dinamico al dispositivo, che rimanga fino allo spegnimento.</a></li>
<li><a href="#orge5b2d9b">Per assegnare l'IP dinamico, usiamo il server DHCP (eventualmente molteplici)</a>
<ul>
<li><a href="#org6d7f3af">Appena una macchina cliente viene bootata, fa un operazione di Request DHCP al server, che farà a sua volta una Reply.</a></li>
<li><a href="#org659ee39">La reply assegna un IP privato, valido per tutto il tempo necessario.</a>
<ul>
<li><a href="#org18913ba">Addirittura, un DHCP address ha un TimeToLeave, poi viene buttato e refreshato.</a></li>
<li><a href="#orged15ddb">Al punto che quando arriva un ospite (abilitato ad accedere alla rete), loro parlano con DHCP e diventano a tutti gli effetti parte della rete.</a></li>
</ul>
</li>
<li><a href="#org3979ad1">La RequestForComment che lo definisce è la 2131.</a></li>
<li><a href="#org1197186">Il client triggera la richiesta, che nello specifico si chiama DHCP Discover.</a>
<ul>
<li><a href="#org3500952">Questa discover è un pacchetto IP che viaggia con sorgente 0.0.0.0, perchè non so scriverlo ed è proprio per questo che mando la richiesta.</a></li>
<li><a href="#org4e74ceb">La destinazione è 255.255.255.255. Un pacchetto broadcast all'interno della LAN. Non va direttamente al server DHCP. Il motivo è che se io voglio un assegnamento dinamico per ogni macchina, anche non appartenenti alla mia rete, non posso assumere che questi sappiano l'indirizzo del server DHCP.</a></li>
<li><a href="#orgdbe3eac">Inoltre, se io mettessi un singolo IP, perderei la possiblità di avere molteplici DHCP server, utilizi banalmente per ridondanza.</a></li>
<li><a href="#org3c24ec8">Poi c'è un campo Time To Live,  con un Transaction ID, che viene associato all'indirizzo della macchina.</a>
<ul>
<li><a href="#orgcfe6b88">Questo serve per associare le request alle response</a></li>
<li><a href="#org4937bb1">Per identificare questo Time To Live con il client della richiesta, non può essere utilizzato l'IP, ma necessariamente il MAC di livello 2.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9763e01">Il server riceve la richiesta e reagisce con una DHCP Offer.</a>
<ul>
<li><a href="#orgfb66ed0">Quello che offre il DHCP server è l'IP address.</a></li>
<li><a href="#org3f3c289">Sarà sempre un pacchetto con sorgente IP del Server, broadcast e lo stesso transactionID della richiesta.</a>
<ul>
<li><a href="#org89c7b8b">Deve necessariamente essere broadcast.</a></li>
</ul>
</li>
<li><a href="#org202940c">Prima di fare la offer, il server fa un check. Il check dell'IP prevede che tramite ICMP il server sia in grado di verificare se per caso quell'IP non sia stato già assegnato a qualcuno per errore.</a>
<ul>
<li><a href="#org3edc76b">In pratica fa un ping, che prevede un echo se la stazione è raggiungibile. Se l'echo è assente, l'IP non è stato associato a nessuno. Altrimenti l'IP va aggiornato.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5412876">A questo punto il client ha <b>apparentemente</b> risolto il suo problema.</a>
<ul>
<li><a href="#orgaf78a9e">Si può immaginare che il client abbia un timeout in modo che non trascorra troppo prima dell'arrivo di una offer. (Stesso principio dell'ACK).</a></li>
<li><a href="#orgd7babf5">Il problema è che un algoritmo di questo tipo funzionerebbe se e solo se ammettesse uno e un solo server DHCP operativo per ogni rete, ma il protocollo è fatto per funzionare con un numero arbitrario di server.</a>
<ul>
<li><a href="#orge57537a">Infatti, la discover è in broadcast e arriva a tutti i server, che si adopereranno tutti per offrire un IP.</a></li>
</ul>
</li>
<li><a href="#org15f0a07">Bisogna garantire che venga accettata l'offerta di un solo server.</a></li>
</ul>
</li>
<li><a href="#orgc5709d8">Diventa necessaria un ulteriore fase, una commit, chiamata DHCP Request.</a>
<ul>
<li><a href="#org82feb32">Questa viaggia con stesse sorgente e destinazione della discover (0 e 1Broadcast), ma con un ulteriore campo scelta, che contiene un ID del server la cui offerta è stata accettata.</a></li>
</ul>
</li>
<li><a href="#orgc0400fe">A questo punto, si chiude il commitment con una DHCP Ack, che è una validazione della request. Anche questo è mandato in broadcast secondo IP.</a>
<ul>
<li><a href="#orgf874699">Ricordare che tutte queste comunicazioni di risposta da parte del server, utilizzano il MAC di livello 2 e sono quindi Unicast.</a></li>
</ul>
</li>
<li><a href="#org2ba6e89">Questo protocollo è un protocollo a 4 vie, a causa della necessità di selezionare fra i vari server.</a></li>
<li><a href="#orgf82ad58">Servono inoltre dei check per verificare la validità degli IP, anche dal punto di vista del client.</a>
<ul>
<li><a href="#org52e80f6">Viene utilizzato ARP, che è perfetto per questo lavoro, ovvero risolvere un IP in un MAC.</a>
<ul>
<li><a href="#orga8b070f">Facendo una ARP request con l'IP appena assegnato al server, in caso di risposta positiva si capisce che l'IP è già assegnato.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org47bd7d9">Esistono dei meccanismi di ricovero, per gestire i casi in cui i messaggi vengano persi. Si utilizza ad esempio un timer T, che viene eseguito massimo K volte (numero di retry). Una volta aver provato K volte, si ritorna alle origini e si ricomincia da capo.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org41d4771">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).</a></li>
<li><a href="#org41ad2dc">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente</a>
<ul>
<li><a href="#org6c388ea">Immaginiamo di avere due macchine con porte I/O e un forwarder in mezzo, che contiene una tabella e fa un lookup per capire su quale porta trasmettere il messaggio entrato.</a>
<ul>
<li><a href="#orgdba9e4b">A livello 2, questo è fatto dal bridge, che popola e spopola le tabelle periodicamente per lasciar spostare le macchine.</a></li>
<li><a href="#org2226852">Se saliamo di un piano, quello che cambia radicalmente è che non è più vero che la macchina destinazione sia attaccata al link. La validità di un forwarding livello 2, a livello 3 non è più sufficiente.</a>
<ul>
<li><a href="#orge54832a">Il forwarding deve avere la capacità di scegliere la porta che conduce alla destinazione in futuro, e in un modo oscuro alla singola macchina.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org76c6724">A livello 3, la tabella viene popolata da un secondo processo, che chiamiamo <b>router</b>, che lavora con i suoi pacchetti di controllo, utili soltanto a lui, tramite i quali impara la topologia della rete e popola la tabella in modo da permettere di raggiungere ogni host in un modo efficiente, possibilmente il cammino minimo.</a>
<ul>
<li><a href="#org77d9473">La cosa interessante è che abbiamo una separazione netta fra tutto ciò che è gestione dei dati utente e la gestione di controllo di tutto ciò che serve alla rete autonomamente perchè funzioni.</a></li>
<li><a href="#org14241f8">Con il routing questa diventa chiara.</a>
<ul>
<li><a href="#org98ec5c0">Finora i messaggi di controllo e i dati erano mescolati, anche fisicamente.</a></li>
<li><a href="#org029fe31">Adesso, il router lavora in modo assolutamente autonomo.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdf25eca">Il router opera attraverso 3 tecniche:</a>
<ul>
<li><a href="#org9be8703">Il protocollo con Distance vector opera assegnando due etichette con numero del link e corrispondente peso su ogni arco bidirezionale.</a>
<ul>
<li><a href="#orga501026">Ogni nodo produce la tabella delle adiacenze. Questa contiene Router, Link e Cost.</a>
<ul>
<li><a href="#orge4a040d">Sè stesso è raggiungibile da sè stesso (no link) con costo 0.</a></li>
<li><a href="#orgedd39bc">Ogni altro router, è raggiungibile attraverso un certo link, con un costo uguale alla somma delle etichette dei pesi di tutti gli archi che vengono attraversati.</a></li>
</ul>
</li>
<li><a href="#org94fb014">Con queste costruiamo la conoscenza locale, ovvero tutti i router appena adiacenti attraverso soltanto un filo, insieme al loro costo.</a>
<ul>
<li><a href="#org51a2717">Ancora non abbiamo una visione topologica della rete. Abbiamo solo una visione delle adiacenze.</a>
<ul>
<li><a href="#orgbb34896">Un singolo nodo nono ha idea di quali nodi possa raggiungere oltre le adiacenze.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6f5e3c1">Il modo per passare da una conoscenza locale a quella globale sfrutta la comunicazione fra nodi.</a></li>
<li><a href="#orgb6fb637">Periodicamente viene trasferito agli altri il distance vector, ovvero l'associazione Router-Costo</a>
<ul>
<li><a href="#orgf3011f5">Ogni router ha un proprio timer, alla scadenza del quale trasferisce il vettore delle distanze ai suoi vicini.</a></li>
</ul>
</li>
<li><a href="#org2d49b91">Quando un nodo riceve il vettore delle distanze del vicino, aggiorna il proprio vettore con i nuovi nodi raggiungibili attraverso il vicino, la cui distanza è la somma fra il primo nodo è quello appena collegato e quest'ultimo con il nuovo.</a></li>
<li><a href="#org87e1988">Ogni vettore delle distanze nuovo che arriva, un router calcola anche tutte le nuove distanze per le destinazioni che già conosce, in modo da aggiornare nuove distanze minime.</a></li>
<li><a href="#org0138d4a">Il tempo necessario per conoscere tutta la rete è lineare con il suo diametro.</a></li>
<li><a href="#org6ab158e">Viene inoltre utilizzato il trigger update con cui i nodi vicini possono richiedere informazioni alla variazione dello stato. Ad esempio usano il trigger update i router appena accesi così chiamano velocemente informazioni nuove.</a></li>
<li><a href="#orge0a1516">Il problema di questo protocollo è che non c'è modo di aggiornare in caso di peggioramenti e questo causa un malfunzionamento abbastanza grave.</a>
<ul>
<li><a href="#orgbbf8b67">Immaginiamo che un link su un certo nodo si guasti.</a>
<ul>
<li><a href="#orgaeed69f">Il nodo stesso lo riconosce subito e aggiorna la propria tabella con valore <b>infinito</b> per il nodo dietro quel link.</a></li>
<li><a href="#orgd13099c">Gli altri nodi però non lo sanno e continuano a mandare su quel link, se la loro tabella dice che è quella la strada minore.</a></li>
<li><a href="#org09856fe">Questa situazione finisce soltanto nel momento in cui B propaga il suo distance vector con costo infinito.</a></li>
<li><a href="#org93522eb">Cosa succede se però nel frattempo un altro nodo, non ancora informato del guasto, manda il proprio distance vector al nodo che ha appena notato il guasto?</a>
<ul>
<li><a href="#org7bb9dda">Siano A, B e C i nodi, con A che vuole raggiungere C attraverso B, e il collegamento fra B e C guasto.</a>
<ul>
<li><a href="#org69cd9e0">Allora la distanza fra A e C è uguale alla distanza fra A e B più quella fra B e C</a></li>
<li><a href="#org5e444da">Il problema è che adesso la distanza fra B e C è infinita, ma quella fra A e C considera ancora il valore da B e C precedente.</a></li>
<li><a href="#org9adc95e">Allora B aggiorna la sua stessa distanza fra B e C come quella suggerita da A, che però già contiene la distanza B-C non aggiornata, più la distanza fra A e B.</a>
<ul>
<li><a href="#org1f5e05a">In pratica, B rimpiazza l'infinito con la distanza B-A più A-B più B-C vecchia.</a></li>
<li><a href="#orge110451">Alla update successiva, A vede che B ha aumentato la propria distanza di un valore uguale alla distanza A-B e aggiorna il suo valore a quella distanza, più B-A</a>
<ul>
<li><a href="#org32f2255">Quindi A rimpiazza A-B + old(B-C) con A</a></li>
<li><a href="#org26ff110">Quello che succede è questo (indico la distanza fra i nodi A o B e C):</a></li>
</ul>
</li>
<li><a href="#org6bac152">Si inizierà un <b>count to infinity</b> in cui ad ogni step la distanza verso quel collegamento aumenta della distanza fra i due nodi in questione.</a></li>
<li><a href="#org88bd480">Questo accade perchè le distanze di sia A che B verso quello guasto C contengono al loro interno la distanza A-B. Ovvero, B raggiunge C tramite A (o almeno crede di fare così) e A raggiunge C tramite B.Il sistema è innescato da B, che normalmente non dovrebbe aggiornare la propria distanza per includere quella di A, perchè il collegamento diretto con C è banalmente più breve di quello che compie un ciclo tramite A e poi ripercorre il collegamento diretto.</a>
<ul>
<li><a href="#org2ac3861">Quando però il link con C è danneggiato, accade che il ciclo attraverso A più la vecchia distanza B-C è sicuramente più breve dell'infinito e B aggiorna, senza sapere che A fa affidamento su di lui.</a></li>
<li><a href="#orga72f405">A aggiorna, senza sapere che B fa affidamento su di lui.</a></li>
<li><a href="#org797a0a7">MAIN</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5cd9988">Le due cause del problema sono il fatto che l'informazione dello specifico nodo utilizzato per raggiungere una destinazione è persa, e che i disstance vector viaggiano in modo asincrono e possono anche essere smarriti.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdd44c54">Il count to infinity da luogo al bouncing effect, in cui i pacchetti fra i nodi A e B dell'esempio precedente rimangono bloccati rimbalzando fra gli stessi.</a></li>
<li><a href="#org12e2a52">Una soluzione al <b>count to infinity</b> è lo <b>split horizon</b></a>
<ul>
<li><a href="#org063c2dd">Il distance vector riporterà costo infinito per il link corrispondente a quello utilizzato per inviare lo stesso distance vector.</a>
<ul>
<li><a href="#orgbf2794b">Di conseguenza, quando l'infinito inizia a propagarsi,</a></li>
<li><a href="#org22952b4">Con questo trucco, il distance vector non potrà contenere loop perchè un nodo non sceglierà mai di utilizzare il link che conduce ad un loop.</a></li>
<li><a href="#orgadfd157">Esiste un caso in cui il problema del count to infinity avviene anche in questo caso.</a>
<ul>
<li><a href="#org7924e7a">In particolare, lo split horizon non aiuta nel caso in cui ci siano più di due router coinvolti. Infatti, in questo caso, il nodo appena adiacente a quello su cui è avvenuto il guasto non direbbe a questùltimo di conoscere la strada, ma la direbbe ad un nodo ancora successivo e collegato al primo, su cui è avvenuto il guasto. il terzo nodo della catena avviserebbe il primo di conoscere una strada, la quale sebbene non passi per il link diretto con il nodo che ha un link guasto, passa per un ciclo che eventualmente arriverà a quel nodo. La conseguenza è la stessa.</a></li>
<li><a href="#org14f5fe0">Si può dunque dire che lo split horizon abbia un orizzonte di risoluzione di massimo 2 nodi, oltre i quali il problema è irrisolvibile.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb81ea63">I difetti sono che: 1 passo solo il peso ma non il percorso seguito ,2 non ho la topologia magliata, ma conosco solo i miei vicini,3 la propagazione è asincrona e potrei perdere qualche informazione, ovvero le tabele non sempre divergono.</a></li>
<li><a href="#org0c4bd40">Quindi le tre tecniche usate per migliorare l'efficienza di questa tecnica sono le seguenti:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org728728f">Ci rifacciamo alla stessa struttura riguardante il routing, con un router che contiene un forwarder con porte IO di ingresso ed uscita e che opera su una tabella di routing, facendo un lookup e stabilendo la corretta porta di output. Chi scrive sulla tabella è il router, che ha i propri pacchetti di controllo e opera come un processo totalmente asincrono ed indipendente.</a>
<ul>
<li><a href="#org5f94d60">Il router è attivato periodicamente, mentre il forwarder è attivato alla presenza di un pacchetto in coda di input.</a></li>
<li><a href="#orga0d2832">Vogliamo sviluppare una soluzione alternativa in cui oltre al peso e alla destinazione del cammino, si dice anche il link che si vuole utilizzare</a></li>
<li><a href="#orgf6c5c16">La gran parte delle reti fondamentali di internet, ovvero quelle intermedie fra LAN, utilizza un protocollo chiamato OSPF Link State</a>
<ul>
<li><a href="#org95f1f2d">Voglio costruirmi il grafo della connettività, con i costi di ogni arco, dopo aver scambiato abbastanza informazioni fra nodi.</a></li>
<li><a href="#org39dd88a">Ogni nodo manda la distanza sui suoi link a TUTTI gli altri nodi, quindi esistono N(N-1) messaggi di controllo</a>
<ul>
<li><a href="#org3cc760b">Questa strategia si chiama FLOODING.</a>
<ul>
<li><a href="#org00b07e7">Ogni link state viene mandato su tutte le porte IO diverse da quella di arrivo.</a></li>
</ul>
</li>
<li><a href="#org43ecd68">Il link state di uno specifico nodo continuerebbe a girare all'infinito. Allora viene introdotto un buffer che tiene l'ultimo state link e informazioni aggiuntive tipo header, contenenti l'indirizzo del mittente, un numero di sequenza associato allo specifico mittente, un TTL, ovvero un numero massimo di hops che possono essere effettuati e alla fine l'informazione vera e propria</a>
<ul>
<li><a href="#orga6aa62f">Ogni LS inviato nel flooding prevede anche un ACK</a>
<ul>
<li><a href="#orgb953ae4">Questo comporta che nella rete sia occupata da tanto traffico di controllo di livello 2</a></li>
</ul>
</li>
<li><a href="#org7728e6c">Per calcolare le distanze, si usa ICMP con il ping, calcolando la distanza con un cronometro fra l'invio ed il ritorno di un pacchetto.</a></li>
</ul>
</li>
<li><a href="#org608fde6">Le cose positive del link state sono che si conosce la topologia della rete nella sua interezza, così che attraverso Dijkstra si stabiliscano tutti i cammini minimi.</a></li>
<li><a href="#orgfe0ed83">L'implementazione dei LinkState viene effettuata da OSPF, ovvero open shortest path first.</a>
<ul>
<li><a href="#org55a837c">Il problema è che questo calcolo andrebbe fatto da ogni nodo nella rete, con un certo carico computazionale.</a></li>
<li><a href="#org3428451">La routing table conterrà la destinazione da raggiungere, il link attraverso cui si raggiunge e il costo, costruito tramite Dijkstra.</a></li>
<li><a href="#org5ecf160">Questo protocollo è MULTIPATH, ovvero salva i casi in cui due path diverse abbiano lo stesso peso, in modo da fare load balancing.</a></li>
<li><a href="#orgaad32e4">Addirittura posso obbligare un pacchetto a passare attraverso uno specifico nodo, imbullonandolo nello header.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgab6e824">Adesso immaginiamo di avere una topologia di nodi con due nodi, R1 ed R3, connessi ad una rete (ad esempio lan, ma qualunque) con netID rispettivamente 1 e 3, che contengono al loro interno uno degli host H1 e H3.</a>
<ul>
<li><a href="#org61b193a">Ogni nodo contiene anche una tabella di adiacenze, in cui ad ogni nodo è associato il link che serve per raggiungerlo</a></li>
<li><a href="#orgefe7168">Queste reti si chiamano stub, ovvero reti foglia, e contengono una tabella a loro volta, in cui è salvata la coppia netID-nodo a cui è collegata.</a>
<ul>
<li><a href="#orgd97c3df"><span class="todo TODO">TODO</span> Capire chi salva quali tabelle e in particolare chi tiene la netId table</a></li>
<li><a href="#org047c5d3">Ad esempio, nella rete con netId 1 c'è scritto che la 1 è raggiungibile direttamente e la 3 attraverso il nodo R3.</a></li>
<li><a href="#org31fc0ad">Quando H1 manda un pacchetto a H3, traduce H3 in R3. Il router R1 manda verso R1 mandando sul router successivo secondo la sua routing table, in particolare sul link associato a quel router.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org488ecd5">OSPF ruota sicuramente sulla area 0, ovvero il backbone dello Autonomous System. All'area 0 sono collegate sotto-aree che per comunicare da loro devono necessariamente passare attraverso l'area 0. L'area 0 contiene dei border-router attraverso cui passa TUTTO il traffico, intra area ed extra area.</a></li>
<li><a href="#org8707cfe">Per mettere in comunicazione AS diversi, serve avere dei link che li collegano e i router fra essi utilizzano un altro protocollo, BGP.</a></li>
</ul>
</li>
<li><a href="#orgf4ee215">Per migliorare la efficienza e generare le tabelle di routing vengono messe in atto delle tecniche avanzate, fra cui centralizzare il calcolo dei cammini minimi. Un router specifico, chiamato Designated Router, che calcola i cammini minimi per tutte i nodi e gli rimanda le tabelle già calcolate.</a>
<ul>
<li><a href="#orgd1108d9">Si riduce un po' il traffico, ma si ha lo svantaggio di congestionare i link verso lo stesso, su cui convergono le comunicazioni.</a></li>
<li><a href="#org3411b1e">Ormai tutte le reti lo usano.</a></li>
<li><a href="#org2066424">Lo spunto di eleggere un designated router è stato preso tanto bene che invece di eleggere uno dei router, si è deciso di portarlo in cloud, inventando il Software Designed Network SDN.</a>
<ul>
<li><a href="#orgf06caf3">Nella gran parte dei casi quel router si trova su cloud.</a></li>
<li><a href="#org7e20e8f">Tutto ciò è possibile perchè noi fin dall'inizio abbiamo stabilito che il piano di controllo, routing, è separato dal piano di dati, forwarding.</a></li>
<li><a href="#org221e6cb">Esiste un protocollo, Open Flow, che regola le comunicazioni con il Designated Router, anche cercando di risolvere problemi di sicurezza.</a></li>
<li><a href="#org22b59b0">A questo punto il flooding non esiste più, ma avviene una comunicazione punto punto con l'SDN o Designated Router.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org186bd41">Supponiamo di avere due macchina che ha uno strato applicativo, seguito da TCP, IP ecc&#x2026;, attaccata ad una rete IP.</a>
<ul>
<li><a href="#org93ae470">Ora immaginiamo che una macchina in mezzo a queste macchine ci sia una rete non IP.</a></li>
<li><a href="#org40de97c">La macchina centrale deve avere IP per riuscire a prendere i pacchetti e poi l'altro network per processarli correttamente. Poi andranno reinviati in IP</a></li>
<li><a href="#orga82dee4">Il TUNNELLING è il modo di gestire lo header durante il passaggio in quella macchina</a></li>
<li><a href="#orgfd0a0e8">La soluzione banale è che l'intero pacchetto, compreso header, viene incapsulato e lo header dell'altro protocollo viene semplicemente aggiunto, per poi essere rimosso dopo</a></li>
</ul>
</li>
<li><a href="#org58fe89a">TRANSPORT LAYER NUOVE LEZIONI</a></li>
<li><a href="#orgcee69f3">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).</a>
<ul>
<li><a href="#org878b286">Offre dei servizi che abbiamo già visto nel data-link.</a></li>
<li><a href="#org99c4c4a">Varie funzionalità possono essere attivate o disattivate.</a></li>
<li><a href="#org6e0dde9">TCP e UDP sono ortogonali fra loro. La prima offre disponibilità, mentre la seconda è best-effort e non aggiunge nulla ai livelli superiori.</a></li>
<li><a href="#org24ce560">A livello data-link, tra due porte di rete abbiamo una trasmissione può essere affidabile, avere controllo degli errori ecc.</a>
<ul>
<li><a href="#org2849398">Quello che non è considerato a livello data-link è se qualcosa va perso a livello network.</a>
<ul>
<li><a href="#orgcb18d2a">Un esempio è che abbiamo il nostro host con il suo livello IP.</a>
<ul>
<li><a href="#org6ea91f6">Poi abbiamo tutti questi router intermedi con i loro livelli IP e un protocollo che li leghi (non ci interessa quale).</a></li>
<li><a href="#org23d5b4c">In ogni nodo ci sono delle code di ricezione \(RX\) e di trasmissione \(RT\) che hanno una capacità limitata.</a></li>
<li><a href="#org108fc5a">Nonostante possiamo dare affidabilità al data-link, a questo livello IP, se il RT è in overflow, scarta un pacchetto e questo viene perso del tutto.</a>
<ul>
<li><a href="#org1058da9">Nonostante ci sia una somma di link affidabili, questa non garantisca che tutta la comunicazione end-to-end sia affidabile.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org60f4797">In Transport viene riimplementata l'affidabilità in modo che quando un segmento venga perso, venga gestita la ritrasmissione.</a>
<ul>
<li><a href="#orgebc289d">La trasmissione su cavo è molto affidabile e quindi l'affidabilità a livello data link è passata in secondo piano e diventa più importante quella su tratte più lunghe, con tutta la rete in mezzo, che coinvolgono i router di livello 3.</a></li>
</ul>
</li>
<li><a href="#org4e40a25">Le unità base di comunicazione a livello 4 sono chiamate <b>messaggi</b> o <b>segmenti</b>.</a></li>
<li><a href="#org1699a12">Il livello di trasporto ha anche un suo indirizzamento (naming) utilizzando le porte, che servono per identificare l'applicazione che sta utilizzando il collegamento di livello 4.</a>
<ul>
<li><a href="#org901d85a">Mentre l'indirizzo IP serve per identificare l'host di rete</a></li>
<li><a href="#orgee7c3e5">Immaginiamo di avere un client ed un server con TCP o UDP a livello 4, IP sotto e poi una rete completamente trasparente.</a>
<ul>
<li><a href="#orgfdf9988">Abbiamo poi delle applicazioni che comunicano, ad esempio app client e web server con db.</a></li>
<li><a href="#orgcf6a93c">Immaginiamo arrivi un pacchetto IP a livello server.</a>
<ul>
<li><a href="#org94729af">Il server legge il suo header e con il suo destination address sa che è destinato a lui.</a></li>
<li><a href="#orgf743330">Nello campo "protocol" ci sarà scritto se il pacchetto è da mandare ad IP o UDP.</a></li>
<li><a href="#orgb02b082">Le applicazioni ascoltano su una specifica porta (80 per http ecc.)</a></li>
<li><a href="#org98d8679">TCP si chiede: a quale di queste operazioni appartiene questo segmento? in modo da smistarlo correttamente.</a>
<ul>
<li><a href="#org5783bb3">Quindi l'IP address identifica tutto l'host, il PROTOCOL indica il protocollo di transport e la porta(?) indica l'applicazione specifica che usa i dati.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org98f5502">Anche dal lato client, si parte dall'Application layer e si sceglie il corretto protocollo (TCP/UDP) da utilizzare.</a>
<ul>
<li><a href="#orgbd5849e">Quindi l'IP e il protocollo da utilizzare sono informazioni necessarie per aprire la comunicazione.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge921a42">A livello di Trasporto si usano le socket.</a>
<ul>
<li><a href="#org2c54942">Una socket è fatta così (stessa dell'immagine sul libro):</a>
<ul>
<li><a href="#orgd4fa350">Abbiamo un ClientAP e un ServerAP (access point), che noi richiediamo semplicemente e sono offerte dal sistema operativo.</a></li>
<li><a href="#org1999207">Fra i due AP abbiamo una transport entity</a></li>
<li><a href="#orge27a0b7">Ogni applicazione contiene due buffer che sono RecevingBuffer e SendingBuffer.</a></li>
<li><a href="#org757ed4b">Le socket berkeley sono lo standard de facto, di Unix, che non è altro che un descrittore di file su cui si può effettuare scrittura e lettura.</a>
<ul>
<li><a href="#org56ae866">Una write scrive sull'SB e la read sull'RB</a></li>
</ul>
</li>
<li><a href="#org9a9097a">Poi abbiamo un istanza del protocollo TCP che se vede che va tutto bene (poi vedremo cosa vuol dire), prende carico dei dati e li trasmette in rete.</a></li>
<li><a href="#orgadc1b7a">C'è poi un altro livello di buffer, uno per ingresso e uno per uscita, aree di memoria temporanee che TCP riserva per tenere temporaneamente i pezzi di unità di informazione che devono essere ancora trasmessi.</a>
<ul>
<li><a href="#org2bf4018">TCP lavora a stream di byte e c'è un ordinamento assoluto di essi e va garantito che il ricevitore le riceva nello stesso ordine.</a></li>
<li><a href="#org15fc4c9">Immaginiamo ad esempio di inviare 1, 2 e 3 e che 2 venga perso.</a></li>
<li><a href="#org1db3f89">Dopo aver ricevuto il 3, il TCP lato client si rende conto che manca qualcosa.</a></li>
<li><a href="#org352f900">Il blocchetto 3 rimane temporaneamente in buffer e quando il blocchetto 2 arriva a destinazione, verrà sbloccato anche il successivo.</a></li>
<li><a href="#orgd0f7f29">Il buffer tcp d'uscita serve invece per tenere gli stream da mandare fino alla ricezione di un ACK.</a></li>
</ul>
</li>
<li><a href="#orgdb21bb1">Adesso, la velocità di lettura e scrittura sono diverse fra loro, diventa necessario mettere un buffer al centro.</a>
<ul>
<li><a href="#org565391e">Se una macchina genera in modo troppo veloce e l'altra troppo lenta, chiederà di rallentare la trasmissione.</a></li>
<li><a href="#orgfccad11">Siamo a livello kernel e non abbiamo tanta memoria.</a>
<ul>
<li><a href="#org744e0f9">Se non mettessimo un limite alla memoria, i buffer si saturerebbero e non rispetteremmo le specifiche di TCP che ci offre la totale affidabilità nella trasmissione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org54a908f">Con le socket si interagisce in questo modo, ovvero le API da utilizzare sono:</a>
<ul>
<li><a href="#org5b4957a">Abbiamo ancora i due access point client e server che si interfacciano con il TCP/UDP.</a>
<ul>
<li><a href="#org24bdeeb">Il livello 7 (application) è implementato nello user space.</a></li>
<li><a href="#org2a6b563">Il livello 4 è implementato nel kernel, quindi nel sistema operativo.</a></li>
<li><a href="#org9ac8588">Il livello 3 anche</a></li>
<li><a href="#org7844594">Il livello 2 sulla scheda di rete, quindi a livello firmware</a></li>
<li><a href="#orgeb67fe4">Il livello 1 è il cavo.</a></li>
</ul>
</li>
<li><a href="#orgefbe518">Nel server, ci sono:</a>
<ul>
<li><a href="#org22b77df">Una prima chiamata, bidirezionale, è <code>socket()</code>. Questa restituisce un descrittore di file aperto e bidirezionale, ovvero su cui si può leggere e scrivere.</a></li>
<li><a href="#org1d14c2c">Poi c'è l'operazione di <code>bind()</code> a cui passiamo un indirizzo IP e una porta, che lega la socket a un indirizzo IP (0.0.0.0 se ascolti su tutti gli IP della macchina). O conosciamo l'IP o utilizziamo un indirizzo DNS e la porta o la sappiamo già o è una porta well-known, come 80 o 8080 per HTTP, 443 e 8443 per HTTPS, ssh sulla 22, DNS sulla 53UDP.</a></li>
<li><a href="#orge780217">Poi abbiamo <code>listen()</code> che dice alla socket di mettersi in ascolto sull'indirizzo indicato al <code>bind()</code>. Crea inoltre una coda di richieste.</a>
<ul>
<li><a href="#orgb7aaf19">Anche qua, questa coda è finita e se arriva un bombardamento di richieste ovviamente il buffer si riempie e le successive richieste non saranno più gestite.</a></li>
</ul>
</li>
<li><a href="#orgeb91f1b">L'ultima chiamata è la <code>accept()</code>. Questa si blocca in attesa di una richiesta. Quindi è una richiesta bloccante. Aspetta che qualcuno arrivi per aprire una connessione.</a></li>
<li><a href="#orgd9202c1">A questo punto, TCP non è ancora intervenuto ma ha stabilito tutte le parti necessarie per ottenere una comunicazione</a></li>
</ul>
</li>
<li><a href="#orgdab1740">Nel client ci sono:</a>
<ul>
<li><a href="#org256998c"><code>socket</code> come prima</a></li>
<li><a href="#org0afb875"><code>connect()</code>, bloccante, in cui, come nella <code>bind()</code> specifichiamo un IP e una porta per recapitare correttamente un messaggio.</a>
<ul>
<li><a href="#orga4659be">Questa connect scatena un'apertura di connessione, (o il recapito di un messaggio in UDP), che sblocca il server attraverso la unlock, fa una <code>fork</code> che da luogo ad una nuova <code>socket()</code>, che effettuerà una nuova <code>bind()</code>.</a></li>
<li><a href="#orge15aeca">Solo a questo punto viene tirata su la struttura del TCP con i 4 buffer.</a></li>
<li><a href="#orgf989889">Quando viene effettuata la prima chiamata <code>socket</code> nel server, viene creata solo la coda di richieste.</a></li>
<li><a href="#org5a5ace2">Solo la seconda chiamata tira su tutto il sistema TCP indicato prima</a></li>
<li><a href="#org2bf2c41">La porta della sorgente è scelta randomicamente.</a></li>
</ul>
</li>
<li><a href="#org63dd900">Alla ricezione dell'ok della socket pronta dall'altra parte, si sblocca anche il client e da lì in poi la comunicazione è aperta e si possono utilizzare le system call tipiche dei file, ovvero <code>send()</code> e <code>receive()</code></a></li>
</ul>
</li>
<li><a href="#org90726e9">Quando voglio chiudere, una delle due chiama una <code>close()</code></a>
<ul>
<li><a href="#org8d9adf8">Questa chiusura coinvolge anche l'entità TCP, ma finora abbiamo soltanto osservato TCP dall'esterno.</a></li>
</ul>
</li>
<li><a href="#org0503450">Con la quintupla [protocol, ipsrc, ipdst, portsrc, portdst] posso identificare la singola comunicazione che è stata tirata su dopo la serie di procedure appena indicata.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2364efb">Il TCP garantisce che la comunicazione sia <b>affidabile</b> e <b>ordinata</b>.</a>
<ul>
<li><a href="#orgeaf031c">Opera inoltre un controllo di flusso, ovvero un controllo orizzontale, con un app sorgente che scrive e una dest che legge, entrambe ad un certo rate, in modo che non ci sia overflow.</a>
<ul>
<li><a href="#orgac695db">Questo avviene basandosi sul rate minore.</a></li>
</ul>
</li>
<li><a href="#orgcabfb96">Opera poi un controllo errori.</a>
<ul>
<li><a href="#orgd17ca81">Mentre UDP avverte in caso di errori, TCP si occupa anche di risolverli, gestendo la ritrasmissione.</a></li>
</ul>
</li>
<li><a href="#orgc9c5ac7">Opera poi un controllo di congestione, questa volta verticale.</a>
<ul>
<li><a href="#org0f5d438">E' vero che TCP nasconde la rete sottostante, ma sa che c'è una rete e sa che questa è potenzialmente inaffidabile.</a></li>
<li><a href="#orgeeb7677">Sa che se vengono immessi troppi pacchetti su una rete, questa possa essere congestionata.</a></li>
<li><a href="#org4510f3b">TCP prova ad intuire la congestione della rete e prevenire la perdita di pacchetti della rete, diminuendo il rate di trasmissione di questi ultimi.</a></li>
</ul>
</li>
<li><a href="#orgffbabd2">Inoltre, è orientata allo stream.</a>
<ul>
<li><a href="#orgb56594a">Il concetto su cui lavora è dello stream di byte, che devono arrivare tutti.</a></li>
</ul>
</li>
<li><a href="#org130f6e8">Poi, è orientato alla connessione.</a>
<ul>
<li><a href="#orgb4b1e7f">Prima di utilizzare le socket, leggervi e scrivervi, dobbiamo instaurare una connessione, aprendola, che mantiene un certo stato.</a>
<ul>
<li><a href="#orgea99e71">Il drawback è che è necessario tenere lo stato e tutte le info per la connessione in memoria nel kernel, e dev'essere occupato durante tutta la comunicazione.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb0b2b87">Lo header TCP è rappresentato in pagine larghe 32 bit.</a>
<ul>
<li><a href="#org3ce6b17">Alla prima riga abbiamo 16 bit per porta sorgente e 16 per la destinazione</a></li>
<li><a href="#orgd77ed0a">Alla seconda riga abbiamo i 32 bit per il numero di sequenza</a>
<ul>
<li><a href="#orga3713f0">Il numero di sequenza indica il primo byte della lunghezza variabile di byte che compone il segmento.</a></li>
<li><a href="#orgf793c0f">Viene inizializzato al momento dell'istanziamento della connessione.</a></li>
</ul>
</li>
<li><a href="#orgbd6f7ab">Poi abbiamo il campo ACK number, strettamente legato al precedente.</a>
<ul>
<li><a href="#org49fe76d">Identifica il numero di byte che la destinazione di questa connessione ha correttamente ricevuto e qual è l'indice del prossimo byte che mi aspetto.</a></li>
<li><a href="#org9bf0546">I due campi superiori vengono utilizzati per gestire i casi in cui ci sia una perdita di segmenti e gestire correttamente la trasmissione.</a></li>
</ul>
</li>
<li><a href="#org6be7650">Nella terza pagina abbiamo:</a>
<ul>
<li><a href="#org6a7d7e8">Poi c'è il campo TCP Header Length da 4 bit</a>
<ul>
<li><a href="#org26d3ada">La dimensione dell'header è variabile, sebbene esista una lunghezza solitamente usata.</a></li>
</ul>
</li>
<li><a href="#org529d159">Poi 4 bit non utilizzati</a></li>
<li><a href="#org2bcaafd">Poi c'è una serie di 8 bit di controllo</a>
<ul>
<li><a href="#org3085cf5">Prima il CWR, Congestion Window Reduced, che serve alla rete congestionata per notificare la situazione</a></li>
<li><a href="#org7b086d7">Poi lo ECE, &#x2026;. echo.</a>
<ul>
<li><a href="#org0f7fd66">Solo i due superiori sono presenti sul Tanenbaum ma non sull'Halsall</a></li>
</ul>
</li>
<li><a href="#org96206fc">Poi c'è un bit URGent, per indicare che certi dati sono urgenti e devono essere processati ASAP, superando l'ordinamento solito.</a></li>
<li><a href="#org771cccf">Poi c'è il campo ACK</a></li>
<li><a href="#orgf6c7a7b">Poi PUSH, che serve per mandaare via i dati contenuti nel buffer della socket.</a>
<ul>
<li><a href="#orge9649e1">Ad esempio, immaginiamo che stiamo mandando dei dati e scrivendo nel SendingBuffer.</a></li>
<li><a href="#orgb5cbd31">Il TCP riempie un segmento di una certa dimensione e poi lo manda quando ha una certa dimensione.</a></li>
<li><a href="#org568a13b">In alcuni casi, può essere necessario che tutti i dati vengano salvati immediatamente</a></li>
<li><a href="#org8e5ad1c">La differenza con lo urgent è che in questo caso il valore viene mandato da solo ma rispettando l'ordine.</a></li>
</ul>
</li>
<li><a href="#orgae4bcbd">Poi ci sono RST, SYN e FIN che non ho ascoltato. Reset, sincronizzazione e chiudi connessione.</a></li>
</ul>
</li>
<li><a href="#orgef0fe55">I restanti 16 bit di Window Size indicano lo spazio ancora disponibile nel ricevitore.</a>
<ul>
<li><a href="#org318e7c6">Chi sta trasmettendo, leggendo questo campo può capire se l'altra macchina sostiene il rate o deve rallentare.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2cb1a3d">Nella quarta pagina:</a>
<ul>
<li><a href="#orga0a4e54">Un checksum a 16 bit, che poi vedremo come viene calcolato, che ci permette di capire se tutto è corretto e viene collegato sulla base dello pseudoheader e tiene anche conto della conformità del payload (controllo degli errori)</a>
<ul>
<li><a href="#orgb2fb5d2">Lo pseudoheader è una versione ridotta dello header.</a></li>
</ul>
</li>
<li><a href="#org8593508">Poi uno Urgent Pointer, che viene letto se e solo se il frame urgent è a 1, altrimenti non ce ne frega perchè viene trascurato.</a>
<ul>
<li><a href="#org1f5c48b">Indica l'offset all'interno del campo data oltre il quale i dati sono urgent.</a></li>
<li><a href="#org1682fd7">Per convenzione, i dati urgent vengono messi alla fine del segmento e quindi non spazio per la fine della parte urgente.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcbfdd4f">Dopodichè abbiamo le options, parole di 16 bit di cui può esserci un numero variabile.</a></li>
<li><a href="#org9c389da">Dopo le n options, c'è il payload.</a></li>
</ul>
</li>
<li><a href="#org8091ea7">Come si diceva, TCP è orientato alla connessione.</a>
<ul>
<li><a href="#orgc98330d">La connessione è bidirezionale, ma noi analizzeremo solo un lato della connessione, perchè analizzare entrambe sarebbe molto confuso.</a>
<ul>
<li><a href="#org076b3df">Ognuno trasmette e riceve in modo di indipendente. Quindi la sequence e lo ACK sono relativi solo ad una direzione della connessione.</a></li>
</ul>
</li>
<li><a href="#org65a532d">All'apertura della connessione, da entrambe le macchine viene generato un sequence number ISN casuale, per ragioni di sicurezza</a>
<ul>
<li><a href="#orgc1813f6">Altrimenti si potrebbe indovinare un numero ed inserirsi nella connessione</a></li>
<li><a href="#org543a84f">I due flussi, e quindi i due numeri di sequenza, sono indipendenti.</a></li>
</ul>
</li>
<li><a href="#org08d9b61">A chiede di aprire una connessione e manda un segmento con il frame SYN = 1 e il Seq = X (quello generato casualmente da A).</a></li>
<li><a href="#org6746559">B riceve il segmento e ne manda uno di risposta in cui SYN = 1, ACK = 1, Seq = Y (quello generato casualmente da B) e Ack = x + 1.</a>
<ul>
<li><a href="#orgc447d6b">Il bit di ACK attivato indica che il valore in Ack è significativo è può essere letto.</a></li>
<li><a href="#org5f2f78a">Lo ack a x+1 indica che si è pronti ad andare avanti con la trasmissione. Il primo segmento parte da x ed è lungo 1, quindi il prossimo che sono pronto ad ascoltare è il successivo.</a></li>
</ul>
</li>
<li><a href="#orgb404532">A riceve il segmento e risponde con ACK=1 e Ack = y+1</a></li>
<li><a href="#orga76d05c">In tutti i 3 segmenti superiori, il valore del resto dello header e payload non importano.</a></li>
<li><a href="#orgcbd15f9">La procedura prende il nome di three-way handshake.</a></li>
<li><a href="#orgc3d2a5d">Gestione casi delicati</a>
<ul>
<li><a href="#orge7c6864">Viene introdotto un Timer, RTO, che gestisce il caso in cui uno fra i primi due segmenti di handshake vengano persi.</a>
<ul>
<li><a href="#org7886423">Come nel data link, se il timer scade perchè uno qualunque dei primi frame è scomparso, si prova ad aprire nuovamente la connessione.</a></li>
</ul>
</li>
<li><a href="#org0b86596">Il timer gestisce anche i casi in cui l'handshake di risposta ci impieghi troppo ad arrivare ( o si può dire che dopo il tempo \(T\) si assuma che la connessione è persa e bisogna gestire il caso in cui la risposta invece arrivi)</a>
<ul>
<li><a href="#org8ab4ec6">Ogni nuova riapertura aggiorna il SEQ casuale</a></li>
<li><a href="#org2afe986">Se arriva una risposta per un apertura precedente, è facile dal numero di sequenza capire che non sia la risposta corretta</a></li>
<li><a href="#org6e7c3e5">In tal caso, si manda un messaggio con RST e si chiude la connessione.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga81d42f">Utilizzando lo stesso concetto di base del port scanning, si può fare SYN FLOOD.</a>
<ul>
<li><a href="#orgbcf430c">Mando tanti messaggi di SYN sulle varie porte.</a></li>
<li><a href="#org43e8158">Il server mi risponde genuinamente e attende per la mia 3 risposta, finale, di handshake.</a></li>
<li><a href="#org6316a53">Io non rispondo e il server deve allocare risorse per tanti syn aperti contemporaneamente.</a></li>
<li><a href="#org6bb7e36">Se invece rispondo con un RST, non effettuo un attacco e non peso sulle risorse, ma analizzo soltanto le porte aperte.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8d7197d">Quindi siamo arrivati al SYN che uno manda per aprire la connessione, con un numero di sequenza generato in numero casuale. Il canale è bidirezionale e quindi avviene tutto nello stesso modo in entrambi gli host.</a>
<ul>
<li><a href="#org4a35ac4">Il SYN parte a 1, in risposta il SYN è a uno e anche l'ACK, che indica che il campo Ack è significativo e tale campo è numDiSequenza +1, per indicare che quello è il prossimo bit che si è pronti a ricevere.</a>
<ul>
<li><a href="#orgb1b713d">Ovviamente manda anche il proprio numero di sequenza.</a></li>
</ul>
</li>
<li><a href="#org79f9b79">Se tutto va a buon fine, la terza risposta dal sender è uguale alla seconda dal receiver e da lì in poi la connessione è aperta.</a></li>
<li><a href="#orgcc32eac">C'è un timer che garantisce che se l'ACK viene perso, o impiega troppo tempo ad arrivare, venga mandato un messaggio con RESET a 1 che annulla l'handshake, che va rieffettuato</a></li>
<li><a href="#org369f4fe">In ogni header è indicato il Max Segment Size, che indica la dimensione massima di segmento che l'host può gestire senza andare in overflow.</a>
<ul>
<li><a href="#org127bb79">La dimensione Standard, quando il campo è vuoto, il segmento è di 536 byte.</a></li>
</ul>
</li>
<li><a href="#org97bcd2a">L'obiettivo di TCP è trasferire i dati nel miglior modo, garantendo affidabilità, gest.errori, ordine ecc., e anche farlo in modo efficiente, evitando un overhead eccessivo</a></li>
<li><a href="#org7150122">Il motivo per cui viene scelta 536 byte è che siamo sicuri che il livello IP non frammenterà tale segmento in più pacchetti.</a>
<ul>
<li><a href="#org708ecef">Per ogni frammentazione effettuata dall'IP, serve copiare sia header TCP che IP, introducendo overhead.</a></li>
<li><a href="#orgafd2787">Inoltre, essendo la rete best-effort, quanti più sotto-segmenti vengono mandati quanto più è probabile che avvengano dei problemi che dovranno essere poi gestiti</a></li>
</ul>
</li>
<li><a href="#org88522cb">Immaginiamo di avere una connessione A-B in TCP, necessariamente bidirezionale.</a>
<ul>
<li><a href="#orgec68a1b">Dato che noi analizziamo solo i casi "unidirezionali", noi valutiamo solo SendingBuffer e TcpSendingBuffer nel sender, e i corrispondenti ma per il receiver nel receiver.</a></li>
<li><a href="#org90fbe8c">Assumiamo che la segment size sia 500.</a></li>
<li><a href="#org956ec3b">L'applicazione lato sender scrive 2000 byte nell'SB della socket esposto.</a></li>
<li><a href="#org4d97452">Ovviamente, va eseguita una frammentazione a livello trasporto.</a>
<ul>
<li><a href="#orgfe25b21">Assumiamo per ora che non avvengano problemi nella trasmissione.</a></li>
</ul>
</li>
<li><a href="#orgeba6369">Nel sending buffer della TCP, nascosto al livello applicazione, vengono copiati e segmentati opportunamente i byte del buffer superiore.</a></li>
<li><a href="#org7be641f">Nello header è presente l'informazione SEQ=X. Il payload sarà dal byte X a quello X + 499</a>
<ul>
<li><a href="#org7033c48">X è in realtà X+1 se la connessione è appena stata instaurata, ma per semplicità si considera X il valore corrente.</a></li>
</ul>
</li>
<li><a href="#org10abce3">Nel frattempo, il receiver si aspettava il Sequence Number = X e così si accerta che l'ordine sia corretto.</a></li>
<li><a href="#org0d8e819">I dati arrivano nel buffer inferiore, ma dato che l'ordine è corretto, vengono subito copiati nel buffer superiore.</a></li>
<li><a href="#orgf479fad">Lo header risposta del receiving buffer contiene il campo ACK a 1 e quello Ack a X + 500, che è il primo byte successivo a quello ricevuto.</a>
<ul>
<li><a href="#org48407ef">Implicitamente vuol dire che il segmento precedente è correttamente ricevuto.</a></li>
</ul>
</li>
<li><a href="#orgc124063">Il sender elimina dal buffer del TCP il segmento corrispondente.</a></li>
<li><a href="#org30f28c9">Allora, il prossimo segmento mandato è quello che parte da X+500 e questo valore è nel SEQ dello header.</a></li>
<li><a href="#org7fbf26a">Anche questo pacchetto è in ordine e quindi va subito spostato nel buffer superiore.</a>
<ul>
<li><a href="#org6eb57e0">Il TCP tiene tutti i segmenti non in ordine nel buffer inferiore.</a></li>
<li><a href="#org6d365fb">Ogni segmento correttamente ricevuto, ma successivo ad un segmento non ricevuto, rimane nel buffer inferiore.</a></li>
</ul>
</li>
<li><a href="#orgc459ccd">Analogamente al messaggio precedente, il receiver risponde con un Ack = X+1000.</a>
<ul>
<li><a href="#org5ef5d5c">Anche adesso, il sender si libera del segmento.</a></li>
</ul>
</li>
<li><a href="#org1657fe8">Procedo così fino allo svuotamento del buffer di invio.</a></li>
</ul>
</li>
<li><a href="#orge9c6f80">Nella configurazione precedente, c'è un problema nel caso in cui ho bisogno di (real-time?) ad esempio ssh su una console remota.</a>
<ul>
<li><a href="#orgf31e32d">Voglio che i dati vengano processati byte per byte</a></li>
<li><a href="#orgf3a82b7">Allora uso la flag PUSH, in modo che TCP spedisca il singolo byte, senza arrivare ad una dimensione del segmento di 500 byte come prima</a></li>
<li><a href="#orgc1a8f6c">Quando PUSH viene usata, il receiver manda un regolare ACK, con Ack X+1</a></li>
<li><a href="#orge4e09de">In questo caso, però, viene fatta una eco dello stesso byte, questa volta</a></li>
<li><a href="#org4fc03d8">Il motivo per cui viene fatta la eco è che il sender prende input a tastiera ma non mostra direttamente a schermo, perchè non è sicuro che dall'altra parte sia correttamente ricevuto. Solo quando si è sicuri che dall'altra parte sia stato ricevuto, viene stampato a tastiera</a></li>
</ul>
</li>
<li><a href="#org9e7ab83">Per garantire&#x2026;(?) viene introdotto il delay acknowledgment.</a>
<ul>
<li><a href="#org7afb419">La questione è che TCP ignora l'obiettivo delle applicazioni, ma loro lo sanno e potrebbero voler inserire più informazioni nello header.</a></li>
<li><a href="#orga25a70e">Immaginiamo una situazione come prima: si riceve un byte pushato.</a></li>
<li><a href="#orgd8eb813">Il receiver, però, non risponde subito con un Ack, ma aspetta un tempo (standard 200ms).</a></li>
<li><a href="#org081b0fc">Se in quel tempo arriva qualcosa nel buffer di invio del ricevitore, quei dati vengono incorporati nel messaggio di Ack.</a>
<ul>
<li><a href="#org8f27e17">In questo caso, sia sequence che ack number sono considerati. Seq è quello che ti do, ack quello che prendo.</a>
<ul>
<li><a href="#org95fadc3">Prima invece, il campo sequence non era mai impostato</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcf08a4e">In questo caso, quando la eco viene aggiunta nel buffer di invio della ricezione, viene inserita nello stesso frame di Ack. Così ri risparmia un messaggio TCP.</a>
<ul>
<li><a href="#orgd67c8a4">Il prossimo messaggio del sender sarà sia un ACK della echo che un send del byte successivo.</a></li>
</ul>
</li>
<li><a href="#org51c0a00">Questa soluzione è efficiente dal punto di vista di rete, ma inefficiente dal punto di vista della user-experience.</a>
<ul>
<li><a href="#org1899905">Per trovare un compromesso fra rete e user-experience, si utilizza la tecnica del <b>NAGLE</b>.</a>
<ul>
<li><a href="#org3b817da">Ho un sender con una serie di segmenti composti da un singolo byte da pushare.</a></li>
<li><a href="#org8472f26">Come prima, mando un segmento con il byte, il receiver lo riceve e aspetta 200ms.</a>
<ul>
<li><a href="#orgcac7180">L'applicazione riceve il byte e fa la ACK + echo, con SEQ = Y, PUSH attivato, ACK attivato e Ack = X + 1</a></li>
</ul>
</li>
<li><a href="#org625a319">I successivi byte vengono impacchettati in un singolo segmento e mandati tutti insieme. Il receiver risponde con l'ack.</a>
<ul>
<li><a href="#org14d9f72"><span class="todo TODO">TODO</span> Capire se viene effettuata la echo dei byte in blocco e se viene fatta byte per byte o cumulativa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8944071"></a></li>
</ul>
</li>
<li><a href="#org2f34f11">In caso di errori, è lo stesso TCP che se ne accorge e cerca di sanarlo.</a>
<ul>
<li><a href="#org0a4374b">TCP è orientato allo stream.</a>
<ul>
<li><a href="#org7aff566">Abbiamo già visto che a livello 2 ogni pacchetto è identificato da un numero che viene utilizzato per riconoscere i frame su cui avviene l'errore.</a></li>
<li><a href="#orgd7e5892">In TCP l'idea del sequence number è che, conoscendo la dimensione del file \(N\), il segmento va da \(X\) a \(X+N\).</a></li>
<li><a href="#org1ec49de">Ci interessa capire fino a che punto dello stream è stato ricevuto tutto correttamente.</a>
<ul>
<li><a href="#org981b590">Ovvero, l'indice \(K<N\) fino a cui è assicurata la comunicazione avvenuta correttamente.</a></li>
</ul>
</li>
<li><a href="#org6aeaa0d">Quindi il sequence number sommato al payload, mi da il nuovo numero di sequenza.</a></li>
<li><a href="#org4aca1dd">Immaginiamo di avere una situazione in cui l'app sender debba spedire 2400 byte con una dimensione del segmento di 500.</a></li>
<li><a href="#orged74cfe">Il primo segmento viene spedito con SEQ=X.</a></li>
<li><a href="#orge9c5362">Il secondo viene spedito senza aspettare l'ACK, con SEQ=X+500</a></li>
<li><a href="#orgf0576e2">Si immagini adesso che il secondo segmento venga perso.</a></li>
<li><a href="#org4d199b0">Nel frattempo, il receiver risponde con un ACK per il primo segmento, ovvero con Ack X + 500 e dato che il segmento è nell'ordine corretto, questo viene spedito al buffer superiore.</a></li>
<li><a href="#orgde9e891">Quando il secondo segmento è spedito ma non è stato ricevuto l'ack corrispondente, il segmento è ancora nel sending buffer del tcp del sender.</a></li>
<li><a href="#org604fc18">Comunque non aspetto l'ACK del secondo, perchè essendoci la rete per mezzo, non posso sapere se arriverà a breve o non arriverà.</a></li>
<li><a href="#org2926dd8">Quindi mando il terzo, con SEQ=X+1000.</a></li>
<li><a href="#org8e94444">Quando il receiver riceve questo segmento, lo mette nel suo buffer, ma risponde con lo stesso ACK di prima.</a>
<ul>
<li><a href="#orgac4ceb9">Ovvero, si intende che sebbene qualcosa sia ricevuto, non "riempie lo spazio" di ciò che non era stato ricevuto.</a></li>
</ul>
</li>
<li><a href="#orgdc46ecb">La questione è che ogni segmento attiva un timer. Finchè il timer non scade, TCP prosegue con <b>tutti</b> i segmenti successivi in buffer d'invio.</a></li>
<li><a href="#orga85e9e4">Quando il timer scade, soltanto quello specifico segmento viene inviato.</a></li>
<li><a href="#org9eb6a05">A questo punto, il ricevitore si renderà conto che quel segmento, il secondo in questo caso, va posizionato prima dei successivi, che già possiede nel buffer. Allora tutti quelli successivi saranno sbloccati ed il prossimo ACK li includerà. Si parla quindi di ACK cumulativo.</a></li>
<li><a href="#org1f07b7c">Questa roba si chiama <b>fast retransmit</b>, ovvero la ritrasmissione di un singolo segmento.</a></li>
<li><a href="#org2e5d87f">Il timer è pensato per considerare il caso di perdita, anche abbastanza inusuale, sovradimensionato.</a></li>
<li><a href="#orgd8a60ef">Si usa però anche una strategia del triplo ACK: al terzo ACK uguale ricevuto, viene inviato il segmento corrispondente.</a></li>
<li><a href="#org39715f4">Usando queste due strategie, si limita il danno sull'efficienza del timeout e si rende più veloce l'invio dei segmenti precedenti.</a>
<ul>
<li><a href="#org9414a7a">Ad esempio, si fa in modo che tutti i segmenti in coda nel buffer a cui serve quello perso per sbloccarsi, debbano aspettare al massimo T ma spesso anche di meno, così da ridurre lo spazio di memoria occupato.</a></li>
</ul>
</li>
<li><a href="#org36c6f51">Il timer è anche molto utile per gli ultimi (?)2 segmenti, dopo i quali non esistono 3 ack che facciano partire la ritrasmissione.</a>
<ul>
<li><a href="#org0ddf778"><span class="todo TODO">TODO</span> Per quanti segmenti vale questa proprietà</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3f50fe8">Negle ha un utilità quando vogliamo garantire un utilizzo efficiente della rete.</a>
<ul>
<li><a href="#orgc085dba">Lo si usa al posto di mandare ogni carattere da solo, con un overhead altissimo dovuto allo header IP e TCP.</a>
<ul>
<li><a href="#org9c0f8c9">Per mandare un byte, mi servono 4 messaggi.</a></li>
<li><a href="#orgfe24cd3">Si usa il delay per diminuire i messaggi che vengono mandati, ma si paga troppo tempo per l'attesa del delay ogni volta, con piggy bagging in cui nei dati da comunicare si inserisce anche l'ack cumulativo</a></li>
<li><a href="#org2b1eaca">Un compromesso e il nagle</a></li>
</ul>
</li>
<li><a href="#orga18f056">Il Nagle viene in supporto quando abbiamo un quantitativo di dati dall'applicazione, ovvero nel SB (superiore) che è minore alla maximum segment size.</a>
<ul>
<li><a href="#orgb3be167">Nagle innanzitutto guarda il TCP Sending Buffer (quello inferiore). Se è vuoto vuol dire che non sto aspettando nessun ACK.</a>
<ul>
<li><a href="#org91bb292">In questo caso, invio direttamente il contenuto dell'SB, nonostante sia inferiore.</a></li>
</ul>
</li>
<li><a href="#org9d2b855">Se invece ci sono altri segmenti nel buffer inferiore, lo accoda.</a></li>
<li><a href="#orgb8c6e61">Uno dei lati negativi di Nagle è che sebbene utilizzi bene la rete, ovvero limitando l'overhead, (QUAL è L'ASPETTO NEGATIVO)?</a></li>
</ul>
</li>
<li><a href="#orgd69112e">Un altro aspetto è che tcp è orientato allo stream e ragiona in base ai bit.</a>
<ul>
<li><a href="#org8b90cf5">Una sequenza di dati presente nel sending buffer non dev'essere multiplo della max segment size. Il TCP suddivide in blocchetti della dimensione corretta.</a>
<ul>
<li><a href="#org7bcad21">Se un ultimo blocchetto non raggiunge la max segment size, sta all'applicazione decidere se mandarlo subito o se aspettare nuovi dati, la cui prima parte verrà aggiunta all'ultimo segmento e mandata tutto insieme.</a></li>
</ul>
</li>
<li><a href="#orga713985">Quindi si parla di segmento numero n come divisione logica, ma tutto è relativo al byte di inizio sequenza.</a></li>
<li><a href="#org5551980">Il principio è che si occupa il meno possibile. L'eventuale padding è fatto ai livelli inferiori.</a></li>
</ul>
</li>
<li><a href="#org42c0bb3">Quando TCP invia un pacchetto ad IP, quest'ultimo, conoscendo perfettamente la max transfer unit del suo livello 2, frammenta ulteriormente se necessario.</a>
<ul>
<li><a href="#org3cb370e">IP stesso riassemblerà poi la serie di pacchetti e la fornirà a tcp</a></li>
<li><a href="#org18520ee">Se non ci riesce, a TCP non arriverà assolutamente nulla.</a>
<ul>
<li><a href="#orgb80414d">Inoltre, solo il primo pacchetto avrà lo header tcp.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org391b8a0">Come abbiamo già visto, il round trip time è il tempo necessario perchè un segmento venga inviato ed ackAto.</a>
<ul>
<li><a href="#orgc18b325">Possiamo però anche inviare più segmenti nello stesso momento.</a></li>
<li><a href="#org863348b">Ogni segmento fa partire un timer, che dev'essere dimensionato correttamente e quindi non può essere statico.</a></li>
<li><a href="#org74b4664">Esiste uno standard che ci spiega come calcolarlo</a>
<ul>
<li><a href="#org6cd48c7">Diciamo che il round trip time in media impieghi 30 ms</a></li>
<li><a href="#org5b2f1c1">La stima viene fatta considerandolo come un outlier della distribuzione.</a>
<ul>
<li><a href="#orgaaadd7f">Tipicamente si dice che un valore di +3sigma, quindi media più 4 deviazioni standard ci da una stima di un caso molto raro di outlier.</a></li>
<li><a href="#org5fd2948">Quindi dobbiamo sapere la media e la deviazione standard in base ai dati del round trip time.</a>
<ul>
<li><a href="#org1d457dd">INSERIRE FORMULA</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org13990b6">Il controllo di flusso viene messo in atto quando il produttore produce molto più velocemente del ricevente.</a>
<ul>
<li><a href="#orge271806">Infatti, il buffer di ricezione andrebbe poi in overflow.</a>
<ul>
<li><a href="#org6c49477">Immaginiamo di avere una situazione in cui il sending buffer è di 3000 e il receiving 2000. (mss sempre 500 (ma standard 512)).</a>
<ul>
<li><a href="#orgcb9ff54">L'informazione della dimensione dell'altro è nota ad entrambi.</a></li>
<li><a href="#org14b05a4">Una volta che il sender ha mandato 2000 bit (in 4 tranche perchè la finestra è di 500), il receiving manda non solo un ACK per controllo errori, ma anche un WIN=0, per il controllo di flusso, che indica che lo spazio è finito.</a></li>
<li><a href="#org8af79f2">Quando avrà poi letto 1000 byte, manderà un ACK con lo stesso byte atteso del precedente, ma una window size di 1000.</a></li>
</ul>
</li>
<li><a href="#org41f9561">Il problema è che se il secondo ack di riapertura viene perso, il sender rimarrebbe bloccato per sempre, ovvero si avrebbe un deadlock.</a>
<ul>
<li><a href="#orgc40fde9">Allo scadere di un Persist Timer nel receiver, viene mandato un segmento speciale vuoto, ovvero senza dati, a cui il receiver risponde con un reinvio dell'ack con nuova finestra.</a>
<ul>
<li><a href="#orga116e27">Se anche quel nuovo ack è perso, allo scadere di un nuovo timer la connessione sarebbe chiusa.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgae545f3">Il problema della silly window syndrome accade quando il receiver riempie la propria window e continua a notificare la nuova disponibilità ma per una quantità di byte minima.</a>
<ul>
<li><a href="#orgfc8453e">La soluzione è l'algoritmo di Clark, in cui l'aggiornamento della windows dev'essere almeno grande come la MSS o come la metà del buffer.</a></li>
</ul>
</li>
<li><a href="#org5af507a">La rete ignora completamente il controllo di flusso.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org149aae6"><span class="todo TODO">TODO</span> Riempire con ultime 2 lezioni di livello 4</a></li>
<li><a href="#orgc668dca">Iniziamo il livello applicazione parlando del DNS, ovvero il Domain Name System.</a>
<ul>
<li><a href="#orge0cbd2e">E' un sistema che permette di rendere più semplice raggiungere un host</a>
<ul>
<li><a href="#orgee697e9">Normalmente si usa un IP per raggiungere un host, ma è praticamente impossibile ricordare un IP.</a></li>
</ul>
</li>
<li><a href="#orgaebad13">Funziona associando un nome (dominio) all'ip di uno specifico host.</a>
<ul>
<li><a href="#orgb0cf427">Permette anche di recuperare altre informazioni</a></li>
</ul>
</li>
<li><a href="#org3ffa469">L'idea è quella di disaccoppiare il modo in cui un essere umano raggiunga un certo servizio.</a>
<ul>
<li><a href="#org5b11c5c">Ad esempio il servizio potrebbe cambiare indirizzo ip in modo trasparente agli utenti.</a>
<ul>
<li><a href="#org2eb4f2f">Questo è utilizzato anche per il load balancing, così che il traffico venga diviso su diversi server.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2fd1e69">Il fully qualified domain name (FQDN) contiene un punto alla fine che indica il root domain</a></li>
<li><a href="#org25b72aa">Il modo in cui avviene la risoluzione del FQDN fra due macchine, ovvero fra un host che richiede e il server che risponde, è sostituendo ad ogni punto il numero di caratteri che seguono quel punto prima di quello successivo, esempio 2DI5UNIMI2IT0.</a></li>
<li><a href="#org8389264">Una query DNS contiene uno header, il FQDN specifico, il tipo di query(A, AAAA, Mx), la classe (che indica la rete su cui si vuole risolvere, che di fatto è sempre internet)</a>
<ul>
<li><a href="#org5db6117">Il tipo può essere2 A per IPv4, AAAA per IPv6, MX per posta, CNAME (canonical name) che è un altro nome per lo stesso sito</a></li>
</ul>
</li>
<li><a href="#org2f520a9">La risposta ricopia i dati e inserisce l'indirizzo nell'ultimo campo.</a></li>
<li><a href="#org450da38">Un record DNS in cache può essere associato ad uno specifico TTL, dopo il quale il record scade e la prossima richiesta effettuata da qualunque client dovrà essere risoluta di nuovo</a>
<ul>
<li><a href="#org9c5a8cd"><span class="todo TODO">TODO</span> Capire funzionamento in caso di record scaduto</a></li>
</ul>
</li>
<li><a href="#org9637bb1">Il resolving DNS avviene con un client che chiede la risoluzione di uno specifico FQDN al resolver all'interno della stessa macchina.</a>
<ul>
<li><a href="#org55190f4">Il resolver usa UDP perchè non gli serve instaurare la connessione e parla con il Local DNS, che viene impostato in fase di configurazione.</a></li>
</ul>
</li>
<li><a href="#org54b497e">A livello globale ci sono dei root DNS servers che contengono soltanto i domini di primo livello, con gli IP corrispondenti dei NameServer.</a>
<ul>
<li><a href="#orgef596cf">Usiamo questi se non sappiamo come raggiungere il dominio di primo livello, che di solito però conosciamo già perchè rimane in cache</a></li>
<li><a href="#orgc970664">Sul libro sono indicati due approcci, uno iterativo e uno ricorsivo, ma gli esempi sono tutti iterativi.</a>
<ul>
<li><a href="#org87cd323">L'approccio ricorsivo funziona con il resolver che manda una query al local dns e quest'ultimo risponde con l'indirizzo già pronto.</a>
<ul>
<li><a href="#org7e6346f">Non è implementata nei server per questioni di scalabilità.</a></li>
<li><a href="#org6cafc50">Il problema è che sebbene sia molto comoda per il client, il resolver dovrebbe mantenere tantissime informazioni di stato in attesa dei passi successivi.</a></li>
</ul>
</li>
<li><a href="#org7d95c94">L'approccio iterativo si applica dal local dns in poi, mentre fra resolver e local dns rimane ricorsivo, ovvero il local dns mantiene lo stato della richiesta fino all'invio della risposta al resolver.</a>
<ul>
<li><a href="#orga98ba2c">Il client continua a ricevere una risposta valida già pronta.</a></li>
<li><a href="#org2193f4c">Il local DNS, però, gestisce in modo iterativo.</a>
<ul>
<li><a href="#orgb8200e7">Manda l'intero dominio al root, che conosce però solo l'IP di primo livello e risponde con un informazione parziale, ovvero con l'indirizzo del NS di primo livello.</a></li>
<li><a href="#org6a7d73d">Una volta conosciuto quello di primo livello, si chiede al corrispondente NameServer di risolvere la parte rimanente del dominio.</a>
<ul>
<li><a href="#org9328b07">Questo risponde con l'indirizzo del DNS Server del secondo livello.</a></li>
</ul>
</li>
<li><a href="#org83f3c26">Se il dominio era composto da tre livelli, il DNS server di secondo livello risponde con l'IP specifico</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0f75bf7">Anche l'approccio iterativo richidede un overhead per il primo step, che viene attenuato dall'utilizzo della cache.</a>
<ul>
<li><a href="#orgdf551e4">In questo modo, la prossima volta che verrà richiesto un dominio di terzo livello appartenente allo stesso secondo livello, la richiesta verrà effettuata direttamente al Name Server di secondo livello.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgddb2ba4">Ultima lezione</a></li>
</ul>
</div>
</div>
<div id="outline-container-org08bb564" class="outline-2">
<h2 id="org08bb564">References</h2>
<div class="outline-text-2" id="text-org08bb564">
<p>
<a href="https://computer.howstuffworks.com/ethernet.htm">How Ethernet works</a>
<a href="https://intronetworks.cs.luc.edu/1/html/index.html">Exercises from Chicago University</a>
</p>
</div>
</div>
<div id="outline-container-org29180fd" class="outline-2">
<h2 id="org29180fd">Host computer dove risiedono le app finali e un sistema di rete composto da un insieme di nodi e link.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org2228452" class="outline-2">
<h2 id="org2228452">Gli unici dati che viaggiano nel sistema sono denominati pacchetti, di dimensione massima fissa. Semplifica l'architettura dei nodi di switch, cioè i router, che svolgono funzionalità di instradamento. In questo modo ogni router si occupa soltanto di ricevere e smistare i pacchetti su link stabiliti in base a metriche di instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd6cc51b" class="outline-2">
<h2 id="orgd6cc51b">Una divisione funzionale delle varie parti è: il sistema di reti, attraverso ip, decide il percorso migliore in base a quel momento specifico (le condizioni variano nel tempo), concetto chiamato instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org5df9786" class="outline-2">
<h2 id="org5df9786">Pacchetti con stesso mittente e destinatario non necessariamente percorrono lo stesso cammino. Non solo la comunicazione non è affidabile, ma anche ogni pacchetto è completamente indipendente dagli altri, sebbene siano tutti risultato dello stesso processo di frammentazione da parte dell'host. Servirà poi un modo per reassemblarli a destinazione.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgaf438d0" class="outline-2">
<h2 id="orgaf438d0">Ogni pacchetto è indipendente, ma in qualche modo verrà ricostruito, quindi c'è qualche legame logico fra il singolo frammento e l'unità generale. Finchè i pacchetti sono nel sistema di rete, questo collegamento è perso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org950ccae" class="outline-2">
<h2 id="org950ccae">A questo punto abbiamo definito dei concetti come affidabilità e valori tempo di trasmissione, tempo di propagazione, round-trip tie, error-rate su un canale, gitter, che tornano.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org3605f48" class="outline-2">
<h2 id="org3605f48">Abbiamo identificato le componenti architetturali di una rete, con link fra router e host, entrambi con software e funzioni utili alla comunicazione, IP lato router e TCP lato host&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org763e335" class="outline-2">
<h2 id="org763e335">Adesso analizzeremo le altre componenti della rete, e come sono organizzate all'interno della struttura, le varie funzioni di rete.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orge526da8" class="outline-2">
<h2 id="orge526da8">Per la struttura gerarchica a 5 (7) livelli, i collegamenti fra le due macchine sorgente e destinazione sono allo stesso livello. Non sono ammesse cross-layer communication.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org84cbc5f" class="outline-2">
<h2 id="org84cbc5f">Finora abbiamo capito come, su un canale che collega il nodo a al nodo b, inviare frame in modo affidabile (rimando alle 3 condizioni)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org36124a3" class="outline-2">
<h2 id="org36124a3">A volte la topologia di rete è un grafo parzialmente connesso e in particolare in cui i punti sono collegati fra loro in una <b>maglia</b>, ed è per questo chiamata anche punto-a-punto, ma spesso non è così.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgb0469e7" class="outline-2">
<h2 id="orgb0469e7">Di solito, alla salita del fronte d'onda, legge il valore in volt, e se è 5 il bit è 1, altrimenti 0&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgbc3728a" class="outline-2">
<h2 id="orgbc3728a">Per stabilire l'utilizzo (efficienza) del mio MAC layer, che presiede la connessione Ethernet, bisogna introdurre al tempo di propagazione, nella formula originale, ovvero tx su tx + 2tp, il contention time medio, ovvero il tempo perso in carrier sense, nel discardare trasmissioni corrotte e nei ritardi. (Bisogna sommare l'inverso (perchè?), e quindi 1/A)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org1eb8280" class="outline-2">
<h2 id="org1eb8280">Per aumentare le prestazioni di Ethernet, potrei scalare il tasso di trasmissione di un ordine di grandezza. Il problema è che il rame non va oltre 25Mbps.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd77b681" class="outline-2">
<h2 id="orgd77b681">Nell'architettura Ethernet, il primo apparato utilizzato è il repeating hub, passivo, in cui tutte le stazioni contendono per il canale di trasmissione. Gli hub sono collegati da un bridging hub, attivo, che attraverso il principio di Store-and-Forward, separa i domini di collisione dei vari hub. Un bridge ha tante porte ethernet quanti sono i domini collegati. Inoltre, contiene una tabella aggiornata ogni volta che riceve una comunicazione (bridge trasparente). Quando la comunicazione è destinata a una stazione non salvata in tabella, fa flading.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orge6c8b46" class="outline-2">
<h2 id="orge6c8b46">A livello superiore, c'è uno switch, che funziona come un hub, ma con una memoria ed una cpu, per memorizzare e switchare in modo intelligente. Le connessioni da e per lo switch NON richiedono Carrier Sense, perchè sono punto-punto, in quanto già univocate dal bridge. Il cavo utilizzato è un duplex e può essere anche in fibra. Le porte sono comunque compliant con IEEE nel formato della porta.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org2af6a5a" class="outline-2">
<h2 id="org2af6a5a">Nel CSMA-CD, l'efficienza è \(\frac{1}{1+\frac{2BL}{CF}e}\), quindi se aumento la Bandwidth, devo necessariamente ridurre la lunghezza e aumentare la dimensione del frame.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd2c93e7" class="outline-2">
<h2 id="orgd2c93e7">Notiamo che nel Data-Link, a questo punto, non ci sono più collegamenti punto-punto, ma un MAC layer, che controlla l'accesso a un canale condiviso.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org71205b8" class="outline-2">
<h2 id="org71205b8">Una VLAN viene utilizzata per introdurre una nuova divisione virtuale fra stazioni. Un motivo per cui viene utilizzata è per aumentare la sicurezza.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org98d5d71" class="outline-2">
<h2 id="org98d5d71">Per riassumere i primi 2 livelli, sono entrambi composti da due sottolivelli.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-orgd570d63" class="outline-2">
<h2 id="orgd570d63">Le LAN occupano spazi geografici molto limitati. E' necessario collegare LAN, anche lontane, così che siano tutte raggiungibili. Per farlo, vengono collegate ad uno strato superiore, che sarebbe l'ISP, fino ad arrivare ad un terzo strato che è quello intercontinentale.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org90fd521" class="outline-2">
<h2 id="org90fd521">Nel livello 3 dobbiamo gestire l'indirizzamento e l'instradamento.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org56b2f6c" class="outline-2">
<h2 id="org56b2f6c">Riguardo l'indirizzamento IP, abbiamo visto metodi per garantire l'unicità dell'indirizzo. Abbiamo visto il subnetting, che va di pari passo con il metodo CLASS based. Subnetting non nasce con l'obiettivo di superare il limite delle classi, ma è trucco organizzativo per inserire un nuovo livello gerarchico per gestire le reti in modo che riflettano di più la struttura.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org660452f" class="outline-2">
<h2 id="org660452f">Sebbene l'indirizzamento sia parte del livello 3 a livello globale, ogni livello possiede il proprio indirizzo per comunicare con altre macchine.</h2>
<div class="outline-text-2" id="text-org660452f">
</div>
<div id="outline-container-org204fbd7" class="outline-3">
<h3 id="org204fbd7">A livello 2, in una rete CSMA-CD l'indirizzo è il MAC</h3>
</div>
<div id="outline-container-org8d5798d" class="outline-3">
<h3 id="org8d5798d">A livello 3, l'indirizzo è quello IP, con tutte le considerazioni fatte in precedenza.</h3>
</div>
<div id="outline-container-org6ba3a9a" class="outline-3">
<h3 id="org6ba3a9a">Un problema che dobbiamo risolvere è quello di mappare l'IP al corrispondente MAC.</h3>
<div class="outline-text-3" id="text-org6ba3a9a">
</div>
<div id="outline-container-org26357e9" class="outline-4">
<h4 id="org26357e9">Infatti, finora non c'è nessun modo per far arrivare un pacchetto a destinazione.</h4>
</div>
</div>
<div id="outline-container-org5afbdb1" class="outline-3">
<h3 id="org5afbdb1">Immaginiamo che A e B siano sulla stessa rete locale.</h3>
<div class="outline-text-3" id="text-org5afbdb1">
</div>
<div id="outline-container-org6f09a11" class="outline-4">
<h4 id="org6f09a11">Se la macchina A manda un pacchetto al modulo B, chiede ad ARP di risolvere l'IP in un MAC address, così che possa mandarglielo attraverso il livello 2</h4>
</div>
<div id="outline-container-org410d6bd" class="outline-4">
<h4 id="org410d6bd">In pratica l'ARP, per conto di IP, manda ai livelli sottostanti una richiesta, ARPRequest, così che il dispositivo in questione risponda con un ARPReply, rispondendo con il proprio MAC, che ARP fornirà al livello IP della macchina sorgente.</h4>
<div class="outline-text-4" id="text-org410d6bd">
</div>
<div id="outline-container-org8df1b1b" class="outline-5">
<h5 id="org8df1b1b">Le due macchine, nell'esempio, si trovano nella stessa rete. Ovviamente, nella richiesta non si sa chi sia l'host destinazione, quindi è necessario fare una richiesta broadcast. La risposta sarà, invece, punto-punto.</h5>
</div>
</div>
</div>
<div id="outline-container-org35e506c" class="outline-3">
<h3 id="org35e506c">Immaginiamo adesso che siano su macchine diverse.</h3>
<div class="outline-text-3" id="text-org35e506c">
</div>
<div id="outline-container-org1883350" class="outline-4">
<h4 id="org1883350">A manda richiesta a Z, su un'altra rete.</h4>
</div>
<div id="outline-container-org8dc75cf" class="outline-4">
<h4 id="org8dc75cf">Il site access gateway leggerà il NETID e vedrà che non appartiene alla rete locale e che quindi va cercato al di fuori. Prenderà lui in carico l'operazione.</h4>
</div>
<div id="outline-container-org11706b8" class="outline-4">
<h4 id="org11706b8">A questo punto, risponderà con il proprio MAC, in modo che A mandi le richieste al gateway.</h4>
</div>
<div id="outline-container-org735f945" class="outline-4">
<h4 id="org735f945">Il gateway aspetterà autonomamente per la ARPReply della macchina remota e salverà il risultato.</h4>
</div>
<div id="outline-container-orga026032" class="outline-4">
<h4 id="orga026032">Questo servizio si chiama ProxyARP.</h4>
</div>
</div>
<div id="outline-container-org63d2c82" class="outline-3">
<h3 id="org63d2c82">ARP in ogni dispositivo terrà una ARP Cache, in cui salverà tutte le associazioni IP-MAC, così che le volte successive non servirà una nuova richiesta.</h3>
</div>
<div id="outline-container-org1687419" class="outline-3">
<h3 id="org1687419">Quindi uso ARP per fare una discovery delle macchine che sono raggiungibili in rete.</h3>
</div>
<div id="outline-container-org05de959" class="outline-3">
<h3 id="org05de959">Anche in questo caso, abbiamo un livello 3 che per funzionare (anzi, il suo obiettivo) è di livello 2. Deve infatti andare a toccare il MAC, indirizzo di livello 2, ma in questo caso almeno fa una richiesta</h3>
</div>
<div id="outline-container-orgb1aedc9" class="outline-3">
<h3 id="orgb1aedc9">Notiamo che nello header di livello 3, il campo type è usato anche per identificare se la richiesta sia IPv4 o ARP</h3>
</div>
</div>
<div id="outline-container-org8527999" class="outline-2">
<h2 id="org8527999">Introduciamo il DHCP</h2>
<div class="outline-text-2" id="text-org8527999">
</div>
<div id="outline-container-org51adb1a" class="outline-3">
<h3 id="org51adb1a">Abbiamo tante macchine collegate ad una LAN, che possono essere nostre oppure di ospiti che arrivano transitoriamente. Come assegniamo l'IP privato alle macchine?</h3>
<div class="outline-text-3" id="text-org51adb1a">
</div>
<div id="outline-container-orge3c1718" class="outline-4">
<h4 id="orge3c1718">La LAN potrebbe essere Wireless, collegata tramite un Access Point ad una Lan fisica, che tramite il suo Access Gateway è collegata alla rete fisica.</h4>
</div>
</div>
<div id="outline-container-org20921fd" class="outline-3">
<h3 id="org20921fd">Il Gateway riesce a fare Address Resolution e quindi è anche un NAT. Ovvero, riesce a mascherare un indirizzo interno.</h3>
<div class="outline-text-3" id="text-org20921fd">
</div>
<div id="outline-container-org914f990" class="outline-4">
<h4 id="org914f990">Ci presenta con un IP pubblico alla rete, ma poi smista alle macchine singole con gli indirizzi privati.</h4>
</div>
</div>
<div id="outline-container-org6435daf" class="outline-3">
<h3 id="org6435daf">Questi indirizzi potrebbero esere statici, ma questo è scomodo. (Perchè?).</h3>
</div>
<div id="outline-container-orgbd0dcf3" class="outline-3">
<h3 id="orgbd0dcf3">E' più comodo se al momento della prima connessione alla rete, venga assegnato un IP dinamico al dispositivo, che rimanga fino allo spegnimento.</h3>
</div>
<div id="outline-container-orge5b2d9b" class="outline-3">
<h3 id="orge5b2d9b">Per assegnare l'IP dinamico, usiamo il server DHCP (eventualmente molteplici)</h3>
<div class="outline-text-3" id="text-orge5b2d9b">
</div>
<div id="outline-container-org6d7f3af" class="outline-4">
<h4 id="org6d7f3af">Appena una macchina cliente viene bootata, fa un operazione di Request DHCP al server, che farà a sua volta una Reply.</h4>
</div>
<div id="outline-container-org659ee39" class="outline-4">
<h4 id="org659ee39">La reply assegna un IP privato, valido per tutto il tempo necessario.</h4>
<div class="outline-text-4" id="text-org659ee39">
</div>
<div id="outline-container-org18913ba" class="outline-5">
<h5 id="org18913ba">Addirittura, un DHCP address ha un TimeToLeave, poi viene buttato e refreshato.</h5>
</div>
<div id="outline-container-orged15ddb" class="outline-5">
<h5 id="orged15ddb">Al punto che quando arriva un ospite (abilitato ad accedere alla rete), loro parlano con DHCP e diventano a tutti gli effetti parte della rete.</h5>
</div>
</div>
<div id="outline-container-org3979ad1" class="outline-4">
<h4 id="org3979ad1">La RequestForComment che lo definisce è la 2131.</h4>
</div>
<div id="outline-container-org1197186" class="outline-4">
<h4 id="org1197186">Il client triggera la richiesta, che nello specifico si chiama DHCP Discover.</h4>
<div class="outline-text-4" id="text-org1197186">
</div>
<div id="outline-container-org3500952" class="outline-5">
<h5 id="org3500952">Questa discover è un pacchetto IP che viaggia con sorgente 0.0.0.0, perchè non so scriverlo ed è proprio per questo che mando la richiesta.</h5>
</div>
<div id="outline-container-org4e74ceb" class="outline-5">
<h5 id="org4e74ceb">La destinazione è 255.255.255.255. Un pacchetto broadcast all'interno della LAN. Non va direttamente al server DHCP. Il motivo è che se io voglio un assegnamento dinamico per ogni macchina, anche non appartenenti alla mia rete, non posso assumere che questi sappiano l'indirizzo del server DHCP.</h5>
</div>
<div id="outline-container-orgdbe3eac" class="outline-5">
<h5 id="orgdbe3eac">Inoltre, se io mettessi un singolo IP, perderei la possiblità di avere molteplici DHCP server, utilizi banalmente per ridondanza.</h5>
</div>
<div id="outline-container-org3c24ec8" class="outline-5">
<h5 id="org3c24ec8">Poi c'è un campo Time To Live,  con un Transaction ID, che viene associato all'indirizzo della macchina.</h5>
<div class="outline-text-5" id="text-org3c24ec8">
</div>
<div id="outline-container-orgcfe6b88" class="outline-6">
<h6 id="orgcfe6b88">Questo serve per associare le request alle response</h6>
</div>
<div id="outline-container-org4937bb1" class="outline-6">
<h6 id="org4937bb1">Per identificare questo Time To Live con il client della richiesta, non può essere utilizzato l'IP, ma necessariamente il MAC di livello 2.</h6>
</div>
</div>
</div>
<div id="outline-container-org9763e01" class="outline-4">
<h4 id="org9763e01">Il server riceve la richiesta e reagisce con una DHCP Offer.</h4>
<div class="outline-text-4" id="text-org9763e01">
</div>
<div id="outline-container-orgfb66ed0" class="outline-5">
<h5 id="orgfb66ed0">Quello che offre il DHCP server è l'IP address.</h5>
</div>
<div id="outline-container-org3f3c289" class="outline-5">
<h5 id="org3f3c289">Sarà sempre un pacchetto con sorgente IP del Server, broadcast e lo stesso transactionID della richiesta.</h5>
<div class="outline-text-5" id="text-org3f3c289">
</div>
<div id="outline-container-org89c7b8b" class="outline-6">
<h6 id="org89c7b8b">Deve necessariamente essere broadcast.</h6>
</div>
</div>
<div id="outline-container-org202940c" class="outline-5">
<h5 id="org202940c">Prima di fare la offer, il server fa un check. Il check dell'IP prevede che tramite ICMP il server sia in grado di verificare se per caso quell'IP non sia stato già assegnato a qualcuno per errore.</h5>
<div class="outline-text-5" id="text-org202940c">
</div>
<div id="outline-container-org3edc76b" class="outline-6">
<h6 id="org3edc76b">In pratica fa un ping, che prevede un echo se la stazione è raggiungibile. Se l'echo è assente, l'IP non è stato associato a nessuno. Altrimenti l'IP va aggiornato.</h6>
</div>
</div>
</div>
<div id="outline-container-org5412876" class="outline-4">
<h4 id="org5412876">A questo punto il client ha <b>apparentemente</b> risolto il suo problema.</h4>
<div class="outline-text-4" id="text-org5412876">
</div>
<div id="outline-container-orgaf78a9e" class="outline-5">
<h5 id="orgaf78a9e">Si può immaginare che il client abbia un timeout in modo che non trascorra troppo prima dell'arrivo di una offer. (Stesso principio dell'ACK).</h5>
</div>
<div id="outline-container-orgd7babf5" class="outline-5">
<h5 id="orgd7babf5">Il problema è che un algoritmo di questo tipo funzionerebbe se e solo se ammettesse uno e un solo server DHCP operativo per ogni rete, ma il protocollo è fatto per funzionare con un numero arbitrario di server.</h5>
<div class="outline-text-5" id="text-orgd7babf5">
</div>
<div id="outline-container-orge57537a" class="outline-6">
<h6 id="orge57537a">Infatti, la discover è in broadcast e arriva a tutti i server, che si adopereranno tutti per offrire un IP.</h6>
</div>
</div>
<div id="outline-container-org15f0a07" class="outline-5">
<h5 id="org15f0a07">Bisogna garantire che venga accettata l'offerta di un solo server.</h5>
</div>
</div>
<div id="outline-container-orgc5709d8" class="outline-4">
<h4 id="orgc5709d8">Diventa necessaria un ulteriore fase, una commit, chiamata DHCP Request.</h4>
<div class="outline-text-4" id="text-orgc5709d8">
</div>
<div id="outline-container-org82feb32" class="outline-5">
<h5 id="org82feb32">Questa viaggia con stesse sorgente e destinazione della discover (0 e 1Broadcast), ma con un ulteriore campo scelta, che contiene un ID del server la cui offerta è stata accettata.</h5>
</div>
</div>
<div id="outline-container-orgc0400fe" class="outline-4">
<h4 id="orgc0400fe">A questo punto, si chiude il commitment con una DHCP Ack, che è una validazione della request. Anche questo è mandato in broadcast secondo IP.</h4>
<div class="outline-text-4" id="text-orgc0400fe">
</div>
<div id="outline-container-orgf874699" class="outline-5">
<h5 id="orgf874699">Ricordare che tutte queste comunicazioni di risposta da parte del server, utilizzano il MAC di livello 2 e sono quindi Unicast.</h5>
</div>
</div>
<div id="outline-container-org2ba6e89" class="outline-4">
<h4 id="org2ba6e89">Questo protocollo è un protocollo a 4 vie, a causa della necessità di selezionare fra i vari server.</h4>
</div>
<div id="outline-container-orgf82ad58" class="outline-4">
<h4 id="orgf82ad58">Servono inoltre dei check per verificare la validità degli IP, anche dal punto di vista del client.</h4>
<div class="outline-text-4" id="text-orgf82ad58">
</div>
<div id="outline-container-org52e80f6" class="outline-5">
<h5 id="org52e80f6">Viene utilizzato ARP, che è perfetto per questo lavoro, ovvero risolvere un IP in un MAC.</h5>
<div class="outline-text-5" id="text-org52e80f6">
</div>
<div id="outline-container-orga8b070f" class="outline-6">
<h6 id="orga8b070f">Facendo una ARP request con l'IP appena assegnato al server, in caso di risposta positiva si capisce che l'IP è già assegnato.</h6>
</div>
</div>
</div>
<div id="outline-container-org47bd7d9" class="outline-4">
<h4 id="org47bd7d9">Esistono dei meccanismi di ricovero, per gestire i casi in cui i messaggi vengano persi. Si utilizza ad esempio un timer T, che viene eseguito massimo K volte (numero di retry). Una volta aver provato K volte, si ritorna alle origini e si ricomincia da capo.</h4>
</div>
</div>
</div>
<div id="outline-container-org41d4771" class="outline-2">
<h2 id="org41d4771">L'ICMP utilizzato per il ping e per capire delle statistiche sulla rete, fa uso di uno Header IP ed utilizza un Checksum, oltre che il tipo di richiesta (ce ne sono varie).</h2>
</div>
<div id="outline-container-org41ad2dc" class="outline-2">
<h2 id="org41ad2dc">Un importante compito del livello 3 è quello di instradare i pacchetti verso la giusta destinazione. Il grafo della rete è parzialmente connesso e serve un livello superiore a quello del data link che abbia una visione più ampia e riesca a smistare i pacchetti in un modo intelligente ed efficiente</h2>
<div class="outline-text-2" id="text-org41ad2dc">
</div>
<div id="outline-container-org6c388ea" class="outline-3">
<h3 id="org6c388ea">Immaginiamo di avere due macchine con porte I/O e un forwarder in mezzo, che contiene una tabella e fa un lookup per capire su quale porta trasmettere il messaggio entrato.</h3>
<div class="outline-text-3" id="text-org6c388ea">
</div>
<div id="outline-container-orgdba9e4b" class="outline-4">
<h4 id="orgdba9e4b">A livello 2, questo è fatto dal bridge, che popola e spopola le tabelle periodicamente per lasciar spostare le macchine.</h4>
</div>
<div id="outline-container-org2226852" class="outline-4">
<h4 id="org2226852">Se saliamo di un piano, quello che cambia radicalmente è che non è più vero che la macchina destinazione sia attaccata al link. La validità di un forwarding livello 2, a livello 3 non è più sufficiente.</h4>
<div class="outline-text-4" id="text-org2226852">
</div>
<div id="outline-container-orge54832a" class="outline-5">
<h5 id="orge54832a">Il forwarding deve avere la capacità di scegliere la porta che conduce alla destinazione in futuro, e in un modo oscuro alla singola macchina.</h5>
</div>
</div>
</div>
<div id="outline-container-org76c6724" class="outline-3">
<h3 id="org76c6724">A livello 3, la tabella viene popolata da un secondo processo, che chiamiamo <b>router</b>, che lavora con i suoi pacchetti di controllo, utili soltanto a lui, tramite i quali impara la topologia della rete e popola la tabella in modo da permettere di raggiungere ogni host in un modo efficiente, possibilmente il cammino minimo.</h3>
<div class="outline-text-3" id="text-org76c6724">
</div>
<div id="outline-container-org77d9473" class="outline-4">
<h4 id="org77d9473">La cosa interessante è che abbiamo una separazione netta fra tutto ciò che è gestione dei dati utente e la gestione di controllo di tutto ciò che serve alla rete autonomamente perchè funzioni.</h4>
</div>
<div id="outline-container-org14241f8" class="outline-4">
<h4 id="org14241f8">Con il routing questa diventa chiara.</h4>
<div class="outline-text-4" id="text-org14241f8">
</div>
<div id="outline-container-org98ec5c0" class="outline-5">
<h5 id="org98ec5c0">Finora i messaggi di controllo e i dati erano mescolati, anche fisicamente.</h5>
</div>
<div id="outline-container-org029fe31" class="outline-5">
<h5 id="org029fe31">Adesso, il router lavora in modo assolutamente autonomo.</h5>
</div>
</div>
</div>
<div id="outline-container-orgdf25eca" class="outline-3">
<h3 id="orgdf25eca">Il router opera attraverso 3 tecniche:</h3>
<div class="outline-text-3" id="text-orgdf25eca">
<ul class="org-ul">
<li>Distance vector - RIP, vecchio e residuale</li>
<li>OSPF, link state, più diffuso</li>
<li>BGP, Border Gateway Protocol, evoluzione del distance vector, utilizzato per la comunicazione ad alto livello, intercontinentale</li>
</ul>
</div>
<div id="outline-container-org9be8703" class="outline-4">
<h4 id="org9be8703">Il protocollo con Distance vector opera assegnando due etichette con numero del link e corrispondente peso su ogni arco bidirezionale.</h4>
<div class="outline-text-4" id="text-org9be8703">
</div>
<div id="outline-container-orga501026" class="outline-5">
<h5 id="orga501026">Ogni nodo produce la tabella delle adiacenze. Questa contiene Router, Link e Cost.</h5>
<div class="outline-text-5" id="text-orga501026">
</div>
<div id="outline-container-orge4a040d" class="outline-6">
<h6 id="orge4a040d">Sè stesso è raggiungibile da sè stesso (no link) con costo 0.</h6>
</div>
<div id="outline-container-orgedd39bc" class="outline-6">
<h6 id="orgedd39bc">Ogni altro router, è raggiungibile attraverso un certo link, con un costo uguale alla somma delle etichette dei pesi di tutti gli archi che vengono attraversati.</h6>
</div>
</div>
<div id="outline-container-org94fb014" class="outline-5">
<h5 id="org94fb014">Con queste costruiamo la conoscenza locale, ovvero tutti i router appena adiacenti attraverso soltanto un filo, insieme al loro costo.</h5>
<div class="outline-text-5" id="text-org94fb014">
</div>
<div id="outline-container-org51a2717" class="outline-6">
<h6 id="org51a2717">Ancora non abbiamo una visione topologica della rete. Abbiamo solo una visione delle adiacenze.</h6>
<div class="outline-text-6" id="text-org51a2717">
</div>
<div id="outline-container-orgbb34896" class="outline-7">
<h7 id="orgbb34896">Un singolo nodo nono ha idea di quali nodi possa raggiungere oltre le adiacenze.</h7>
</div>
</div>
</div>
<div id="outline-container-org6f5e3c1" class="outline-5">
<h5 id="org6f5e3c1">Il modo per passare da una conoscenza locale a quella globale sfrutta la comunicazione fra nodi.</h5>
</div>
<div id="outline-container-orgb6fb637" class="outline-5">
<h5 id="orgb6fb637">Periodicamente viene trasferito agli altri il distance vector, ovvero l'associazione Router-Costo</h5>
<div class="outline-text-5" id="text-orgb6fb637">
</div>
<div id="outline-container-orgf3011f5" class="outline-6">
<h6 id="orgf3011f5">Ogni router ha un proprio timer, alla scadenza del quale trasferisce il vettore delle distanze ai suoi vicini.</h6>
</div>
</div>
<div id="outline-container-org2d49b91" class="outline-5">
<h5 id="org2d49b91">Quando un nodo riceve il vettore delle distanze del vicino, aggiorna il proprio vettore con i nuovi nodi raggiungibili attraverso il vicino, la cui distanza è la somma fra il primo nodo è quello appena collegato e quest'ultimo con il nuovo.</h5>
</div>
<div id="outline-container-org87e1988" class="outline-5">
<h5 id="org87e1988">Ogni vettore delle distanze nuovo che arriva, un router calcola anche tutte le nuove distanze per le destinazioni che già conosce, in modo da aggiornare nuove distanze minime.</h5>
</div>
<div id="outline-container-org0138d4a" class="outline-5">
<h5 id="org0138d4a">Il tempo necessario per conoscere tutta la rete è lineare con il suo diametro.</h5>
</div>
<div id="outline-container-org6ab158e" class="outline-5">
<h5 id="org6ab158e">Viene inoltre utilizzato il trigger update con cui i nodi vicini possono richiedere informazioni alla variazione dello stato. Ad esempio usano il trigger update i router appena accesi così chiamano velocemente informazioni nuove.</h5>
</div>
<div id="outline-container-orge0a1516" class="outline-5">
<h5 id="orge0a1516">Il problema di questo protocollo è che non c'è modo di aggiornare in caso di peggioramenti e questo causa un malfunzionamento abbastanza grave.</h5>
<div class="outline-text-5" id="text-orge0a1516">
</div>
<div id="outline-container-orgbbf8b67" class="outline-6">
<h6 id="orgbbf8b67">Immaginiamo che un link su un certo nodo si guasti.</h6>
<div class="outline-text-6" id="text-orgbbf8b67">
</div>
<div id="outline-container-orgaeed69f" class="outline-7">
<h7 id="orgaeed69f">Il nodo stesso lo riconosce subito e aggiorna la propria tabella con valore <b>infinito</b> per il nodo dietro quel link.</h7>
</div>
<div id="outline-container-orgd13099c" class="outline-7">
<h7 id="orgd13099c">Gli altri nodi però non lo sanno e continuano a mandare su quel link, se la loro tabella dice che è quella la strada minore.</h7>
</div>
<div id="outline-container-org09856fe" class="outline-7">
<h7 id="org09856fe">Questa situazione finisce soltanto nel momento in cui B propaga il suo distance vector con costo infinito.</h7>
</div>
<div id="outline-container-org93522eb" class="outline-7">
<h7 id="org93522eb">Cosa succede se però nel frattempo un altro nodo, non ancora informato del guasto, manda il proprio distance vector al nodo che ha appena notato il guasto?</h7>
<div class="outline-text-7" id="text-org93522eb">
</div>
<div id="outline-container-org7bb9dda" class="outline-8">
<h8 id="org7bb9dda">Siano A, B e C i nodi, con A che vuole raggiungere C attraverso B, e il collegamento fra B e C guasto.</h8>
<div class="outline-text-8" id="text-org7bb9dda">
</div>
<div id="outline-container-org69cd9e0" class="outline-9">
<h9 id="org69cd9e0">Allora la distanza fra A e C è uguale alla distanza fra A e B più quella fra B e C</h9>
</div>
<div id="outline-container-org5e444da" class="outline-9">
<h9 id="org5e444da">Il problema è che adesso la distanza fra B e C è infinita, ma quella fra A e C considera ancora il valore da B e C precedente.</h9>
</div>
<div id="outline-container-org9adc95e" class="outline-9">
<h9 id="org9adc95e">Allora B aggiorna la sua stessa distanza fra B e C come quella suggerita da A, che però già contiene la distanza B-C non aggiornata, più la distanza fra A e B.</h9>
<div class="outline-text-9" id="text-org9adc95e">
</div>
<div id="outline-container-org1f5e05a" class="outline-10">
<h10 id="org1f5e05a">In pratica, B rimpiazza l'infinito con la distanza B-A più A-B più B-C vecchia.</h10>
</div>
<div id="outline-container-orge110451" class="outline-10">
<h10 id="orge110451">Alla update successiva, A vede che B ha aumentato la propria distanza di un valore uguale alla distanza A-B e aggiorna il suo valore a quella distanza, più B-A</h10>
<div class="outline-text-10" id="text-orge110451">
</div>
<div id="outline-container-org32f2255" class="outline-11">
<h11 id="org32f2255">Quindi A rimpiazza A-B + old(B-C) con A</h11>
</div>
<div id="outline-container-org26ff110" class="outline-11">
<h11 id="org26ff110">Quello che succede è questo (indico la distanza fra i nodi A o B e C):</h11>
<div class="outline-text-11" id="text-org26ff110">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">stato</td>
</tr>

<tr>
<td class="org-left">[A-B]+[B-C]</td>
<td class="org-left">[B-C]</td>
<td class="org-left">Iniziale</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">Inf</td>
<td class="org-left">Collegamento rotto e DVB viene perso</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">[B-A]+[A-B]+[B-C]</td>
<td class="org-left">B acquisisce la distanza da A</td>
</tr>

<tr>
<td class="org-left">[A-B]+[B-A]+[A-B]+[B-C]</td>
<td class="org-left">//</td>
<td class="org-left">A acquisisce da B</td>
</tr>

<tr>
<td class="org-left">//</td>
<td class="org-left">[B-A]+"same as top left"</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org6bac152" class="outline-10">
<h10 id="org6bac152">Si inizierà un <b>count to infinity</b> in cui ad ogni step la distanza verso quel collegamento aumenta della distanza fra i due nodi in questione.</h10>
</div>
<div id="outline-container-org88bd480" class="outline-10">
<h10 id="org88bd480">Questo accade perchè le distanze di sia A che B verso quello guasto C contengono al loro interno la distanza A-B. Ovvero, B raggiunge C tramite A (o almeno crede di fare così) e A raggiunge C tramite B.Il sistema è innescato da B, che normalmente non dovrebbe aggiornare la propria distanza per includere quella di A, perchè il collegamento diretto con C è banalmente più breve di quello che compie un ciclo tramite A e poi ripercorre il collegamento diretto.</h10>
<div class="outline-text-10" id="text-org88bd480">
</div>
<div id="outline-container-org2ac3861" class="outline-11">
<h11 id="org2ac3861">Quando però il link con C è danneggiato, accade che il ciclo attraverso A più la vecchia distanza B-C è sicuramente più breve dell'infinito e B aggiorna, senza sapere che A fa affidamento su di lui.</h11>
</div>
<div id="outline-container-orga72f405" class="outline-11">
<h11 id="orga72f405">A aggiorna, senza sapere che B fa affidamento su di lui.</h11>
</div>
<div id="outline-container-org797a0a7" class="outline-11">
<h11 id="org797a0a7">MAIN</h11>
<div class="outline-text-11" id="text-org797a0a7">
<p>
Maybe the solution is that the distance vector also contains the link that leads to a node.
If a new value comes from a distance vector, and that value is HIGHER than the one a node already had, but it is on the same link, the node updates it.
</p>

<p>
Yes, exactly! That's the key insight that explains why count to infinity actually occurs. The distance vector protocol also keeps track of the next hop (the link or neighbor through which a destination is reached), not just the distances.
</p>

<p>
So in the A-B-C scenario:
</p>

<p>
Initially A reaches C through B (next hop = B)
When B-C link fails:
    B sets its distance to C as infinity
    When A receives B's update, even though it's a larger value, A MUST accept it because B is its next hop to C
    A can't keep its old shorter value because that path was dependent on going through B
</p>

<p>
This is why it's crucial that nodes update their routes when they receive updates from their next hop neighbor, even if the new distance is larger. The node must trust its next hop's information about destinations reached through that path.
</p>

<p>
This is also why solutions like split horizon work - they prevent nodes from advertising routes back through the path they learned them from, breaking this cycle of increasing distances.
</p>

<p>
Your observation about the importance of the link/next hop information is spot-on and explains the actual mechanism behind count to infinity much more accurately than the oversimplified "only accept shorter paths" explanation.
SPIEGAZIONE DEL PERCHÈ UN NODO ACCETTA UN VALORE PIÙ ALTO
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org5cd9988" class="outline-9">
<h9 id="org5cd9988">Le due cause del problema sono il fatto che l'informazione dello specifico nodo utilizzato per raggiungere una destinazione è persa, e che i disstance vector viaggiano in modo asincrono e possono anche essere smarriti.</h9>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdd44c54" class="outline-5">
<h5 id="orgdd44c54">Il count to infinity da luogo al bouncing effect, in cui i pacchetti fra i nodi A e B dell'esempio precedente rimangono bloccati rimbalzando fra gli stessi.</h5>
</div>
<div id="outline-container-org12e2a52" class="outline-5">
<h5 id="org12e2a52">Una soluzione al <b>count to infinity</b> è lo <b>split horizon</b></h5>
<div class="outline-text-5" id="text-org12e2a52">
</div>
<div id="outline-container-org063c2dd" class="outline-6">
<h6 id="org063c2dd">Il distance vector riporterà costo infinito per il link corrispondente a quello utilizzato per inviare lo stesso distance vector.</h6>
<div class="outline-text-6" id="text-org063c2dd">
</div>
<div id="outline-container-orgbf2794b" class="outline-7">
<h7 id="orgbf2794b">Di conseguenza, quando l'infinito inizia a propagarsi,</h7>
</div>
<div id="outline-container-org22952b4" class="outline-7">
<h7 id="org22952b4">Con questo trucco, il distance vector non potrà contenere loop perchè un nodo non sceglierà mai di utilizzare il link che conduce ad un loop.</h7>
</div>
<div id="outline-container-orgadfd157" class="outline-7">
<h7 id="orgadfd157">Esiste un caso in cui il problema del count to infinity avviene anche in questo caso.</h7>
<div class="outline-text-7" id="text-orgadfd157">
</div>
<div id="outline-container-org7924e7a" class="outline-8">
<h8 id="org7924e7a">In particolare, lo split horizon non aiuta nel caso in cui ci siano più di due router coinvolti. Infatti, in questo caso, il nodo appena adiacente a quello su cui è avvenuto il guasto non direbbe a questùltimo di conoscere la strada, ma la direbbe ad un nodo ancora successivo e collegato al primo, su cui è avvenuto il guasto. il terzo nodo della catena avviserebbe il primo di conoscere una strada, la quale sebbene non passi per il link diretto con il nodo che ha un link guasto, passa per un ciclo che eventualmente arriverà a quel nodo. La conseguenza è la stessa.</h8>
<div class="outline-text-8" id="text-org7924e7a">
<pre class="example" id="orgc731e4e">
Consider three routers A, B, and C in a loop
If the link between A and destination D fails
Router A marks D as unreachable (16)
However, B might still tell C it can reach D
C might then tell A it can reach D
A might then choose this alternative path, not knowing it's part of a loop
The metric will keep increasing until it reaches infinity
</pre>
</div>
</div>
<div id="outline-container-org14f5fe0" class="outline-8">
<h8 id="org14f5fe0">Si può dunque dire che lo split horizon abbia un orizzonte di risoluzione di massimo 2 nodi, oltre i quali il problema è irrisolvibile.</h8>
</div>
</div>
</div>
<div id="outline-container-orgb81ea63" class="outline-6">
<h6 id="orgb81ea63">I difetti sono che: 1 passo solo il peso ma non il percorso seguito ,2 non ho la topologia magliata, ma conosco solo i miei vicini,3 la propagazione è asincrona e potrei perdere qualche informazione, ovvero le tabele non sempre divergono.</h6>
</div>
<div id="outline-container-org0c4bd40" class="outline-6">
<h6 id="org0c4bd40">Quindi le tre tecniche usate per migliorare l'efficienza di questa tecnica sono le seguenti:</h6>
<div class="outline-text-6" id="text-org0c4bd40">
<ul class="org-ul">
<li>Triggered update</li>
<li>Split horizon</li>
<li>Ogni tempo T flusho le tabelle e risolvo tutte le situazioni difficili che si erano create.</li>
<li>L'infinito è appena maggiore di 16</li>
<li>Storm di update
<ul class="org-ul">
<li>Quando c'è un guasto, tutti i nodi coinvolti farebbero update, con seguente congestione. Viene quindi introdotto un random fra 1 e 5 secondi, così da ridurre la storm ma aumentando la probabilità di count to infinity</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org728728f" class="outline-2">
<h2 id="org728728f">Ci rifacciamo alla stessa struttura riguardante il routing, con un router che contiene un forwarder con porte IO di ingresso ed uscita e che opera su una tabella di routing, facendo un lookup e stabilendo la corretta porta di output. Chi scrive sulla tabella è il router, che ha i propri pacchetti di controllo e opera come un processo totalmente asincrono ed indipendente.</h2>
<div class="outline-text-2" id="text-org728728f">
</div>
<div id="outline-container-org5f94d60" class="outline-3">
<h3 id="org5f94d60">Il router è attivato periodicamente, mentre il forwarder è attivato alla presenza di un pacchetto in coda di input.</h3>
</div>
<div id="outline-container-orga0d2832" class="outline-3">
<h3 id="orga0d2832">Vogliamo sviluppare una soluzione alternativa in cui oltre al peso e alla destinazione del cammino, si dice anche il link che si vuole utilizzare</h3>
</div>
<div id="outline-container-orgf6c5c16" class="outline-3">
<h3 id="orgf6c5c16">La gran parte delle reti fondamentali di internet, ovvero quelle intermedie fra LAN, utilizza un protocollo chiamato OSPF Link State</h3>
<div class="outline-text-3" id="text-orgf6c5c16">
</div>
<div id="outline-container-org95f1f2d" class="outline-4">
<h4 id="org95f1f2d">Voglio costruirmi il grafo della connettività, con i costi di ogni arco, dopo aver scambiato abbastanza informazioni fra nodi.</h4>
</div>
<div id="outline-container-org39dd88a" class="outline-4">
<h4 id="org39dd88a">Ogni nodo manda la distanza sui suoi link a TUTTI gli altri nodi, quindi esistono N(N-1) messaggi di controllo</h4>
<div class="outline-text-4" id="text-org39dd88a">
</div>
<div id="outline-container-org3cc760b" class="outline-5">
<h5 id="org3cc760b">Questa strategia si chiama FLOODING.</h5>
<div class="outline-text-5" id="text-org3cc760b">
</div>
<div id="outline-container-org00b07e7" class="outline-6">
<h6 id="org00b07e7">Ogni link state viene mandato su tutte le porte IO diverse da quella di arrivo.</h6>
</div>
</div>
<div id="outline-container-org43ecd68" class="outline-5">
<h5 id="org43ecd68">Il link state di uno specifico nodo continuerebbe a girare all'infinito. Allora viene introdotto un buffer che tiene l'ultimo state link e informazioni aggiuntive tipo header, contenenti l'indirizzo del mittente, un numero di sequenza associato allo specifico mittente, un TTL, ovvero un numero massimo di hops che possono essere effettuati e alla fine l'informazione vera e propria</h5>
<div class="outline-text-5" id="text-org43ecd68">
</div>
<div id="outline-container-orga6aa62f" class="outline-6">
<h6 id="orga6aa62f">Ogni LS inviato nel flooding prevede anche un ACK</h6>
<div class="outline-text-6" id="text-orga6aa62f">
</div>
<div id="outline-container-orgb953ae4" class="outline-7">
<h7 id="orgb953ae4">Questo comporta che nella rete sia occupata da tanto traffico di controllo di livello 2</h7>
</div>
</div>
<div id="outline-container-org7728e6c" class="outline-6">
<h6 id="org7728e6c">Per calcolare le distanze, si usa ICMP con il ping, calcolando la distanza con un cronometro fra l'invio ed il ritorno di un pacchetto.</h6>
</div>
</div>
<div id="outline-container-org608fde6" class="outline-5">
<h5 id="org608fde6">Le cose positive del link state sono che si conosce la topologia della rete nella sua interezza, così che attraverso Dijkstra si stabiliscano tutti i cammini minimi.</h5>
</div>
<div id="outline-container-orgfe0ed83" class="outline-5">
<h5 id="orgfe0ed83">L'implementazione dei LinkState viene effettuata da OSPF, ovvero open shortest path first.</h5>
<div class="outline-text-5" id="text-orgfe0ed83">
</div>
<div id="outline-container-org55a837c" class="outline-6">
<h6 id="org55a837c">Il problema è che questo calcolo andrebbe fatto da ogni nodo nella rete, con un certo carico computazionale.</h6>
</div>
<div id="outline-container-org3428451" class="outline-6">
<h6 id="org3428451">La routing table conterrà la destinazione da raggiungere, il link attraverso cui si raggiunge e il costo, costruito tramite Dijkstra.</h6>
</div>
<div id="outline-container-org5ecf160" class="outline-6">
<h6 id="org5ecf160">Questo protocollo è MULTIPATH, ovvero salva i casi in cui due path diverse abbiano lo stesso peso, in modo da fare load balancing.</h6>
</div>
<div id="outline-container-orgaad32e4" class="outline-6">
<h6 id="orgaad32e4">Addirittura posso obbligare un pacchetto a passare attraverso uno specifico nodo, imbullonandolo nello header.</h6>
</div>
</div>
</div>
<div id="outline-container-orgab6e824" class="outline-4">
<h4 id="orgab6e824">Adesso immaginiamo di avere una topologia di nodi con due nodi, R1 ed R3, connessi ad una rete (ad esempio lan, ma qualunque) con netID rispettivamente 1 e 3, che contengono al loro interno uno degli host H1 e H3.</h4>
<div class="outline-text-4" id="text-orgab6e824">
</div>
<div id="outline-container-org61b193a" class="outline-5">
<h5 id="org61b193a">Ogni nodo contiene anche una tabella di adiacenze, in cui ad ogni nodo è associato il link che serve per raggiungerlo</h5>
</div>
<div id="outline-container-orgefe7168" class="outline-5">
<h5 id="orgefe7168">Queste reti si chiamano stub, ovvero reti foglia, e contengono una tabella a loro volta, in cui è salvata la coppia netID-nodo a cui è collegata.</h5>
<div class="outline-text-5" id="text-orgefe7168">
</div>
<div id="outline-container-orgd97c3df" class="outline-6">
<h6 id="orgd97c3df"><span class="todo TODO">TODO</span> Capire chi salva quali tabelle e in particolare chi tiene la netId table</h6>
</div>
<div id="outline-container-org047c5d3" class="outline-6">
<h6 id="org047c5d3">Ad esempio, nella rete con netId 1 c'è scritto che la 1 è raggiungibile direttamente e la 3 attraverso il nodo R3.</h6>
</div>
<div id="outline-container-org31fc0ad" class="outline-6">
<h6 id="org31fc0ad">Quando H1 manda un pacchetto a H3, traduce H3 in R3. Il router R1 manda verso R1 mandando sul router successivo secondo la sua routing table, in particolare sul link associato a quel router.</h6>
</div>
</div>
</div>
<div id="outline-container-org488ecd5" class="outline-4">
<h4 id="org488ecd5">OSPF ruota sicuramente sulla area 0, ovvero il backbone dello Autonomous System. All'area 0 sono collegate sotto-aree che per comunicare da loro devono necessariamente passare attraverso l'area 0. L'area 0 contiene dei border-router attraverso cui passa TUTTO il traffico, intra area ed extra area.</h4>
</div>
<div id="outline-container-org8707cfe" class="outline-4">
<h4 id="org8707cfe">Per mettere in comunicazione AS diversi, serve avere dei link che li collegano e i router fra essi utilizzano un altro protocollo, BGP.</h4>
</div>
</div>
<div id="outline-container-orgf4ee215" class="outline-3">
<h3 id="orgf4ee215">Per migliorare la efficienza e generare le tabelle di routing vengono messe in atto delle tecniche avanzate, fra cui centralizzare il calcolo dei cammini minimi. Un router specifico, chiamato Designated Router, che calcola i cammini minimi per tutte i nodi e gli rimanda le tabelle già calcolate.</h3>
<div class="outline-text-3" id="text-orgf4ee215">
</div>
<div id="outline-container-orgd1108d9" class="outline-4">
<h4 id="orgd1108d9">Si riduce un po' il traffico, ma si ha lo svantaggio di congestionare i link verso lo stesso, su cui convergono le comunicazioni.</h4>
</div>
<div id="outline-container-org3411b1e" class="outline-4">
<h4 id="org3411b1e">Ormai tutte le reti lo usano.</h4>
</div>
<div id="outline-container-org2066424" class="outline-4">
<h4 id="org2066424">Lo spunto di eleggere un designated router è stato preso tanto bene che invece di eleggere uno dei router, si è deciso di portarlo in cloud, inventando il Software Designed Network SDN.</h4>
<div class="outline-text-4" id="text-org2066424">
</div>
<div id="outline-container-orgf06caf3" class="outline-5">
<h5 id="orgf06caf3">Nella gran parte dei casi quel router si trova su cloud.</h5>
</div>
<div id="outline-container-org7e20e8f" class="outline-5">
<h5 id="org7e20e8f">Tutto ciò è possibile perchè noi fin dall'inizio abbiamo stabilito che il piano di controllo, routing, è separato dal piano di dati, forwarding.</h5>
</div>
<div id="outline-container-org221e6cb" class="outline-5">
<h5 id="org221e6cb">Esiste un protocollo, Open Flow, che regola le comunicazioni con il Designated Router, anche cercando di risolvere problemi di sicurezza.</h5>
</div>
<div id="outline-container-org22b59b0" class="outline-5">
<h5 id="org22b59b0">A questo punto il flooding non esiste più, ma avviene una comunicazione punto punto con l'SDN o Designated Router.</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org186bd41" class="outline-2">
<h2 id="org186bd41">Supponiamo di avere due macchina che ha uno strato applicativo, seguito da TCP, IP ecc&#x2026;, attaccata ad una rete IP.</h2>
<div class="outline-text-2" id="text-org186bd41">
</div>
<div id="outline-container-org93ae470" class="outline-3">
<h3 id="org93ae470">Ora immaginiamo che una macchina in mezzo a queste macchine ci sia una rete non IP.</h3>
</div>
<div id="outline-container-org40de97c" class="outline-3">
<h3 id="org40de97c">La macchina centrale deve avere IP per riuscire a prendere i pacchetti e poi l'altro network per processarli correttamente. Poi andranno reinviati in IP</h3>
</div>
<div id="outline-container-orga82dee4" class="outline-3">
<h3 id="orga82dee4">Il TUNNELLING è il modo di gestire lo header durante il passaggio in quella macchina</h3>
</div>
<div id="outline-container-orgfd0a0e8" class="outline-3">
<h3 id="orgfd0a0e8">La soluzione banale è che l'intero pacchetto, compreso header, viene incapsulato e lo header dell'altro protocollo viene semplicemente aggiunto, per poi essere rimosso dopo</h3>
</div>
</div>
<div id="outline-container-org58fe89a" class="outline-2">
<h2 id="org58fe89a">TRANSPORT LAYER NUOVE LEZIONI</h2>
</div>
<div id="outline-container-orgcee69f3" class="outline-2">
<h2 id="orgcee69f3">Transport layer è il primo livello ad essere end-to-end, ovvero che comunica fra due macchine ed astrae ai livelli superiori la rete sottostante (la nasconde).</h2>
<div class="outline-text-2" id="text-orgcee69f3">
</div>
<div id="outline-container-org878b286" class="outline-3">
<h3 id="org878b286">Offre dei servizi che abbiamo già visto nel data-link.</h3>
</div>
<div id="outline-container-org99c4c4a" class="outline-3">
<h3 id="org99c4c4a">Varie funzionalità possono essere attivate o disattivate.</h3>
</div>
<div id="outline-container-org6e0dde9" class="outline-3">
<h3 id="org6e0dde9">TCP e UDP sono ortogonali fra loro. La prima offre disponibilità, mentre la seconda è best-effort e non aggiunge nulla ai livelli superiori.</h3>
</div>
<div id="outline-container-org24ce560" class="outline-3">
<h3 id="org24ce560">A livello data-link, tra due porte di rete abbiamo una trasmissione può essere affidabile, avere controllo degli errori ecc.</h3>
<div class="outline-text-3" id="text-org24ce560">
</div>
<div id="outline-container-org2849398" class="outline-4">
<h4 id="org2849398">Quello che non è considerato a livello data-link è se qualcosa va perso a livello network.</h4>
<div class="outline-text-4" id="text-org2849398">
</div>
<div id="outline-container-orgcb18d2a" class="outline-5">
<h5 id="orgcb18d2a">Un esempio è che abbiamo il nostro host con il suo livello IP.</h5>
<div class="outline-text-5" id="text-orgcb18d2a">
</div>
<div id="outline-container-org6ea91f6" class="outline-6">
<h6 id="org6ea91f6">Poi abbiamo tutti questi router intermedi con i loro livelli IP e un protocollo che li leghi (non ci interessa quale).</h6>
</div>
<div id="outline-container-org23d5b4c" class="outline-6">
<h6 id="org23d5b4c">In ogni nodo ci sono delle code di ricezione \(RX\) e di trasmissione \(RT\) che hanno una capacità limitata.</h6>
</div>
<div id="outline-container-org108fc5a" class="outline-6">
<h6 id="org108fc5a">Nonostante possiamo dare affidabilità al data-link, a questo livello IP, se il RT è in overflow, scarta un pacchetto e questo viene perso del tutto.</h6>
<div class="outline-text-6" id="text-org108fc5a">
</div>
<div id="outline-container-org1058da9" class="outline-7">
<h7 id="org1058da9">Nonostante ci sia una somma di link affidabili, questa non garantisca che tutta la comunicazione end-to-end sia affidabile.</h7>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org60f4797" class="outline-3">
<h3 id="org60f4797">In Transport viene riimplementata l'affidabilità in modo che quando un segmento venga perso, venga gestita la ritrasmissione.</h3>
<div class="outline-text-3" id="text-org60f4797">
</div>
<div id="outline-container-orgebc289d" class="outline-4">
<h4 id="orgebc289d">La trasmissione su cavo è molto affidabile e quindi l'affidabilità a livello data link è passata in secondo piano e diventa più importante quella su tratte più lunghe, con tutta la rete in mezzo, che coinvolgono i router di livello 3.</h4>
</div>
</div>
<div id="outline-container-org4e40a25" class="outline-3">
<h3 id="org4e40a25">Le unità base di comunicazione a livello 4 sono chiamate <b>messaggi</b> o <b>segmenti</b>.</h3>
</div>
<div id="outline-container-org1699a12" class="outline-3">
<h3 id="org1699a12">Il livello di trasporto ha anche un suo indirizzamento (naming) utilizzando le porte, che servono per identificare l'applicazione che sta utilizzando il collegamento di livello 4.</h3>
<div class="outline-text-3" id="text-org1699a12">
</div>
<div id="outline-container-org901d85a" class="outline-4">
<h4 id="org901d85a">Mentre l'indirizzo IP serve per identificare l'host di rete</h4>
</div>
<div id="outline-container-orgee7c3e5" class="outline-4">
<h4 id="orgee7c3e5">Immaginiamo di avere un client ed un server con TCP o UDP a livello 4, IP sotto e poi una rete completamente trasparente.</h4>
<div class="outline-text-4" id="text-orgee7c3e5">
</div>
<div id="outline-container-orgfdf9988" class="outline-5">
<h5 id="orgfdf9988">Abbiamo poi delle applicazioni che comunicano, ad esempio app client e web server con db.</h5>
</div>
<div id="outline-container-orgcf6a93c" class="outline-5">
<h5 id="orgcf6a93c">Immaginiamo arrivi un pacchetto IP a livello server.</h5>
<div class="outline-text-5" id="text-orgcf6a93c">
</div>
<div id="outline-container-org94729af" class="outline-6">
<h6 id="org94729af">Il server legge il suo header e con il suo destination address sa che è destinato a lui.</h6>
</div>
<div id="outline-container-orgf743330" class="outline-6">
<h6 id="orgf743330">Nello campo "protocol" ci sarà scritto se il pacchetto è da mandare ad IP o UDP.</h6>
</div>
<div id="outline-container-orgb02b082" class="outline-6">
<h6 id="orgb02b082">Le applicazioni ascoltano su una specifica porta (80 per http ecc.)</h6>
</div>
<div id="outline-container-org98d8679" class="outline-6">
<h6 id="org98d8679">TCP si chiede: a quale di queste operazioni appartiene questo segmento? in modo da smistarlo correttamente.</h6>
<div class="outline-text-6" id="text-org98d8679">
</div>
<div id="outline-container-org5783bb3" class="outline-7">
<h7 id="org5783bb3">Quindi l'IP address identifica tutto l'host, il PROTOCOL indica il protocollo di transport e la porta(?) indica l'applicazione specifica che usa i dati.</h7>
</div>
</div>
</div>
<div id="outline-container-org98f5502" class="outline-5">
<h5 id="org98f5502">Anche dal lato client, si parte dall'Application layer e si sceglie il corretto protocollo (TCP/UDP) da utilizzare.</h5>
<div class="outline-text-5" id="text-org98f5502">
</div>
<div id="outline-container-orgbd5849e" class="outline-6">
<h6 id="orgbd5849e">Quindi l'IP e il protocollo da utilizzare sono informazioni necessarie per aprire la comunicazione.</h6>
</div>
</div>
</div>
<div id="outline-container-orge921a42" class="outline-4">
<h4 id="orge921a42">A livello di Trasporto si usano le socket.</h4>
<div class="outline-text-4" id="text-orge921a42">
</div>
<div id="outline-container-org2c54942" class="outline-5">
<h5 id="org2c54942">Una socket è fatta così (stessa dell'immagine sul libro):</h5>
<div class="outline-text-5" id="text-org2c54942">
</div>
<div id="outline-container-orgd4fa350" class="outline-6">
<h6 id="orgd4fa350">Abbiamo un ClientAP e un ServerAP (access point), che noi richiediamo semplicemente e sono offerte dal sistema operativo.</h6>
</div>
<div id="outline-container-org1999207" class="outline-6">
<h6 id="org1999207">Fra i due AP abbiamo una transport entity</h6>
</div>
<div id="outline-container-orge27a0b7" class="outline-6">
<h6 id="orge27a0b7">Ogni applicazione contiene due buffer che sono RecevingBuffer e SendingBuffer.</h6>
</div>
<div id="outline-container-org757ed4b" class="outline-6">
<h6 id="org757ed4b">Le socket berkeley sono lo standard de facto, di Unix, che non è altro che un descrittore di file su cui si può effettuare scrittura e lettura.</h6>
<div class="outline-text-6" id="text-org757ed4b">
</div>
<div id="outline-container-org56ae866" class="outline-7">
<h7 id="org56ae866">Una write scrive sull'SB e la read sull'RB</h7>
</div>
</div>
<div id="outline-container-org9a9097a" class="outline-6">
<h6 id="org9a9097a">Poi abbiamo un istanza del protocollo TCP che se vede che va tutto bene (poi vedremo cosa vuol dire), prende carico dei dati e li trasmette in rete.</h6>
</div>
<div id="outline-container-orgadc1b7a" class="outline-6">
<h6 id="orgadc1b7a">C'è poi un altro livello di buffer, uno per ingresso e uno per uscita, aree di memoria temporanee che TCP riserva per tenere temporaneamente i pezzi di unità di informazione che devono essere ancora trasmessi.</h6>
<div class="outline-text-6" id="text-orgadc1b7a">
</div>
<div id="outline-container-org2bf4018" class="outline-7">
<h7 id="org2bf4018">TCP lavora a stream di byte e c'è un ordinamento assoluto di essi e va garantito che il ricevitore le riceva nello stesso ordine.</h7>
</div>
<div id="outline-container-org15fc4c9" class="outline-7">
<h7 id="org15fc4c9">Immaginiamo ad esempio di inviare 1, 2 e 3 e che 2 venga perso.</h7>
</div>
<div id="outline-container-org1db3f89" class="outline-7">
<h7 id="org1db3f89">Dopo aver ricevuto il 3, il TCP lato client si rende conto che manca qualcosa.</h7>
</div>
<div id="outline-container-org352f900" class="outline-7">
<h7 id="org352f900">Il blocchetto 3 rimane temporaneamente in buffer e quando il blocchetto 2 arriva a destinazione, verrà sbloccato anche il successivo.</h7>
</div>
<div id="outline-container-orgd0f7f29" class="outline-7">
<h7 id="orgd0f7f29">Il buffer tcp d'uscita serve invece per tenere gli stream da mandare fino alla ricezione di un ACK.</h7>
</div>
</div>
<div id="outline-container-orgdb21bb1" class="outline-6">
<h6 id="orgdb21bb1">Adesso, la velocità di lettura e scrittura sono diverse fra loro, diventa necessario mettere un buffer al centro.</h6>
<div class="outline-text-6" id="text-orgdb21bb1">
</div>
<div id="outline-container-org565391e" class="outline-7">
<h7 id="org565391e">Se una macchina genera in modo troppo veloce e l'altra troppo lenta, chiederà di rallentare la trasmissione.</h7>
</div>
<div id="outline-container-orgfccad11" class="outline-7">
<h7 id="orgfccad11">Siamo a livello kernel e non abbiamo tanta memoria.</h7>
<div class="outline-text-7" id="text-orgfccad11">
</div>
<div id="outline-container-org744e0f9" class="outline-8">
<h8 id="org744e0f9">Se non mettessimo un limite alla memoria, i buffer si saturerebbero e non rispetteremmo le specifiche di TCP che ci offre la totale affidabilità nella trasmissione.</h8>
</div>
</div>
</div>
</div>
<div id="outline-container-org54a908f" class="outline-5">
<h5 id="org54a908f">Con le socket si interagisce in questo modo, ovvero le API da utilizzare sono:</h5>
<div class="outline-text-5" id="text-org54a908f">
</div>
<div id="outline-container-org5b4957a" class="outline-6">
<h6 id="org5b4957a">Abbiamo ancora i due access point client e server che si interfacciano con il TCP/UDP.</h6>
<div class="outline-text-6" id="text-org5b4957a">
</div>
<div id="outline-container-org24bdeeb" class="outline-7">
<h7 id="org24bdeeb">Il livello 7 (application) è implementato nello user space.</h7>
</div>
<div id="outline-container-org2a6b563" class="outline-7">
<h7 id="org2a6b563">Il livello 4 è implementato nel kernel, quindi nel sistema operativo.</h7>
</div>
<div id="outline-container-org9ac8588" class="outline-7">
<h7 id="org9ac8588">Il livello 3 anche</h7>
</div>
<div id="outline-container-org7844594" class="outline-7">
<h7 id="org7844594">Il livello 2 sulla scheda di rete, quindi a livello firmware</h7>
</div>
<div id="outline-container-orgeb67fe4" class="outline-7">
<h7 id="orgeb67fe4">Il livello 1 è il cavo.</h7>
</div>
</div>
<div id="outline-container-orgefbe518" class="outline-6">
<h6 id="orgefbe518">Nel server, ci sono:</h6>
<div class="outline-text-6" id="text-orgefbe518">
</div>
<div id="outline-container-org22b77df" class="outline-7">
<h7 id="org22b77df">Una prima chiamata, bidirezionale, è <code>socket()</code>. Questa restituisce un descrittore di file aperto e bidirezionale, ovvero su cui si può leggere e scrivere.</h7>
</div>
<div id="outline-container-org1d14c2c" class="outline-7">
<h7 id="org1d14c2c">Poi c'è l'operazione di <code>bind()</code> a cui passiamo un indirizzo IP e una porta, che lega la socket a un indirizzo IP (0.0.0.0 se ascolti su tutti gli IP della macchina). O conosciamo l'IP o utilizziamo un indirizzo DNS e la porta o la sappiamo già o è una porta well-known, come 80 o 8080 per HTTP, 443 e 8443 per HTTPS, ssh sulla 22, DNS sulla 53UDP.</h7>
</div>
<div id="outline-container-orge780217" class="outline-7">
<h7 id="orge780217">Poi abbiamo <code>listen()</code> che dice alla socket di mettersi in ascolto sull'indirizzo indicato al <code>bind()</code>. Crea inoltre una coda di richieste.</h7>
<div class="outline-text-7" id="text-orge780217">
</div>
<div id="outline-container-orgb7aaf19" class="outline-8">
<h8 id="orgb7aaf19">Anche qua, questa coda è finita e se arriva un bombardamento di richieste ovviamente il buffer si riempie e le successive richieste non saranno più gestite.</h8>
</div>
</div>
<div id="outline-container-orgeb91f1b" class="outline-7">
<h7 id="orgeb91f1b">L'ultima chiamata è la <code>accept()</code>. Questa si blocca in attesa di una richiesta. Quindi è una richiesta bloccante. Aspetta che qualcuno arrivi per aprire una connessione.</h7>
</div>
<div id="outline-container-orgd9202c1" class="outline-7">
<h7 id="orgd9202c1">A questo punto, TCP non è ancora intervenuto ma ha stabilito tutte le parti necessarie per ottenere una comunicazione</h7>
</div>
</div>
<div id="outline-container-orgdab1740" class="outline-6">
<h6 id="orgdab1740">Nel client ci sono:</h6>
<div class="outline-text-6" id="text-orgdab1740">
</div>
<div id="outline-container-org256998c" class="outline-7">
<h7 id="org256998c"><code>socket</code> come prima</h7>
</div>
<div id="outline-container-org0afb875" class="outline-7">
<h7 id="org0afb875"><code>connect()</code>, bloccante, in cui, come nella <code>bind()</code> specifichiamo un IP e una porta per recapitare correttamente un messaggio.</h7>
<div class="outline-text-7" id="text-org0afb875">
</div>
<div id="outline-container-orga4659be" class="outline-8">
<h8 id="orga4659be">Questa connect scatena un'apertura di connessione, (o il recapito di un messaggio in UDP), che sblocca il server attraverso la unlock, fa una <code>fork</code> che da luogo ad una nuova <code>socket()</code>, che effettuerà una nuova <code>bind()</code>.</h8>
</div>
<div id="outline-container-orge15aeca" class="outline-8">
<h8 id="orge15aeca">Solo a questo punto viene tirata su la struttura del TCP con i 4 buffer.</h8>
</div>
<div id="outline-container-orgf989889" class="outline-8">
<h8 id="orgf989889">Quando viene effettuata la prima chiamata <code>socket</code> nel server, viene creata solo la coda di richieste.</h8>
</div>
<div id="outline-container-org5a5ace2" class="outline-8">
<h8 id="org5a5ace2">Solo la seconda chiamata tira su tutto il sistema TCP indicato prima</h8>
</div>
<div id="outline-container-org2bf2c41" class="outline-8">
<h8 id="org2bf2c41">La porta della sorgente è scelta randomicamente.</h8>
</div>
</div>
<div id="outline-container-org63dd900" class="outline-7">
<h7 id="org63dd900">Alla ricezione dell'ok della socket pronta dall'altra parte, si sblocca anche il client e da lì in poi la comunicazione è aperta e si possono utilizzare le system call tipiche dei file, ovvero <code>send()</code> e <code>receive()</code></h7>
</div>
</div>
<div id="outline-container-org90726e9" class="outline-6">
<h6 id="org90726e9">Quando voglio chiudere, una delle due chiama una <code>close()</code></h6>
<div class="outline-text-6" id="text-org90726e9">
</div>
<div id="outline-container-org8d9adf8" class="outline-7">
<h7 id="org8d9adf8">Questa chiusura coinvolge anche l'entità TCP, ma finora abbiamo soltanto osservato TCP dall'esterno.</h7>
</div>
</div>
<div id="outline-container-org0503450" class="outline-6">
<h6 id="org0503450">Con la quintupla [protocol, ipsrc, ipdst, portsrc, portdst] posso identificare la singola comunicazione che è stata tirata su dopo la serie di procedure appena indicata.</h6>
</div>
</div>
</div>
<div id="outline-container-org2364efb" class="outline-4">
<h4 id="org2364efb">Il TCP garantisce che la comunicazione sia <b>affidabile</b> e <b>ordinata</b>.</h4>
<div class="outline-text-4" id="text-org2364efb">
</div>
<div id="outline-container-orgeaf031c" class="outline-5">
<h5 id="orgeaf031c">Opera inoltre un controllo di flusso, ovvero un controllo orizzontale, con un app sorgente che scrive e una dest che legge, entrambe ad un certo rate, in modo che non ci sia overflow.</h5>
<div class="outline-text-5" id="text-orgeaf031c">
</div>
<div id="outline-container-orgac695db" class="outline-6">
<h6 id="orgac695db">Questo avviene basandosi sul rate minore.</h6>
</div>
</div>
<div id="outline-container-orgcabfb96" class="outline-5">
<h5 id="orgcabfb96">Opera poi un controllo errori.</h5>
<div class="outline-text-5" id="text-orgcabfb96">
</div>
<div id="outline-container-orgd17ca81" class="outline-6">
<h6 id="orgd17ca81">Mentre UDP avverte in caso di errori, TCP si occupa anche di risolverli, gestendo la ritrasmissione.</h6>
</div>
</div>
<div id="outline-container-orgc9c5ac7" class="outline-5">
<h5 id="orgc9c5ac7">Opera poi un controllo di congestione, questa volta verticale.</h5>
<div class="outline-text-5" id="text-orgc9c5ac7">
</div>
<div id="outline-container-org0f5d438" class="outline-6">
<h6 id="org0f5d438">E' vero che TCP nasconde la rete sottostante, ma sa che c'è una rete e sa che questa è potenzialmente inaffidabile.</h6>
</div>
<div id="outline-container-orgeeb7677" class="outline-6">
<h6 id="orgeeb7677">Sa che se vengono immessi troppi pacchetti su una rete, questa possa essere congestionata.</h6>
</div>
<div id="outline-container-org4510f3b" class="outline-6">
<h6 id="org4510f3b">TCP prova ad intuire la congestione della rete e prevenire la perdita di pacchetti della rete, diminuendo il rate di trasmissione di questi ultimi.</h6>
</div>
</div>
<div id="outline-container-orgffbabd2" class="outline-5">
<h5 id="orgffbabd2">Inoltre, è orientata allo stream.</h5>
<div class="outline-text-5" id="text-orgffbabd2">
</div>
<div id="outline-container-orgb56594a" class="outline-6">
<h6 id="orgb56594a">Il concetto su cui lavora è dello stream di byte, che devono arrivare tutti.</h6>
</div>
</div>
<div id="outline-container-org130f6e8" class="outline-5">
<h5 id="org130f6e8">Poi, è orientato alla connessione.</h5>
<div class="outline-text-5" id="text-org130f6e8">
</div>
<div id="outline-container-orgb4b1e7f" class="outline-6">
<h6 id="orgb4b1e7f">Prima di utilizzare le socket, leggervi e scrivervi, dobbiamo instaurare una connessione, aprendola, che mantiene un certo stato.</h6>
<div class="outline-text-6" id="text-orgb4b1e7f">
</div>
<div id="outline-container-orgea99e71" class="outline-7">
<h7 id="orgea99e71">Il drawback è che è necessario tenere lo stato e tutte le info per la connessione in memoria nel kernel, e dev'essere occupato durante tutta la comunicazione.</h7>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb0b2b87" class="outline-4">
<h4 id="orgb0b2b87">Lo header TCP è rappresentato in pagine larghe 32 bit.</h4>
<div class="outline-text-4" id="text-orgb0b2b87">
</div>
<div id="outline-container-org3ce6b17" class="outline-5">
<h5 id="org3ce6b17">Alla prima riga abbiamo 16 bit per porta sorgente e 16 per la destinazione</h5>
</div>
<div id="outline-container-orgd77ed0a" class="outline-5">
<h5 id="orgd77ed0a">Alla seconda riga abbiamo i 32 bit per il numero di sequenza</h5>
<div class="outline-text-5" id="text-orgd77ed0a">
</div>
<div id="outline-container-orga3713f0" class="outline-6">
<h6 id="orga3713f0">Il numero di sequenza indica il primo byte della lunghezza variabile di byte che compone il segmento.</h6>
</div>
<div id="outline-container-orgf793c0f" class="outline-6">
<h6 id="orgf793c0f">Viene inizializzato al momento dell'istanziamento della connessione.</h6>
</div>
</div>
<div id="outline-container-orgbd6f7ab" class="outline-5">
<h5 id="orgbd6f7ab">Poi abbiamo il campo ACK number, strettamente legato al precedente.</h5>
<div class="outline-text-5" id="text-orgbd6f7ab">
</div>
<div id="outline-container-org49fe76d" class="outline-6">
<h6 id="org49fe76d">Identifica il numero di byte che la destinazione di questa connessione ha correttamente ricevuto e qual è l'indice del prossimo byte che mi aspetto.</h6>
</div>
<div id="outline-container-org9bf0546" class="outline-6">
<h6 id="org9bf0546">I due campi superiori vengono utilizzati per gestire i casi in cui ci sia una perdita di segmenti e gestire correttamente la trasmissione.</h6>
</div>
</div>
<div id="outline-container-org6be7650" class="outline-5">
<h5 id="org6be7650">Nella terza pagina abbiamo:</h5>
<div class="outline-text-5" id="text-org6be7650">
</div>
<div id="outline-container-org6a7d7e8" class="outline-6">
<h6 id="org6a7d7e8">Poi c'è il campo TCP Header Length da 4 bit</h6>
<div class="outline-text-6" id="text-org6a7d7e8">
</div>
<div id="outline-container-org26d3ada" class="outline-7">
<h7 id="org26d3ada">La dimensione dell'header è variabile, sebbene esista una lunghezza solitamente usata.</h7>
</div>
</div>
<div id="outline-container-org529d159" class="outline-6">
<h6 id="org529d159">Poi 4 bit non utilizzati</h6>
</div>
<div id="outline-container-org2bcaafd" class="outline-6">
<h6 id="org2bcaafd">Poi c'è una serie di 8 bit di controllo</h6>
<div class="outline-text-6" id="text-org2bcaafd">
</div>
<div id="outline-container-org3085cf5" class="outline-7">
<h7 id="org3085cf5">Prima il CWR, Congestion Window Reduced, che serve alla rete congestionata per notificare la situazione</h7>
</div>
<div id="outline-container-org7b086d7" class="outline-7">
<h7 id="org7b086d7">Poi lo ECE, &#x2026;. echo.</h7>
<div class="outline-text-7" id="text-org7b086d7">
</div>
<div id="outline-container-org0f7fd66" class="outline-8">
<h8 id="org0f7fd66">Solo i due superiori sono presenti sul Tanenbaum ma non sull'Halsall</h8>
</div>
</div>
<div id="outline-container-org96206fc" class="outline-7">
<h7 id="org96206fc">Poi c'è un bit URGent, per indicare che certi dati sono urgenti e devono essere processati ASAP, superando l'ordinamento solito.</h7>
</div>
<div id="outline-container-org771cccf" class="outline-7">
<h7 id="org771cccf">Poi c'è il campo ACK</h7>
</div>
<div id="outline-container-orgf6c7a7b" class="outline-7">
<h7 id="orgf6c7a7b">Poi PUSH, che serve per mandaare via i dati contenuti nel buffer della socket.</h7>
<div class="outline-text-7" id="text-orgf6c7a7b">
</div>
<div id="outline-container-orge9649e1" class="outline-8">
<h8 id="orge9649e1">Ad esempio, immaginiamo che stiamo mandando dei dati e scrivendo nel SendingBuffer.</h8>
</div>
<div id="outline-container-orgb5cbd31" class="outline-8">
<h8 id="orgb5cbd31">Il TCP riempie un segmento di una certa dimensione e poi lo manda quando ha una certa dimensione.</h8>
</div>
<div id="outline-container-org568a13b" class="outline-8">
<h8 id="org568a13b">In alcuni casi, può essere necessario che tutti i dati vengano salvati immediatamente</h8>
</div>
<div id="outline-container-org8e5ad1c" class="outline-8">
<h8 id="org8e5ad1c">La differenza con lo urgent è che in questo caso il valore viene mandato da solo ma rispettando l'ordine.</h8>
</div>
</div>
<div id="outline-container-orgae4bcbd" class="outline-7">
<h7 id="orgae4bcbd">Poi ci sono RST, SYN e FIN che non ho ascoltato. Reset, sincronizzazione e chiudi connessione.</h7>
</div>
</div>
<div id="outline-container-orgef0fe55" class="outline-6">
<h6 id="orgef0fe55">I restanti 16 bit di Window Size indicano lo spazio ancora disponibile nel ricevitore.</h6>
<div class="outline-text-6" id="text-orgef0fe55">
</div>
<div id="outline-container-org318e7c6" class="outline-7">
<h7 id="org318e7c6">Chi sta trasmettendo, leggendo questo campo può capire se l'altra macchina sostiene il rate o deve rallentare.</h7>
</div>
</div>
</div>
<div id="outline-container-org2cb1a3d" class="outline-5">
<h5 id="org2cb1a3d">Nella quarta pagina:</h5>
<div class="outline-text-5" id="text-org2cb1a3d">
</div>
<div id="outline-container-orga0a4e54" class="outline-6">
<h6 id="orga0a4e54">Un checksum a 16 bit, che poi vedremo come viene calcolato, che ci permette di capire se tutto è corretto e viene collegato sulla base dello pseudoheader e tiene anche conto della conformità del payload (controllo degli errori)</h6>
<div class="outline-text-6" id="text-orga0a4e54">
</div>
<div id="outline-container-orgb2fb5d2" class="outline-7">
<h7 id="orgb2fb5d2">Lo pseudoheader è una versione ridotta dello header.</h7>
</div>
</div>
<div id="outline-container-org8593508" class="outline-6">
<h6 id="org8593508">Poi uno Urgent Pointer, che viene letto se e solo se il frame urgent è a 1, altrimenti non ce ne frega perchè viene trascurato.</h6>
<div class="outline-text-6" id="text-org8593508">
</div>
<div id="outline-container-org1f5c48b" class="outline-7">
<h7 id="org1f5c48b">Indica l'offset all'interno del campo data oltre il quale i dati sono urgent.</h7>
</div>
<div id="outline-container-org1682fd7" class="outline-7">
<h7 id="org1682fd7">Per convenzione, i dati urgent vengono messi alla fine del segmento e quindi non spazio per la fine della parte urgente.</h7>
</div>
</div>
</div>
<div id="outline-container-orgcbfdd4f" class="outline-5">
<h5 id="orgcbfdd4f">Dopodichè abbiamo le options, parole di 16 bit di cui può esserci un numero variabile.</h5>
</div>
<div id="outline-container-org9c389da" class="outline-5">
<h5 id="org9c389da">Dopo le n options, c'è il payload.</h5>
</div>
</div>
<div id="outline-container-org8091ea7" class="outline-4">
<h4 id="org8091ea7">Come si diceva, TCP è orientato alla connessione.</h4>
<div class="outline-text-4" id="text-org8091ea7">
</div>
<div id="outline-container-orgc98330d" class="outline-5">
<h5 id="orgc98330d">La connessione è bidirezionale, ma noi analizzeremo solo un lato della connessione, perchè analizzare entrambe sarebbe molto confuso.</h5>
<div class="outline-text-5" id="text-orgc98330d">
</div>
<div id="outline-container-org076b3df" class="outline-6">
<h6 id="org076b3df">Ognuno trasmette e riceve in modo di indipendente. Quindi la sequence e lo ACK sono relativi solo ad una direzione della connessione.</h6>
</div>
</div>
<div id="outline-container-org65a532d" class="outline-5">
<h5 id="org65a532d">All'apertura della connessione, da entrambe le macchine viene generato un sequence number ISN casuale, per ragioni di sicurezza</h5>
<div class="outline-text-5" id="text-org65a532d">
</div>
<div id="outline-container-orgc1813f6" class="outline-6">
<h6 id="orgc1813f6">Altrimenti si potrebbe indovinare un numero ed inserirsi nella connessione</h6>
</div>
<div id="outline-container-org543a84f" class="outline-6">
<h6 id="org543a84f">I due flussi, e quindi i due numeri di sequenza, sono indipendenti.</h6>
</div>
</div>
<div id="outline-container-org08d9b61" class="outline-5">
<h5 id="org08d9b61">A chiede di aprire una connessione e manda un segmento con il frame SYN = 1 e il Seq = X (quello generato casualmente da A).</h5>
</div>
<div id="outline-container-org6746559" class="outline-5">
<h5 id="org6746559">B riceve il segmento e ne manda uno di risposta in cui SYN = 1, ACK = 1, Seq = Y (quello generato casualmente da B) e Ack = x + 1.</h5>
<div class="outline-text-5" id="text-org6746559">
</div>
<div id="outline-container-orgc447d6b" class="outline-6">
<h6 id="orgc447d6b">Il bit di ACK attivato indica che il valore in Ack è significativo è può essere letto.</h6>
</div>
<div id="outline-container-org5f2f78a" class="outline-6">
<h6 id="org5f2f78a">Lo ack a x+1 indica che si è pronti ad andare avanti con la trasmissione. Il primo segmento parte da x ed è lungo 1, quindi il prossimo che sono pronto ad ascoltare è il successivo.</h6>
</div>
</div>
<div id="outline-container-orgb404532" class="outline-5">
<h5 id="orgb404532">A riceve il segmento e risponde con ACK=1 e Ack = y+1</h5>
</div>
<div id="outline-container-orga76d05c" class="outline-5">
<h5 id="orga76d05c">In tutti i 3 segmenti superiori, il valore del resto dello header e payload non importano.</h5>
</div>
<div id="outline-container-orgcbd15f9" class="outline-5">
<h5 id="orgcbd15f9">La procedura prende il nome di three-way handshake.</h5>
</div>
<div id="outline-container-orgc3d2a5d" class="outline-5">
<h5 id="orgc3d2a5d">Gestione casi delicati</h5>
<div class="outline-text-5" id="text-orgc3d2a5d">
</div>
<div id="outline-container-orge7c6864" class="outline-6">
<h6 id="orge7c6864">Viene introdotto un Timer, RTO, che gestisce il caso in cui uno fra i primi due segmenti di handshake vengano persi.</h6>
<div class="outline-text-6" id="text-orge7c6864">
</div>
<div id="outline-container-org7886423" class="outline-7">
<h7 id="org7886423">Come nel data link, se il timer scade perchè uno qualunque dei primi frame è scomparso, si prova ad aprire nuovamente la connessione.</h7>
</div>
</div>
<div id="outline-container-org0b86596" class="outline-6">
<h6 id="org0b86596">Il timer gestisce anche i casi in cui l'handshake di risposta ci impieghi troppo ad arrivare ( o si può dire che dopo il tempo \(T\) si assuma che la connessione è persa e bisogna gestire il caso in cui la risposta invece arrivi)</h6>
<div class="outline-text-6" id="text-org0b86596">
</div>
<div id="outline-container-org8ab4ec6" class="outline-7">
<h7 id="org8ab4ec6">Ogni nuova riapertura aggiorna il SEQ casuale</h7>
</div>
<div id="outline-container-org2afe986" class="outline-7">
<h7 id="org2afe986">Se arriva una risposta per un apertura precedente, è facile dal numero di sequenza capire che non sia la risposta corretta</h7>
</div>
<div id="outline-container-org6e7c3e5" class="outline-7">
<h7 id="org6e7c3e5">In tal caso, si manda un messaggio con RST e si chiude la connessione.</h7>
</div>
</div>
</div>
<div id="outline-container-orga81d42f" class="outline-5">
<h5 id="orga81d42f">Utilizzando lo stesso concetto di base del port scanning, si può fare SYN FLOOD.</h5>
<div class="outline-text-5" id="text-orga81d42f">
</div>
<div id="outline-container-orgbcf430c" class="outline-6">
<h6 id="orgbcf430c">Mando tanti messaggi di SYN sulle varie porte.</h6>
</div>
<div id="outline-container-org43e8158" class="outline-6">
<h6 id="org43e8158">Il server mi risponde genuinamente e attende per la mia 3 risposta, finale, di handshake.</h6>
</div>
<div id="outline-container-org6316a53" class="outline-6">
<h6 id="org6316a53">Io non rispondo e il server deve allocare risorse per tanti syn aperti contemporaneamente.</h6>
</div>
<div id="outline-container-org6bb7e36" class="outline-6">
<h6 id="org6bb7e36">Se invece rispondo con un RST, non effettuo un attacco e non peso sulle risorse, ma analizzo soltanto le porte aperte.</h6>
<div class="outline-text-6" id="text-org6bb7e36">
<p>
lesgoski
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8d7197d" class="outline-2">
<h2 id="org8d7197d">Quindi siamo arrivati al SYN che uno manda per aprire la connessione, con un numero di sequenza generato in numero casuale. Il canale è bidirezionale e quindi avviene tutto nello stesso modo in entrambi gli host.</h2>
<div class="outline-text-2" id="text-org8d7197d">
</div>
<div id="outline-container-org4a35ac4" class="outline-3">
<h3 id="org4a35ac4">Il SYN parte a 1, in risposta il SYN è a uno e anche l'ACK, che indica che il campo Ack è significativo e tale campo è numDiSequenza +1, per indicare che quello è il prossimo bit che si è pronti a ricevere.</h3>
<div class="outline-text-3" id="text-org4a35ac4">
</div>
<div id="outline-container-orgb1b713d" class="outline-4">
<h4 id="orgb1b713d">Ovviamente manda anche il proprio numero di sequenza.</h4>
</div>
</div>
<div id="outline-container-org79f9b79" class="outline-3">
<h3 id="org79f9b79">Se tutto va a buon fine, la terza risposta dal sender è uguale alla seconda dal receiver e da lì in poi la connessione è aperta.</h3>
</div>
<div id="outline-container-orgcc32eac" class="outline-3">
<h3 id="orgcc32eac">C'è un timer che garantisce che se l'ACK viene perso, o impiega troppo tempo ad arrivare, venga mandato un messaggio con RESET a 1 che annulla l'handshake, che va rieffettuato</h3>
<div class="outline-text-3" id="text-orgcc32eac">
<pre class="example" id="org19204cc">
Let me explain why starting sequence numbers in the Transport layer are random:

    Security: Random initial sequence numbers help prevent TCP sequence prediction attacks. If sequence numbers were predictable, attackers could potentially hijack TCP connections by guessing the next sequence number.

    Connection Uniqueness: Random sequence numbers reduce the likelihood of old segments from previous connections being mistakenly accepted as valid in new connections between the same endpoints.

    Prevents Segment Mix-up: If multiple connections are established between the same hosts, random sequence numbers help ensure segments from different connections don't get mixed up.

    Protection against Spoofing: Random initial sequence numbers make it harder for attackers to inject fake segments into an existing connection since they would need to guess the correct sequence number.

    Avoids Overlap: In case of delayed segments from previous connections, random sequence numbers help prevent confusion between old and new data streams.

This randomization is a crucial security measure in modern TCP implementations and helps maintain the integrity and reliability of network communications.
</pre>
</div>
</div>
<div id="outline-container-org369f4fe" class="outline-3">
<h3 id="org369f4fe">In ogni header è indicato il Max Segment Size, che indica la dimensione massima di segmento che l'host può gestire senza andare in overflow.</h3>
<div class="outline-text-3" id="text-org369f4fe">
</div>
<div id="outline-container-org127bb79" class="outline-4">
<h4 id="org127bb79">La dimensione Standard, quando il campo è vuoto, il segmento è di 536 byte.</h4>
</div>
</div>
<div id="outline-container-org97bcd2a" class="outline-3">
<h3 id="org97bcd2a">L'obiettivo di TCP è trasferire i dati nel miglior modo, garantendo affidabilità, gest.errori, ordine ecc., e anche farlo in modo efficiente, evitando un overhead eccessivo</h3>
</div>
<div id="outline-container-org7150122" class="outline-3">
<h3 id="org7150122">Il motivo per cui viene scelta 536 byte è che siamo sicuri che il livello IP non frammenterà tale segmento in più pacchetti.</h3>
<div class="outline-text-3" id="text-org7150122">
</div>
<div id="outline-container-org708ecef" class="outline-4">
<h4 id="org708ecef">Per ogni frammentazione effettuata dall'IP, serve copiare sia header TCP che IP, introducendo overhead.</h4>
</div>
<div id="outline-container-orgafd2787" class="outline-4">
<h4 id="orgafd2787">Inoltre, essendo la rete best-effort, quanti più sotto-segmenti vengono mandati quanto più è probabile che avvengano dei problemi che dovranno essere poi gestiti</h4>
</div>
</div>
<div id="outline-container-org88522cb" class="outline-3">
<h3 id="org88522cb">Immaginiamo di avere una connessione A-B in TCP, necessariamente bidirezionale.</h3>
<div class="outline-text-3" id="text-org88522cb">
</div>
<div id="outline-container-orgec68a1b" class="outline-4">
<h4 id="orgec68a1b">Dato che noi analizziamo solo i casi "unidirezionali", noi valutiamo solo SendingBuffer e TcpSendingBuffer nel sender, e i corrispondenti ma per il receiver nel receiver.</h4>
</div>
<div id="outline-container-org90fbe8c" class="outline-4">
<h4 id="org90fbe8c">Assumiamo che la segment size sia 500.</h4>
</div>
<div id="outline-container-org956ec3b" class="outline-4">
<h4 id="org956ec3b">L'applicazione lato sender scrive 2000 byte nell'SB della socket esposto.</h4>
</div>
<div id="outline-container-org4d97452" class="outline-4">
<h4 id="org4d97452">Ovviamente, va eseguita una frammentazione a livello trasporto.</h4>
<div class="outline-text-4" id="text-org4d97452">
</div>
<div id="outline-container-orgfe25b21" class="outline-5">
<h5 id="orgfe25b21">Assumiamo per ora che non avvengano problemi nella trasmissione.</h5>
</div>
</div>
<div id="outline-container-orgeba6369" class="outline-4">
<h4 id="orgeba6369">Nel sending buffer della TCP, nascosto al livello applicazione, vengono copiati e segmentati opportunamente i byte del buffer superiore.</h4>
</div>
<div id="outline-container-org7be641f" class="outline-4">
<h4 id="org7be641f">Nello header è presente l'informazione SEQ=X. Il payload sarà dal byte X a quello X + 499</h4>
<div class="outline-text-4" id="text-org7be641f">
</div>
<div id="outline-container-org7033c48" class="outline-5">
<h5 id="org7033c48">X è in realtà X+1 se la connessione è appena stata instaurata, ma per semplicità si considera X il valore corrente.</h5>
</div>
</div>
<div id="outline-container-org10abce3" class="outline-4">
<h4 id="org10abce3">Nel frattempo, il receiver si aspettava il Sequence Number = X e così si accerta che l'ordine sia corretto.</h4>
</div>
<div id="outline-container-org0d8e819" class="outline-4">
<h4 id="org0d8e819">I dati arrivano nel buffer inferiore, ma dato che l'ordine è corretto, vengono subito copiati nel buffer superiore.</h4>
</div>
<div id="outline-container-orgf479fad" class="outline-4">
<h4 id="orgf479fad">Lo header risposta del receiving buffer contiene il campo ACK a 1 e quello Ack a X + 500, che è il primo byte successivo a quello ricevuto.</h4>
<div class="outline-text-4" id="text-orgf479fad">
</div>
<div id="outline-container-org48407ef" class="outline-5">
<h5 id="org48407ef">Implicitamente vuol dire che il segmento precedente è correttamente ricevuto.</h5>
</div>
</div>
<div id="outline-container-orgc124063" class="outline-4">
<h4 id="orgc124063">Il sender elimina dal buffer del TCP il segmento corrispondente.</h4>
</div>
<div id="outline-container-org30f28c9" class="outline-4">
<h4 id="org30f28c9">Allora, il prossimo segmento mandato è quello che parte da X+500 e questo valore è nel SEQ dello header.</h4>
</div>
<div id="outline-container-org7fbf26a" class="outline-4">
<h4 id="org7fbf26a">Anche questo pacchetto è in ordine e quindi va subito spostato nel buffer superiore.</h4>
<div class="outline-text-4" id="text-org7fbf26a">
</div>
<div id="outline-container-org6eb57e0" class="outline-5">
<h5 id="org6eb57e0">Il TCP tiene tutti i segmenti non in ordine nel buffer inferiore.</h5>
</div>
<div id="outline-container-org6d365fb" class="outline-5">
<h5 id="org6d365fb">Ogni segmento correttamente ricevuto, ma successivo ad un segmento non ricevuto, rimane nel buffer inferiore.</h5>
</div>
</div>
<div id="outline-container-orgc459ccd" class="outline-4">
<h4 id="orgc459ccd">Analogamente al messaggio precedente, il receiver risponde con un Ack = X+1000.</h4>
<div class="outline-text-4" id="text-orgc459ccd">
</div>
<div id="outline-container-org5ef5d5c" class="outline-5">
<h5 id="org5ef5d5c">Anche adesso, il sender si libera del segmento.</h5>
</div>
</div>
<div id="outline-container-org1657fe8" class="outline-4">
<h4 id="org1657fe8">Procedo così fino allo svuotamento del buffer di invio.</h4>
</div>
</div>
<div id="outline-container-orge9c6f80" class="outline-3">
<h3 id="orge9c6f80">Nella configurazione precedente, c'è un problema nel caso in cui ho bisogno di (real-time?) ad esempio ssh su una console remota.</h3>
<div class="outline-text-3" id="text-orge9c6f80">
</div>
<div id="outline-container-orgf31e32d" class="outline-4">
<h4 id="orgf31e32d">Voglio che i dati vengano processati byte per byte</h4>
</div>
<div id="outline-container-orgf3a82b7" class="outline-4">
<h4 id="orgf3a82b7">Allora uso la flag PUSH, in modo che TCP spedisca il singolo byte, senza arrivare ad una dimensione del segmento di 500 byte come prima</h4>
</div>
<div id="outline-container-orgc1a8f6c" class="outline-4">
<h4 id="orgc1a8f6c">Quando PUSH viene usata, il receiver manda un regolare ACK, con Ack X+1</h4>
</div>
<div id="outline-container-orge4e09de" class="outline-4">
<h4 id="orge4e09de">In questo caso, però, viene fatta una eco dello stesso byte, questa volta</h4>
</div>
<div id="outline-container-org4fc03d8" class="outline-4">
<h4 id="org4fc03d8">Il motivo per cui viene fatta la eco è che il sender prende input a tastiera ma non mostra direttamente a schermo, perchè non è sicuro che dall'altra parte sia correttamente ricevuto. Solo quando si è sicuri che dall'altra parte sia stato ricevuto, viene stampato a tastiera</h4>
<div class="outline-text-4" id="text-org4fc03d8">
<pre class="example" id="org736ac7b">
Let me explain why TCP echoes bytes with the PUSH flag:

    Data Acknowledgment vs Echo:

    The ACK simply acknowledges receipt of data
    The echo (sending the same byte back) serves a different purpose: it confirms the connection is still alive and functioning in both directions

    Key Benefits of Echoing:

    Tests bi-directional data flow
    Helps detect half-open connections
    Provides an additional validation mechanism beyond simple acknowledgment
    Useful for interactive applications where immediate response is needed

    Relationship to PUSH Flag:

    The PUSH flag indicates that data should be delivered to the application immediately
    Echoing PUSH-flagged bytes ensures the urgent nature of the data is maintained in both directions
    This is particularly important for interactive protocols like Telnet where character-by-character feedback is needed

The echo mechanism complements ACKs rather than duplicating them - ACKs confirm receipt, while echoes validate the full duplex nature of the connection and maintain interactive responsiveness.
</pre>
</div>
</div>
</div>
<div id="outline-container-org9e7ab83" class="outline-3">
<h3 id="org9e7ab83">Per garantire&#x2026;(?) viene introdotto il delay acknowledgment.</h3>
<div class="outline-text-3" id="text-org9e7ab83">
</div>
<div id="outline-container-org7afb419" class="outline-4">
<h4 id="org7afb419">La questione è che TCP ignora l'obiettivo delle applicazioni, ma loro lo sanno e potrebbero voler inserire più informazioni nello header.</h4>
</div>
<div id="outline-container-orga25a70e" class="outline-4">
<h4 id="orga25a70e">Immaginiamo una situazione come prima: si riceve un byte pushato.</h4>
</div>
<div id="outline-container-orgd8eb813" class="outline-4">
<h4 id="orgd8eb813">Il receiver, però, non risponde subito con un Ack, ma aspetta un tempo (standard 200ms).</h4>
</div>
<div id="outline-container-org081b0fc" class="outline-4">
<h4 id="org081b0fc">Se in quel tempo arriva qualcosa nel buffer di invio del ricevitore, quei dati vengono incorporati nel messaggio di Ack.</h4>
<div class="outline-text-4" id="text-org081b0fc">
</div>
<div id="outline-container-org8f27e17" class="outline-5">
<h5 id="org8f27e17">In questo caso, sia sequence che ack number sono considerati. Seq è quello che ti do, ack quello che prendo.</h5>
<div class="outline-text-5" id="text-org8f27e17">
</div>
<div id="outline-container-org95fadc3" class="outline-6">
<h6 id="org95fadc3">Prima invece, il campo sequence non era mai impostato</h6>
</div>
</div>
</div>
<div id="outline-container-orgcf08a4e" class="outline-4">
<h4 id="orgcf08a4e">In questo caso, quando la eco viene aggiunta nel buffer di invio della ricezione, viene inserita nello stesso frame di Ack. Così ri risparmia un messaggio TCP.</h4>
<div class="outline-text-4" id="text-orgcf08a4e">
<pre class="example" id="orgf62fd38">
Let me explain a common TCP optimization technique from computer networking. This technique is called "Delayed Acknowledgment" or "Delayed ACK."

The Delayed ACK technique involves:

    Deliberately waiting for a short period (typically around 200ms) before sending an ACK
    During this wait period, if the receiving host has data to send back to the sender, it can combine (piggyback) the ACK with this outgoing data
    The wait period also allows the receiver to potentially combine multiple ACKs into a single response if more segments arrive during the delay

This technique helps improve network efficiency by:

    Reducing protocol overhead
    Minimizing the number of small packets on the network
    Taking advantage of bi-directional data flow
    Optimizing bandwidth usage by combining ACKs with data when possible

However, Delayed ACK is not used in all cases - for example, every second full-sized segment must be acknowledged immediately to maintain TCP's flow control mechanisms.
</pre>
</div>
<div id="outline-container-orgd67c8a4" class="outline-5">
<h5 id="orgd67c8a4">Il prossimo messaggio del sender sarà sia un ACK della echo che un send del byte successivo.</h5>
</div>
</div>
<div id="outline-container-org51c0a00" class="outline-4">
<h4 id="org51c0a00">Questa soluzione è efficiente dal punto di vista di rete, ma inefficiente dal punto di vista della user-experience.</h4>
<div class="outline-text-4" id="text-org51c0a00">
</div>
<div id="outline-container-org1899905" class="outline-5">
<h5 id="org1899905">Per trovare un compromesso fra rete e user-experience, si utilizza la tecnica del <b>NAGLE</b>.</h5>
<div class="outline-text-5" id="text-org1899905">
</div>
<div id="outline-container-org3b817da" class="outline-6">
<h6 id="org3b817da">Ho un sender con una serie di segmenti composti da un singolo byte da pushare.</h6>
</div>
<div id="outline-container-org8472f26" class="outline-6">
<h6 id="org8472f26">Come prima, mando un segmento con il byte, il receiver lo riceve e aspetta 200ms.</h6>
<div class="outline-text-6" id="text-org8472f26">
</div>
<div id="outline-container-orgcac7180" class="outline-7">
<h7 id="orgcac7180">L'applicazione riceve il byte e fa la ACK + echo, con SEQ = Y, PUSH attivato, ACK attivato e Ack = X + 1</h7>
</div>
</div>
<div id="outline-container-org625a319" class="outline-6">
<h6 id="org625a319">I successivi byte vengono impacchettati in un singolo segmento e mandati tutti insieme. Il receiver risponde con l'ack.</h6>
<div class="outline-text-6" id="text-org625a319">
</div>
<div id="outline-container-org14d9f72" class="outline-7">
<h7 id="org14d9f72"><span class="todo TODO">TODO</span> Capire se viene effettuata la echo dei byte in blocco e se viene fatta byte per byte o cumulativa.</h7>
<div class="outline-text-7" id="text-org14d9f72">
<pre class="example" id="orgdd49d0b">
No, when using Nagle's algorithm, the block of bytes in the second segment is not echoed, and the ACK does not contain an echo of the whole block. Here's why:

    First byte behavior:

    The first byte is sent immediately (Nagle allows this)
    This byte gets acknowledged and echoed (typical for interactive data)

    Block of bytes behavior:

    The subsequent block is sent as a single segment due to Nagle's algorithm
    The receiver only sends an ACK for this data
    The block is NOT echoed back

The reason for this difference is:

    Single byte echoing is typically used for interactive traffic (like telnet) where immediate feedback is needed
    Larger blocks of data don't need character-by-character echo feedback
    Echoing large blocks would be inefficient and isn't necessary for bulk data transfer
    The ACK alone is sufficient to confirm receipt of the block

This behavior helps optimize network performance by:

    Reducing unnecessary network traffic
    Preventing excessive echoing of bulk data
    Maintaining interactivity where needed (single bytes)
    Providing reliable delivery confirmation through ACKs
</pre>

<pre class="example" id="org699fd11">
The echo of the first byte in Nagle's algorithm serves these specific purposes:

    Connection Validation:

    The echo of the first byte confirms that the connection is fully functional in both directions
    It quickly verifies that the remote end is responsive and processing data

    Interactive Feedback:

    For interactive applications (like telnet or ssh), the first byte often represents a keystroke
    Users need immediate feedback for this first input to confirm their interaction
    The echo provides visual confirmation that the connection is working

    Fast Start Verification:

    Rather than waiting for the full data transfer to verify connection quality
    The single byte echo serves as a quick initial test of the connection

    Protocol Efficiency:

    Only echoing the first byte (not the subsequent block) is a compromise between:
        Providing necessary interactive feedback
        Avoiding unnecessary network overhead for bulk data
    After the initial verification, regular ACKs are sufficient for bulk data transfer

This selective echoing behavior combines the benefits of interactive responsiveness for the initial byte with efficient bulk transfer for subsequent data.
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8944071" class="outline-4">
<h4 id="org8944071"></h4>
</div>
</div>
<div id="outline-container-org2f34f11" class="outline-3">
<h3 id="org2f34f11">In caso di errori, è lo stesso TCP che se ne accorge e cerca di sanarlo.</h3>
<div class="outline-text-3" id="text-org2f34f11">
</div>
<div id="outline-container-org0a4374b" class="outline-4">
<h4 id="org0a4374b">TCP è orientato allo stream.</h4>
<div class="outline-text-4" id="text-org0a4374b">
</div>
<div id="outline-container-org7aff566" class="outline-5">
<h5 id="org7aff566">Abbiamo già visto che a livello 2 ogni pacchetto è identificato da un numero che viene utilizzato per riconoscere i frame su cui avviene l'errore.</h5>
</div>
<div id="outline-container-orgd7e5892" class="outline-5">
<h5 id="orgd7e5892">In TCP l'idea del sequence number è che, conoscendo la dimensione del file \(N\), il segmento va da \(X\) a \(X+N\).</h5>
</div>
<div id="outline-container-org1ec49de" class="outline-5">
<h5 id="org1ec49de">Ci interessa capire fino a che punto dello stream è stato ricevuto tutto correttamente.</h5>
<div class="outline-text-5" id="text-org1ec49de">
</div>
<div id="outline-container-org981b590" class="outline-6">
<h6 id="org981b590">Ovvero, l'indice \(K<N\) fino a cui è assicurata la comunicazione avvenuta correttamente.</h6>
</div>
</div>
<div id="outline-container-org6aeaa0d" class="outline-5">
<h5 id="org6aeaa0d">Quindi il sequence number sommato al payload, mi da il nuovo numero di sequenza.</h5>
</div>
<div id="outline-container-org4aca1dd" class="outline-5">
<h5 id="org4aca1dd">Immaginiamo di avere una situazione in cui l'app sender debba spedire 2400 byte con una dimensione del segmento di 500.</h5>
</div>
<div id="outline-container-orged74cfe" class="outline-5">
<h5 id="orged74cfe">Il primo segmento viene spedito con SEQ=X.</h5>
</div>
<div id="outline-container-orge9c5362" class="outline-5">
<h5 id="orge9c5362">Il secondo viene spedito senza aspettare l'ACK, con SEQ=X+500</h5>
</div>
<div id="outline-container-orgf0576e2" class="outline-5">
<h5 id="orgf0576e2">Si immagini adesso che il secondo segmento venga perso.</h5>
</div>
<div id="outline-container-org4d199b0" class="outline-5">
<h5 id="org4d199b0">Nel frattempo, il receiver risponde con un ACK per il primo segmento, ovvero con Ack X + 500 e dato che il segmento è nell'ordine corretto, questo viene spedito al buffer superiore.</h5>
</div>
<div id="outline-container-orgde9e891" class="outline-5">
<h5 id="orgde9e891">Quando il secondo segmento è spedito ma non è stato ricevuto l'ack corrispondente, il segmento è ancora nel sending buffer del tcp del sender.</h5>
</div>
<div id="outline-container-org604fc18" class="outline-5">
<h5 id="org604fc18">Comunque non aspetto l'ACK del secondo, perchè essendoci la rete per mezzo, non posso sapere se arriverà a breve o non arriverà.</h5>
</div>
<div id="outline-container-org2926dd8" class="outline-5">
<h5 id="org2926dd8">Quindi mando il terzo, con SEQ=X+1000.</h5>
</div>
<div id="outline-container-org8e94444" class="outline-5">
<h5 id="org8e94444">Quando il receiver riceve questo segmento, lo mette nel suo buffer, ma risponde con lo stesso ACK di prima.</h5>
<div class="outline-text-5" id="text-org8e94444">
</div>
<div id="outline-container-orgac4ceb9" class="outline-6">
<h6 id="orgac4ceb9">Ovvero, si intende che sebbene qualcosa sia ricevuto, non "riempie lo spazio" di ciò che non era stato ricevuto.</h6>
</div>
</div>
<div id="outline-container-orgdc46ecb" class="outline-5">
<h5 id="orgdc46ecb">La questione è che ogni segmento attiva un timer. Finchè il timer non scade, TCP prosegue con <b>tutti</b> i segmenti successivi in buffer d'invio.</h5>
</div>
<div id="outline-container-orga85e9e4" class="outline-5">
<h5 id="orga85e9e4">Quando il timer scade, soltanto quello specifico segmento viene inviato.</h5>
</div>
<div id="outline-container-org9eb6a05" class="outline-5">
<h5 id="org9eb6a05">A questo punto, il ricevitore si renderà conto che quel segmento, il secondo in questo caso, va posizionato prima dei successivi, che già possiede nel buffer. Allora tutti quelli successivi saranno sbloccati ed il prossimo ACK li includerà. Si parla quindi di ACK cumulativo.</h5>
</div>
<div id="outline-container-org1f07b7c" class="outline-5">
<h5 id="org1f07b7c">Questa roba si chiama <b>fast retransmit</b>, ovvero la ritrasmissione di un singolo segmento.</h5>
</div>
<div id="outline-container-org2e5d87f" class="outline-5">
<h5 id="org2e5d87f">Il timer è pensato per considerare il caso di perdita, anche abbastanza inusuale, sovradimensionato.</h5>
</div>
<div id="outline-container-orgd8a60ef" class="outline-5">
<h5 id="orgd8a60ef">Si usa però anche una strategia del triplo ACK: al terzo ACK uguale ricevuto, viene inviato il segmento corrispondente.</h5>
</div>
<div id="outline-container-org39715f4" class="outline-5">
<h5 id="org39715f4">Usando queste due strategie, si limita il danno sull'efficienza del timeout e si rende più veloce l'invio dei segmenti precedenti.</h5>
<div class="outline-text-5" id="text-org39715f4">
</div>
<div id="outline-container-org9414a7a" class="outline-6">
<h6 id="org9414a7a">Ad esempio, si fa in modo che tutti i segmenti in coda nel buffer a cui serve quello perso per sbloccarsi, debbano aspettare al massimo T ma spesso anche di meno, così da ridurre lo spazio di memoria occupato.</h6>
</div>
</div>
<div id="outline-container-org36c6f51" class="outline-5">
<h5 id="org36c6f51">Il timer è anche molto utile per gli ultimi (?)2 segmenti, dopo i quali non esistono 3 ack che facciano partire la ritrasmissione.</h5>
<div class="outline-text-5" id="text-org36c6f51">
</div>
<div id="outline-container-org0ddf778" class="outline-6">
<h6 id="org0ddf778"><span class="todo TODO">TODO</span> Per quanti segmenti vale questa proprietà</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3f50fe8" class="outline-2">
<h2 id="org3f50fe8">Negle ha un utilità quando vogliamo garantire un utilizzo efficiente della rete.</h2>
<div class="outline-text-2" id="text-org3f50fe8">
</div>
<div id="outline-container-orgc085dba" class="outline-3">
<h3 id="orgc085dba">Lo si usa al posto di mandare ogni carattere da solo, con un overhead altissimo dovuto allo header IP e TCP.</h3>
<div class="outline-text-3" id="text-orgc085dba">
</div>
<div id="outline-container-org9c0f8c9" class="outline-4">
<h4 id="org9c0f8c9">Per mandare un byte, mi servono 4 messaggi.</h4>
</div>
<div id="outline-container-orgfe24cd3" class="outline-4">
<h4 id="orgfe24cd3">Si usa il delay per diminuire i messaggi che vengono mandati, ma si paga troppo tempo per l'attesa del delay ogni volta, con piggy bagging in cui nei dati da comunicare si inserisce anche l'ack cumulativo</h4>
</div>
<div id="outline-container-org2b1eaca" class="outline-4">
<h4 id="org2b1eaca">Un compromesso e il nagle</h4>
</div>
</div>
<div id="outline-container-orga18f056" class="outline-3">
<h3 id="orga18f056">Il Nagle viene in supporto quando abbiamo un quantitativo di dati dall'applicazione, ovvero nel SB (superiore) che è minore alla maximum segment size.</h3>
<div class="outline-text-3" id="text-orga18f056">
</div>
<div id="outline-container-orgb3be167" class="outline-4">
<h4 id="orgb3be167">Nagle innanzitutto guarda il TCP Sending Buffer (quello inferiore). Se è vuoto vuol dire che non sto aspettando nessun ACK.</h4>
<div class="outline-text-4" id="text-orgb3be167">
</div>
<div id="outline-container-org91bb292" class="outline-5">
<h5 id="org91bb292">In questo caso, invio direttamente il contenuto dell'SB, nonostante sia inferiore.</h5>
</div>
</div>
<div id="outline-container-org9d2b855" class="outline-4">
<h4 id="org9d2b855">Se invece ci sono altri segmenti nel buffer inferiore, lo accoda.</h4>
</div>
<div id="outline-container-orgb8c6e61" class="outline-4">
<h4 id="orgb8c6e61">Uno dei lati negativi di Nagle è che sebbene utilizzi bene la rete, ovvero limitando l'overhead, (QUAL è L'ASPETTO NEGATIVO)?</h4>
</div>
</div>
<div id="outline-container-orgd69112e" class="outline-3">
<h3 id="orgd69112e">Un altro aspetto è che tcp è orientato allo stream e ragiona in base ai bit.</h3>
<div class="outline-text-3" id="text-orgd69112e">
</div>
<div id="outline-container-org8b90cf5" class="outline-4">
<h4 id="org8b90cf5">Una sequenza di dati presente nel sending buffer non dev'essere multiplo della max segment size. Il TCP suddivide in blocchetti della dimensione corretta.</h4>
<div class="outline-text-4" id="text-org8b90cf5">
</div>
<div id="outline-container-org7bcad21" class="outline-5">
<h5 id="org7bcad21">Se un ultimo blocchetto non raggiunge la max segment size, sta all'applicazione decidere se mandarlo subito o se aspettare nuovi dati, la cui prima parte verrà aggiunta all'ultimo segmento e mandata tutto insieme.</h5>
</div>
</div>
<div id="outline-container-orga713985" class="outline-4">
<h4 id="orga713985">Quindi si parla di segmento numero n come divisione logica, ma tutto è relativo al byte di inizio sequenza.</h4>
</div>
<div id="outline-container-org5551980" class="outline-4">
<h4 id="org5551980">Il principio è che si occupa il meno possibile. L'eventuale padding è fatto ai livelli inferiori.</h4>
</div>
</div>
<div id="outline-container-org42c0bb3" class="outline-3">
<h3 id="org42c0bb3">Quando TCP invia un pacchetto ad IP, quest'ultimo, conoscendo perfettamente la max transfer unit del suo livello 2, frammenta ulteriormente se necessario.</h3>
<div class="outline-text-3" id="text-org42c0bb3">
</div>
<div id="outline-container-org3cb370e" class="outline-4">
<h4 id="org3cb370e">IP stesso riassemblerà poi la serie di pacchetti e la fornirà a tcp</h4>
</div>
<div id="outline-container-org18520ee" class="outline-4">
<h4 id="org18520ee">Se non ci riesce, a TCP non arriverà assolutamente nulla.</h4>
<div class="outline-text-4" id="text-org18520ee">
</div>
<div id="outline-container-orgb80414d" class="outline-5">
<h5 id="orgb80414d">Inoltre, solo il primo pacchetto avrà lo header tcp.</h5>
</div>
</div>
</div>
<div id="outline-container-org391b8a0" class="outline-3">
<h3 id="org391b8a0">Come abbiamo già visto, il round trip time è il tempo necessario perchè un segmento venga inviato ed ackAto.</h3>
<div class="outline-text-3" id="text-org391b8a0">
</div>
<div id="outline-container-orgc18b325" class="outline-4">
<h4 id="orgc18b325">Possiamo però anche inviare più segmenti nello stesso momento.</h4>
</div>
<div id="outline-container-org863348b" class="outline-4">
<h4 id="org863348b">Ogni segmento fa partire un timer, che dev'essere dimensionato correttamente e quindi non può essere statico.</h4>
</div>
<div id="outline-container-org74b4664" class="outline-4">
<h4 id="org74b4664">Esiste uno standard che ci spiega come calcolarlo</h4>
<div class="outline-text-4" id="text-org74b4664">
</div>
<div id="outline-container-org6cd48c7" class="outline-5">
<h5 id="org6cd48c7">Diciamo che il round trip time in media impieghi 30 ms</h5>
</div>
<div id="outline-container-org5b2f1c1" class="outline-5">
<h5 id="org5b2f1c1">La stima viene fatta considerandolo come un outlier della distribuzione.</h5>
<div class="outline-text-5" id="text-org5b2f1c1">
</div>
<div id="outline-container-orgaaadd7f" class="outline-6">
<h6 id="orgaaadd7f">Tipicamente si dice che un valore di +3sigma, quindi media più 4 deviazioni standard ci da una stima di un caso molto raro di outlier.</h6>
</div>
<div id="outline-container-org5fd2948" class="outline-6">
<h6 id="org5fd2948">Quindi dobbiamo sapere la media e la deviazione standard in base ai dati del round trip time.</h6>
<div class="outline-text-6" id="text-org5fd2948">
</div>
<div id="outline-container-org1d457dd" class="outline-7">
<h7 id="org1d457dd">INSERIRE FORMULA</h7>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org13990b6" class="outline-3">
<h3 id="org13990b6">Il controllo di flusso viene messo in atto quando il produttore produce molto più velocemente del ricevente.</h3>
<div class="outline-text-3" id="text-org13990b6">
</div>
<div id="outline-container-orge271806" class="outline-4">
<h4 id="orge271806">Infatti, il buffer di ricezione andrebbe poi in overflow.</h4>
<div class="outline-text-4" id="text-orge271806">
</div>
<div id="outline-container-org6c49477" class="outline-5">
<h5 id="org6c49477">Immaginiamo di avere una situazione in cui il sending buffer è di 3000 e il receiving 2000. (mss sempre 500 (ma standard 512)).</h5>
<div class="outline-text-5" id="text-org6c49477">
</div>
<div id="outline-container-orgcb9ff54" class="outline-6">
<h6 id="orgcb9ff54">L'informazione della dimensione dell'altro è nota ad entrambi.</h6>
</div>
<div id="outline-container-org14b05a4" class="outline-6">
<h6 id="org14b05a4">Una volta che il sender ha mandato 2000 bit (in 4 tranche perchè la finestra è di 500), il receiving manda non solo un ACK per controllo errori, ma anche un WIN=0, per il controllo di flusso, che indica che lo spazio è finito.</h6>
</div>
<div id="outline-container-org8af79f2" class="outline-6">
<h6 id="org8af79f2">Quando avrà poi letto 1000 byte, manderà un ACK con lo stesso byte atteso del precedente, ma una window size di 1000.</h6>
</div>
</div>
<div id="outline-container-org41f9561" class="outline-5">
<h5 id="org41f9561">Il problema è che se il secondo ack di riapertura viene perso, il sender rimarrebbe bloccato per sempre, ovvero si avrebbe un deadlock.</h5>
<div class="outline-text-5" id="text-org41f9561">
</div>
<div id="outline-container-orgc40fde9" class="outline-6">
<h6 id="orgc40fde9">Allo scadere di un Persist Timer nel receiver, viene mandato un segmento speciale vuoto, ovvero senza dati, a cui il receiver risponde con un reinvio dell'ack con nuova finestra.</h6>
<div class="outline-text-6" id="text-orgc40fde9">
</div>
<div id="outline-container-orga116e27" class="outline-7">
<h7 id="orga116e27">Se anche quel nuovo ack è perso, allo scadere di un nuovo timer la connessione sarebbe chiusa.</h7>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae545f3" class="outline-4">
<h4 id="orgae545f3">Il problema della silly window syndrome accade quando il receiver riempie la propria window e continua a notificare la nuova disponibilità ma per una quantità di byte minima.</h4>
<div class="outline-text-4" id="text-orgae545f3">
</div>
<div id="outline-container-orgfc8453e" class="outline-5">
<h5 id="orgfc8453e">La soluzione è l'algoritmo di Clark, in cui l'aggiornamento della windows dev'essere almeno grande come la MSS o come la metà del buffer.</h5>
</div>
</div>
<div id="outline-container-org5af507a" class="outline-4">
<h4 id="org5af507a">La rete ignora completamente il controllo di flusso.</h4>
</div>
</div>
</div>
<div id="outline-container-org149aae6" class="outline-2">
<h2 id="org149aae6"><span class="todo TODO">TODO</span> Riempire con ultime 2 lezioni di livello 4</h2>
</div>
<div id="outline-container-orgc668dca" class="outline-2">
<h2 id="orgc668dca">Iniziamo il livello applicazione parlando del DNS, ovvero il Domain Name System.</h2>
<div class="outline-text-2" id="text-orgc668dca">
</div>
<div id="outline-container-orge0cbd2e" class="outline-3">
<h3 id="orge0cbd2e">E' un sistema che permette di rendere più semplice raggiungere un host</h3>
<div class="outline-text-3" id="text-orge0cbd2e">
</div>
<div id="outline-container-orgee697e9" class="outline-4">
<h4 id="orgee697e9">Normalmente si usa un IP per raggiungere un host, ma è praticamente impossibile ricordare un IP.</h4>
</div>
</div>
<div id="outline-container-orgaebad13" class="outline-3">
<h3 id="orgaebad13">Funziona associando un nome (dominio) all'ip di uno specifico host.</h3>
<div class="outline-text-3" id="text-orgaebad13">
</div>
<div id="outline-container-orgb0cf427" class="outline-4">
<h4 id="orgb0cf427">Permette anche di recuperare altre informazioni</h4>
</div>
</div>
<div id="outline-container-org3ffa469" class="outline-3">
<h3 id="org3ffa469">L'idea è quella di disaccoppiare il modo in cui un essere umano raggiunga un certo servizio.</h3>
<div class="outline-text-3" id="text-org3ffa469">
</div>
<div id="outline-container-org5b11c5c" class="outline-4">
<h4 id="org5b11c5c">Ad esempio il servizio potrebbe cambiare indirizzo ip in modo trasparente agli utenti.</h4>
<div class="outline-text-4" id="text-org5b11c5c">
</div>
<div id="outline-container-org2eb4f2f" class="outline-5">
<h5 id="org2eb4f2f">Questo è utilizzato anche per il load balancing, così che il traffico venga diviso su diversi server.</h5>
</div>
</div>
</div>
<div id="outline-container-org2fd1e69" class="outline-3">
<h3 id="org2fd1e69">Il fully qualified domain name (FQDN) contiene un punto alla fine che indica il root domain</h3>
</div>
<div id="outline-container-org25b72aa" class="outline-3">
<h3 id="org25b72aa">Il modo in cui avviene la risoluzione del FQDN fra due macchine, ovvero fra un host che richiede e il server che risponde, è sostituendo ad ogni punto il numero di caratteri che seguono quel punto prima di quello successivo, esempio 2DI5UNIMI2IT0.</h3>
</div>
<div id="outline-container-org8389264" class="outline-3">
<h3 id="org8389264">Una query DNS contiene uno header, il FQDN specifico, il tipo di query(A, AAAA, Mx), la classe (che indica la rete su cui si vuole risolvere, che di fatto è sempre internet)</h3>
<div class="outline-text-3" id="text-org8389264">
</div>
<div id="outline-container-org5db6117" class="outline-4">
<h4 id="org5db6117">Il tipo può essere2 A per IPv4, AAAA per IPv6, MX per posta, CNAME (canonical name) che è un altro nome per lo stesso sito</h4>
</div>
</div>
<div id="outline-container-org2f520a9" class="outline-3">
<h3 id="org2f520a9">La risposta ricopia i dati e inserisce l'indirizzo nell'ultimo campo.</h3>
</div>
<div id="outline-container-org450da38" class="outline-3">
<h3 id="org450da38">Un record DNS in cache può essere associato ad uno specifico TTL, dopo il quale il record scade e la prossima richiesta effettuata da qualunque client dovrà essere risoluta di nuovo</h3>
<div class="outline-text-3" id="text-org450da38">
</div>
<div id="outline-container-org9c5a8cd" class="outline-4">
<h4 id="org9c5a8cd"><span class="todo TODO">TODO</span> Capire funzionamento in caso di record scaduto</h4>
</div>
</div>
<div id="outline-container-org9637bb1" class="outline-3">
<h3 id="org9637bb1">Il resolving DNS avviene con un client che chiede la risoluzione di uno specifico FQDN al resolver all'interno della stessa macchina.</h3>
<div class="outline-text-3" id="text-org9637bb1">
</div>
<div id="outline-container-org55190f4" class="outline-4">
<h4 id="org55190f4">Il resolver usa UDP perchè non gli serve instaurare la connessione e parla con il Local DNS, che viene impostato in fase di configurazione.</h4>
</div>
</div>
<div id="outline-container-org54b497e" class="outline-3">
<h3 id="org54b497e">A livello globale ci sono dei root DNS servers che contengono soltanto i domini di primo livello, con gli IP corrispondenti dei NameServer.</h3>
<div class="outline-text-3" id="text-org54b497e">
</div>
<div id="outline-container-orgef596cf" class="outline-4">
<h4 id="orgef596cf">Usiamo questi se non sappiamo come raggiungere il dominio di primo livello, che di solito però conosciamo già perchè rimane in cache</h4>
</div>
<div id="outline-container-orgc970664" class="outline-4">
<h4 id="orgc970664">Sul libro sono indicati due approcci, uno iterativo e uno ricorsivo, ma gli esempi sono tutti iterativi.</h4>
<div class="outline-text-4" id="text-orgc970664">
</div>
<div id="outline-container-org87cd323" class="outline-5">
<h5 id="org87cd323">L'approccio ricorsivo funziona con il resolver che manda una query al local dns e quest'ultimo risponde con l'indirizzo già pronto.</h5>
<div class="outline-text-5" id="text-org87cd323">
</div>
<div id="outline-container-org7e6346f" class="outline-6">
<h6 id="org7e6346f">Non è implementata nei server per questioni di scalabilità.</h6>
</div>
<div id="outline-container-org6cafc50" class="outline-6">
<h6 id="org6cafc50">Il problema è che sebbene sia molto comoda per il client, il resolver dovrebbe mantenere tantissime informazioni di stato in attesa dei passi successivi.</h6>
</div>
</div>
<div id="outline-container-org7d95c94" class="outline-5">
<h5 id="org7d95c94">L'approccio iterativo si applica dal local dns in poi, mentre fra resolver e local dns rimane ricorsivo, ovvero il local dns mantiene lo stato della richiesta fino all'invio della risposta al resolver.</h5>
<div class="outline-text-5" id="text-org7d95c94">
</div>
<div id="outline-container-orga98ba2c" class="outline-6">
<h6 id="orga98ba2c">Il client continua a ricevere una risposta valida già pronta.</h6>
</div>
<div id="outline-container-org2193f4c" class="outline-6">
<h6 id="org2193f4c">Il local DNS, però, gestisce in modo iterativo.</h6>
<div class="outline-text-6" id="text-org2193f4c">
</div>
<div id="outline-container-orgb8200e7" class="outline-7">
<h7 id="orgb8200e7">Manda l'intero dominio al root, che conosce però solo l'IP di primo livello e risponde con un informazione parziale, ovvero con l'indirizzo del NS di primo livello.</h7>
</div>
<div id="outline-container-org6a7d73d" class="outline-7">
<h7 id="org6a7d73d">Una volta conosciuto quello di primo livello, si chiede al corrispondente NameServer di risolvere la parte rimanente del dominio.</h7>
<div class="outline-text-7" id="text-org6a7d73d">
</div>
<div id="outline-container-org9328b07" class="outline-8">
<h8 id="org9328b07">Questo risponde con l'indirizzo del DNS Server del secondo livello.</h8>
</div>
</div>
<div id="outline-container-org83f3c26" class="outline-7">
<h7 id="org83f3c26">Se il dominio era composto da tre livelli, il DNS server di secondo livello risponde con l'IP specifico</h7>
</div>
</div>
</div>
<div id="outline-container-org0f75bf7" class="outline-5">
<h5 id="org0f75bf7">Anche l'approccio iterativo richidede un overhead per il primo step, che viene attenuato dall'utilizzo della cache.</h5>
<div class="outline-text-5" id="text-org0f75bf7">
</div>
<div id="outline-container-orgdf551e4" class="outline-6">
<h6 id="orgdf551e4">In questo modo, la prossima volta che verrà richiesto un dominio di terzo livello appartenente allo stesso secondo livello, la richiesta verrà effettuata direttamente al Name Server di secondo livello.</h6>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgddb2ba4" class="outline-2">
<h2 id="orgddb2ba4">Ultima lezione</h2>
<div class="outline-text-2" id="text-orgddb2ba4">
<p>
Gli esercizi su livello 2 e calcolo di RTT sono fondamentali. Ce ne sono di solito 2.
Scrivere a rossi@di.unimi.it per problemi.
Le domande sono più o meno metà su livelli bassi e metà su quelli alti.
TCP è molto gettonato.
Non usare tante parole ma fare gli schemi.
Ad esempio, per la chiusura della comunicazione TCP, inserire i messaggi scambiati, compreso l'ACK e possibilmente mettere i timer a lato.
Bisogna essere specifici, ad esempio se viene chiesta la chiusura asimmetrica, non serve descrivere anche quella simmetrica.
Decidere che livello di dettaglio usare per la domanda.
Anche per una domanda sul distance vector e split horizon, sarebbe bene fare un esempio e descrivere bene che il problema è che non viene indicato il link che si usa per raggiungere una destinazione
Il prof non sa esattamente quali sono i valori di alfa e beta, comunque basta indicare quali sono stati usati vicino l'esercizio
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-01-28 Tue 20:16</p>
</div>
</body>
</html>
