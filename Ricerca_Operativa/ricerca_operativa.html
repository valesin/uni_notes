<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-05-30 Fri 07:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ricerca operativa</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Ricerca operativa</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5e209e2">Modello matematico</a></li>
<li><a href="#orgb22f14f">Programmazione lineare</a>
<ul>
<li><a href="#org8e75675"></a>
<ul>
<li><a href="#org9c55c93">Forma alle disuguaglianze</a></li>
</ul>
</li>
<li><a href="#org766d78f">Interpretazione geometrica</a>
<ul>
<li><a href="#org8e3694b">Caso bidimensionale</a></li>
<li><a href="#orga744cc6"><span class="todo TODO">TODO</span> Problemi inammissibili e illimitati</a></li>
</ul>
</li>
<li><a href="#orga9d0c03"><span class="todo TODO">TODO</span> Tipi di PL (intorno pag 51 italiano)</a>
<ul>
<li><a href="#orgbf1a270">Mix produttivo</a></li>
<li><a href="#org978925c">Allocazione di risorse</a></li>
<li><a href="#orgc3d2e62"><span class="todo TODO">TODO</span> Mix produttivo + allocazione di risorse</a></li>
</ul>
</li>
<li><a href="#org5760547">Assunzioni</a>
<ul>
<li><a href="#org3cdfa1a">Proporzionalità</a>
<ul>
<li><a href="#org7e513a7">Violazione per presenza di start-up cost</a></li>
<li><a href="#org6942f56">Violazione per variazione di rendimento marginale</a></li>
</ul>
</li>
<li><a href="#org9d5bba6">Additività</a></li>
<li><a href="#org0afce6a">Divisibilità</a></li>
</ul>
</li>
<li><a href="#org8c00562">Metodo del simplesso (pag 101 italiano)</a>
<ul>
<li><a href="#org9932b71">Concetti base</a></li>
<li><a href="#orgadd62ad">Proprietà su cui si basa il metodo del simplesso</a>
<ul>
<li><a href="#orgac877eb">Teorema fondamentale</a>
<ul>
<li><a href="#org8b9b50b">Trasformazione da problema continuo a discreto</a></li>
<li><a href="#org82b080a"><span class="todo TODO">TODO</span> Località (controllare vercellis)</a></li>
<li><a href="#orgc401958">Degenerazione</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge943b7d">Funzionamento</a>
<ul>
<li><a href="#org869f55e">Rappresentazione</a></li>
<li><a href="#org503dd3f">Pseudocodice</a></li>
<li><a href="#org7629784">Inizializzazione</a>
<ul>
<li><a href="#org138ff05">Metodo delle variabili artificiali (124 vercellis)</a></li>
<li><a href="#org31853da">Metodo "big M"</a></li>
<li><a href="#orgac95d4e">Metodo Balinsky-Gòmory</a></li>
</ul>
</li>
<li><a href="#orge19f8f9">Iterazione</a></li>
<li><a href="#orgc3371ab">Test di ottimalità</a></li>
</ul>
</li>
<li><a href="#org340ea54">Situazioni particolari</a>
<ul>
<li><a href="#org5bf005e"><span class="todo TODO">TODO</span> Soluzioni ottime multiple (89 hillier)</a></li>
<li><a href="#org52a7c08">Funzione obiettivo illimitata</a></li>
<li><a href="#orga129fd0"><span class="todo TODO">TODO</span> Degenerazione</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org60e541c">Anki idee</a>
<ul>
<li><a href="#org6fee2ed">Ricava x<sub>b</sub> in funzione di x<sub>d</sub></a></li>
<li><a href="#orgd9fff10">Ricava z in funzione di x<sub>d</sub></a></li>
<li><a href="#org12dc142">scrivi il modello standard tutto in funzione di x<sub>d</sub></a></li>
</ul>
</li>
<li><a href="#org1c97b49">Esercizi</a>
<ul>
<li><a href="#orgcea5225">ProvaModello</a></li>
<li><a href="#org5ed1240">Blending</a></li>
<li><a href="#org42b7982">Carpentry</a></li>
<li><a href="#org1bde576">RicOp-Radioterapia</a></li>
</ul>
</li>
<li><a href="#orgd830ac9">Domande per il prof</a>
<ul>
<li><a href="#orge73b309">Percorso di studio per espandere a partire da questo corso ed arrivare a concetti come Computational Social Science, Algorithmic Game Theory</a></li>
</ul>
</li>
<li><a href="#orgc128764">Puzzle logici</a></li>
<li><a href="#org53247a3">Esercizio bonus</a></li>
<li><a href="#org4e5a82a">Domande</a></li>
<li><a href="#org63d30ad">AI</a></li>
</ul>
</div>
</div>
<div id="outline-container-org5e209e2" class="outline-2">
<h2 id="org5e209e2">Modello matematico</h2>
<div class="outline-text-2" id="text-org5e209e2">
<p>
Le \(n\) <b>decisioni quantitative</b> da prendere sono espresse dalle <b>variabili</b> \((x_{1}, x_{2},...,x_{n})\).
</p>

<p>
Una <b>appropriata misura di performance</b> (es. profitto) è espressa in funzione delle variabili ed è chiamata <b>funzione obiettivo</b>.
</p>

<p>
Sulle variabili possono essere definiti dei <b>vincoli</b>, tipicamente in forma di <b>(dis)equazioni</b>.
</p>

<p>
I <b>parametri</b> del modello corrispondono ai <b>coefficienti delle variabili</b> e sono i <b>dati</b> del nostro modello. Spesso sono delle stime, quindi è utile comprendere il comportamento del modello in caso di variazioni dei dati (<b>sensitivity analysis</b>).
</p>
</div>
</div>
<div id="outline-container-orgb22f14f" class="outline-2">
<h2 id="orgb22f14f">Programmazione lineare</h2>
<div class="outline-text-2" id="text-orgb22f14f">
<p>
Il problema generale che la programmazione lineare risolve è l'allocazione di <b>risorse limitate</b> ad <b>attività concorrenti</b> in un modo <b>ottimo</b>.
</p>

<p>
Con riferimento al modello generale di <b>programmazione matematica</b>, un problema è di <b>programmazione lineare</b> quando:
</p>
<ul class="org-ul">
<li>le variabili hanno un <b>dominio continuo</b>;</li>
<li>i vincoli sono <b>(dis)equazioni lineari</b>;</li>
<li>la funzione obiettivo è una <b>funzione lineare delle variabili</b>.</li>
</ul>

<p>
Ogni problema così modellato viene chiamato <b>programma lineare</b> (<i>linear program</i>) o <b>LP</b>.
</p>
</div>
<div id="outline-container-org8e75675" class="outline-3">
<h3 id="org8e75675"><a id="org5323b6f"></a></h3>
<div class="outline-text-3" id="text-org8e75675">
<p>
Siano dati \(n\) attività che competono per l'utilizzo di \(m\) risorse
</p>

<p>
La <b>forma standard</b> di un problema di PL è
</p>

\begin{align*}
\max_{x} \quad & c^T x \\
& Ax = b \\
& x \geq 0
\end{align*}

<p>
Dove \(x={x_{1},x_2, x_{...},x_{n}}\) è il vettore delle <b>variabili di decisione</b>, ovvero delle attività da allocare, \(c={c_{1},c_2, c_{...},c_{n}}\) è il vettore dei <b>coefficienti della funzione obiettivo</b>, \(A\) è la <b>matrice dei coefficienti</b> di dimensione \(m\times n\) mentre \(b={b_{1},b_2, b_{...},b_{n}}\) è il <b>vettore delle costanti</b> associate ai vincoli.
</p>
</div>
<div id="outline-container-org9c55c93" class="outline-4">
<h4 id="org9c55c93">Forma alle disuguaglianze</h4>
<div class="outline-text-4" id="text-org9c55c93">
<p>
La <b>forma alle disuguaglianze</b> della programmazione lineare prevede che:
</p>
<ul class="org-ul">
<li>i vincoli siano tutte <b>disequazioni</b> in direzione <b>opposta</b> all'obiettivo.</li>
<li>tutte le variabili sono <b>non-negative</b>.</li>
</ul>

<p>
Per ottenerla basta trasformare ogni equazione in una doppia disequazione oppure eliminarla usando la sostituzione, e trasformare ogni variabile libera nella differenza fra due variabili non-negative.
</p>

<p>
Per ottenere la forma standard a partire dalla forma alle disuguaglianze, basta invece aggiungere delle variabili di <b>slack o surplus</b>, che sono sommate o sottratte a seconda che il vincolo sia rispettivamente di \(\leq\) o \(\geq\).
</p>
</div>
</div>
</div>
<div id="outline-container-org766d78f" class="outline-3">
<h3 id="org766d78f">Interpretazione geometrica</h3>
<div class="outline-text-3" id="text-org766d78f">
<p>
Ogni <b>soluzione</b> \(x\) è un assegnamento delle \(n\) variabili, quindi \(x\) è un <b>punto</b> in uno <b>spazio continuo</b> a \(n\) dimensioni.
</p>

<p>
Ogni <b>vincolo di uguaglianza</b> corrisponde ad un <b>iperspazio</b>, ovvero divide lo spazio in due semispazi; corrisponde ad una <b>retta</b> quando il piano è <b>bidimensionale</b>.
</p>

<p>
Ogni <b>vincolo di disuguaglianza</b> corrisponde ad un <b>semispazio</b>, ovvero una delle due parti in cui lo spazio è diviso da un iperspazio.
</p>

<p>
Quindi, il <b>sistema dei vincoli</b> corrisponde all'<b>intersezione</b> dei corrispondenti <b>semispazi</b>, che è un <b>poliedro</b>; in un piano <b>bidimensionale</b>, l'intersezione è un <b>poligono</b>.
</p>

<p>
Tali poliedri sono sempre <b>convessi</b>, ovvero il segmento che congiunge una qualsiasi coppia di punti è interamente contenuto nel poliedro.
</p>

<p>
La <b>funzione obiettivo</b> corrisponde ad un fascio di <b>iperpiani paralleli</b>.
</p>
</div>
<div id="outline-container-org8e3694b" class="outline-4">
<h4 id="org8e3694b">Caso bidimensionale</h4>
<div class="outline-text-4" id="text-org8e3694b">
<p>
I vincoli generano un <b>poligono</b> che corrisponde alla <b>regione di ammisibilità</b>. La funzione obiettivo corrisponde ad una *retta.
</p>

<p>
Si vuole trovare il punto che si trovi <b>all'interno della regione</b> e <b>lungo la retta</b> della funzione obiettivo.
</p>

<p>
Il fatto che si trovi all'interno della regione significa che la soluzione è <b>ammissibile</b>, mentre il fatto che si trovi lungo la retta implica che la funzione sia <b>ottima</b>.
</p>
</div>
</div>
<div id="outline-container-orga744cc6" class="outline-4">
<h4 id="orga744cc6"><span class="todo TODO">TODO</span> Problemi inammissibili e illimitati</h4>
</div>
</div>
<div id="outline-container-orga9d0c03" class="outline-3">
<h3 id="orga9d0c03"><span class="todo TODO">TODO</span> Tipi di PL (intorno pag 51 italiano)</h3>
<div class="outline-text-3" id="text-orga9d0c03">
</div>
<div id="outline-container-orgbf1a270" class="outline-4">
<h4 id="orgbf1a270">Mix produttivo</h4>
</div>
<div id="outline-container-org978925c" class="outline-4">
<h4 id="org978925c">Allocazione di risorse</h4>
<div class="outline-text-4" id="text-org978925c">
<p>
Il problema di PL più frequente.
Richiede di allocare risorse limitate fra attività concorrenti
</p>
</div>
</div>
<div id="outline-container-orgc3d2e62" class="outline-4">
<h4 id="orgc3d2e62"><span class="todo TODO">TODO</span> Mix produttivo + allocazione di risorse</h4>
</div>
</div>
<div id="outline-container-org5760547" class="outline-3">
<h3 id="org5760547">Assunzioni</h3>
<div class="outline-text-3" id="text-org5760547">
</div>
<div id="outline-container-org3cdfa1a" class="outline-4">
<h4 id="org3cdfa1a">Proporzionalità</h4>
<div class="outline-text-4" id="text-org3cdfa1a">
</div>
<div id="outline-container-org7e513a7" class="outline-5">
<h5 id="org7e513a7">Violazione per presenza di start-up cost</h5>
<div class="outline-text-5" id="text-org7e513a7">
<p>
Ogni variabile deve contribuire in modo proporzionale al suo utilizzo.
</p>

<p>
Nel caso in cui esista uno costo di inizializzazione associato ad una variabile, la retta si interseca con le ordinate più giù dello 0.
</p>

<p>
Sebbene rimanga una retta, dato che un contributo negativo non è ammesso, si avrebbe un contributo <b>nullo</b> quando non è utilizzata, un contributo \(x\) quando è utilizzata una volta e un contributo \(y>x\) ad ogni step successivo e il principio di proporzionalità sarebbe violato.
</p>

<p>
Questa violazione è risolta applicando tecniche di <i>mixed pl</i>.
</p>
</div>
</div>
<div id="outline-container-org6942f56" class="outline-5">
<h5 id="org6942f56">Violazione per variazione di rendimento marginale</h5>
<div class="outline-text-5" id="text-org6942f56">
<p>
Quando il rendimento totale diminuisce all'aumentare delle risorse impiegate (ovvero delle variabili di decisione), allora la funzione obiettivo non è lineare.
</p>

<p>
I casi di rendimenti marginali crescenti sono quelli in cui ad esempio l'economia di scala permette di attuare delle ottimizzazioni.
</p>

<p>
Quelli decrescenti sono ad esempio i casi in cui il costo per il marketing necessario per vendere i prodotti aggiuntivi cresca più che linearmente.
</p>
</div>
</div>
</div>
<div id="outline-container-org9d5bba6" class="outline-4">
<h4 id="org9d5bba6">Additività</h4>
<div class="outline-text-4" id="text-org9d5bba6">
<p>
Non è possibile che l'impatto delle variabili sulla funzione obiettivo o sui vincoli sia uguale al prodotto di più variabili.
</p>

<p>
Il vincolo è violato nel caso in cui lo switch da un'attività all'altra richieda dei costi e quindi ogni switch comporterebbe una perdita di tempo lineare al prodotto incrociato. Allo stesso modo, se lo switch permette di utilizzare più efficientemente le risorse disponibili, allora si ha un addendo negativo all'impatto della produzione delle due variabili sui vincoli.
</p>
</div>
</div>
<div id="outline-container-org0afce6a" class="outline-4">
<h4 id="org0afce6a">Divisibilità</h4>
<div class="outline-text-4" id="text-org0afce6a">
<p>
Se le attività non possono essere arbitrariamente divise durante la produzione, ovvero le variabili non hanno dominio almeno sui razionali, allora si ha un problema di programmazione intera.
</p>
</div>
</div>
</div>
<div id="outline-container-org8c00562" class="outline-3">
<h3 id="org8c00562">Metodo del simplesso (pag 101 italiano)</h3>
<div class="outline-text-3" id="text-org8c00562">
<p>
I programmi lineari possono essere risolti mediante il <b>metodo (o algoritmo) del simplesso</b>.
</p>
</div>
<div id="outline-container-org9932b71" class="outline-4">
<h4 id="org9932b71">Concetti base</h4>
<div class="outline-text-4" id="text-org9932b71">
<p>
Si consideri il politopo convesso ad \(n\) dimensioni generato dai vincoli funzionali e quelli di non negatività. Ogni dimensione di queste \(n\) corrisponde ad una delle variabili di decisione.
</p>

<p>
La soluzione del problema di PL si trova su uno dei vertici di questo politopo. (a causa di un'intuizione che per ora ignoriamo)
</p>

<p>
I vertici, che sono punti sullo spazio ad \(n\) dimensioni, si ottengono mediante l'intersezione delle linee di almeno \(n\) vincoli (di più se esistono più di \(n\) vertici che si intersecano in un certo punto), ovvero mediante la soluzione del sistema che contiene tali linee.
</p>

<p>
Il metodo del simplesso di basa su 3 concetti:
</p>
<dl class="org-dl">
<dt>teorema fondamentale della programmazione lineare</dt><dd>Dato un problema in forma di standard \(z=\min\{ c^tx:Ax = b, x \geq 0 \}\), con \(\text{rank}(A)=m\), allora ogni soluzione ammissibile o ottima è una soluzione di base, ovvero si trova su un vertice.
Se ne esistono di più, allora almeno due soluzioni ottime sono vertici adiacenti.
Se non esistono soluzioni di base, allora il politopo è illimitato.
In questo modo si trasforma un problema continuo in uno concreto.</dd>
<dt>il numero di vertici ammissibili è finito</dt><dd>questo permette di trasformare il problema continuo in un problema di ottimizzazione combinatoria</dd>
<dt>se un vertice ammissibile non ha vertici adiacenti migliori, non ci sono vertici migliori in generale</dt><dd>questo permette di implementare una semplice condizione di arresto</dd>
</dl>
</div>
</div>
<div id="outline-container-orgadd62ad" class="outline-4">
<h4 id="orgadd62ad">Proprietà su cui si basa il metodo del simplesso</h4>
<div class="outline-text-4" id="text-orgadd62ad">
</div>
<div id="outline-container-orgac877eb" class="outline-5">
<h5 id="orgac877eb">Teorema fondamentale</h5>
<div class="outline-text-5" id="text-orgac877eb">
<p>
Ogni soluzione <b>ammissibile</b> si trova su un <b>vertice</b> e quindi è una soluzione di <b>base</b>, ovvero in cui \(n\) variabili sono state messe a \(0\) e le rispettive colonne sono state cancellate.
</p>

<p>
Allora se esiste una sola soluzione ottima, si troverà su un vertice, se ne esistono di più, si troveranno su vertici adiacenti, ovvero agli estremi dello stesso spigolo.
</p>
</div>
<div id="outline-container-org8b9b50b" class="outline-6">
<h6 id="org8b9b50b">Trasformazione da problema continuo a discreto</h6>
<div class="outline-text-6" id="text-org8b9b50b">
<p>
Dato che il numero di vertici ammissibili è finito, il problema diventa un problema di enumerazione.
</p>

<p>
Dato che delle \(n+m\) colonne ne vengono scelte soltanto le \(m\) indipendenti, il numero di combinazioni differenti è \(\binom{m+n}{n} = \frac{(m+n)!}{m! \cdot n!}\).
</p>
</div>
</div>
<div id="outline-container-org82b080a" class="outline-6">
<h6 id="org82b080a"><span class="todo TODO">TODO</span> Località (controllare vercellis)</h6>
<div class="outline-text-6" id="text-org82b080a">
<p>
Se un vertice non ha vertici adiacenti migliori in termini della funzione obiettivo, allora non ci sono vertici migliori in generale.
</p>

<p>
Il problema di trovare l'ottimalità globale si trasforma nel trovare l'ottimalità locale di una soluzione. In questo modo si possono effettuare iterazioni ripetute fino ad arrivare alla soluzione finale.
</p>
</div>
</div>
<div id="outline-container-orgc401958" class="outline-6">
<h6 id="orgc401958">Degenerazione</h6>
<div class="outline-text-6" id="text-orgc401958">
<p>
Quando una delle variabili <b>non</b> in base risulta uguale a 0, si ha degenerazione, ovvero più di \(n\) vincoli coincidono in quel punto
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge943b7d" class="outline-4">
<h4 id="orge943b7d">Funzionamento</h4>
<div class="outline-text-4" id="text-orge943b7d">
<p>
Dato che il sistema ha \(m+n\) variabili e \(m\) equazioni (non ho idea della rappresentazione grafica di ciò. cosa significa questo spazio ad \(m\) dimensioni?), ci sono \(n\) gradi di libertà.
Il sistema è risolvibile eliminando gli \(m-n\) gradi di libertà, ottenendo un sistema quadrato di lato \(m\). Per eliminare i gradi di libertà, si mettono \(m-n\) variabili a \(0\) (<i>fuori base</i>) e si risolve il sistema nelle altre variabili (<i>in base</i>). Il punto così identificato è in uno spazio a \(m\) dimensioni e proiettato sul politopo di \(n\) dimensioni identifica esattamente il vertice di intersezione delle due rette associate alle variabili fuori base. (perchè esattamente? per esempio funziona così anche per le intersezioni normali. pensa ad esempio a due linee sul piano cartesiano: la loro intersezione si ottiene non mettendo x o y a zero, che infatti devono variare, ma risolvendo il sistema. oppure, per trovare l'intersezione con l'asse delle x, si imposta y a 0).
</p>

<p>
Il prof dice che la forma canonica è di minimizzazione, ma sul libro non ce n'è traccia.
</p>

<p>
Dalla forma standard
</p>

\begin{aligned}
& \text{max} \quad z = \mathbf{c}^T \mathbf{x} \\
& \text{subject to} \quad A\mathbf{x} = \mathbf{b} \\
& \quad \quad \quad \quad \mathbf{x} \geq \mathbf{0}
\end{aligned}

<p>
scomponiamo ogni matrice e vettore nella parte in base e in quella fuori base.
</p>

<p>
Selezionata una base \(B\) (insieme di colonne linearmente indipendenti di \(A\)) e riorganizzate le colonne, possiamo partizionare:
\[
A = [B \mid N], \quad \mathbf{x} = \begin{bmatrix} \mathbf{x}_B \\ \mathbf{x}_N \end{bmatrix}, \quad \mathbf{c} = \begin{bmatrix} \mathbf{c}_B \\ \mathbf{c}_N \end{bmatrix}
\]
</p>

<p>
Dove \(N\) indica le colonne fuori base.
</p>

<p>
Il sistema diventa:
\[
B\mathbf{x}_B + N\mathbf{x}_N = \mathbf{b}
\]
</p>

<p>
Allora possiamo ricavare \(\mathbf{x}_B\) in funzione di \(\mathbf{x}_N\).
</p>

<p>
Moltiplicando entrambi i membri per \(B^{-1}\):
\[ I\mathbf{x}_B + B^{-1}N\mathbf{x}_N = B^{-1}\mathbf{b} \]
</p>

<p>
E poi isolando \(\mathbf{x}_B\) otteniamo
</p>

<p>
\[\mathbf{x}_B = B^{-1}\mathbf{b} - B^{-1}N\mathbf{x}_N\]
</p>

<p>
A questo punto possiamo sostituire \(\mathbf{x}_B\) in \(z\) per ottenere la funzione obiettivo in funzione delle sole variabili non basiche \(\mathbf{x}_N\):
\[
z = \mathbf{c}_B^T (B^{-1}\mathbf{b} - B^{-1}N\mathbf{x}_N) + \mathbf{c}_N^T \mathbf{x}_N
\]
</p>

<p>
E semplifichiamo:
\[
z = \underbrace{\mathbf{c}_B^T B^{-1}\mathbf{b}}_{z_B} + \underbrace{(\mathbf{c}_N^T - \mathbf{c}_B^T B^{-1}N)}_{r_D} \mathbf{x}_N \quad
\]
</p>


<p>
A questo punto il problema assume la forma canonica:
</p>

\begin{aligned}
& \text{minimize} \quad z = z_B + r_D \mathbf{x}_N \\
& \text{subject to} \quad \mathbf{x}_B + B^{-1}N\mathbf{x}_N = B^{-1}\mathbf{b} \\
& \quad \quad \quad \quad \mathbf{x}_B, \mathbf{x}_N \geq \mathbf{0}
\end{aligned}

<p>
Notare che la funzione obiettivo è composta da due addendi:
</p>
<ul class="org-ul">
<li>\(z_B\), che non dipende da alcuna variabile ed è il valore della funzione obiettivo associato alla soluzione di base corrente.</li>
<li>\(r_D \mathbf{x}_N\), che rappresenta l'impatto delle variabili non di base sulla funzione obiettivo.</li>
</ul>

<p>
\(r_D\) è chiamato <b>vettore dei <a id="orgb831e0d">coefficienti di costo ridotto</a></b>. Misura il costo opportunità legato all'uso della risorsa associata, ovvero quanto costa (in positivo o in negativo) tale scelta di variabili rispetto ad un'altra scelta in cui la variabile fosse usata di più o di meno.
</p>

<p>
È composto dalla prima parte che indica il ricavo marginale di un aumento unitario della variabile e la seconda parte che indica la riduzione del ricavo mediante i costi ombra delle risorse utilizzate. Se aumentare la produzione comporta una spesa per le risorse maggiore al ricavo, allora il guadagno è negativo. Queste informazioni sono tutte incorporate nei costi ridotti. I costi ombra sono utili alla fine per l'analisi parametrica [todo]
</p>


<p>
È usato per effettuare il <b>test di ottimalità</b>. Infatti, se ogni sua componente è non-positiva, allora non c'è modo di incrementare una variabile fuori base per ottenere un aumento della funzione obiettivo.
</p>

<p>
Generalizzando il vettore dei <a href="#orgb831e0d">coefficienti di costo ridotto</a> per tutte le variabili, ovvero \[c^T - c_B^T B^{-1}A\], e considerando soltanto le sue componenti di base, si ottiene \[c_B^T - c_B^T B^{-1}B=0\], ovvero non è possibile ottenere un incremento della funzione obiettivo aumentando le variabili basiche che si trovano già al vertice. (?)
</p>

<p>
Quando \(\mathbf{x}_N = \mathbf{0}\), si ottiene la soluzione di base:
\[
\mathbf{x}_B = B^{-1}\mathbf{b}
\]
</p>

<p>
Questa soluzione è ammissibile se \(B^{-1}\mathbf{b} \geq \mathbf{0}\), altrimenti la forma canonica è detta <b>debole</b> e la soluzione non è ammissibile.
</p>
</div>
<div id="outline-container-org869f55e" class="outline-5">
<h5 id="org869f55e">Rappresentazione</h5>
<div class="outline-text-5" id="text-org869f55e">
<p>
Dalla forma canonica
</p>

\begin{aligned}
& \text{minimize} \quad z = z_B + r_D \mathbf{x}_N \\
& \text{subject to} \quad \mathbf{x}_B + B^{-1}N\mathbf{x}_N = B^{-1}\mathbf{b} \\
& \quad \quad \quad \quad \mathbf{x}_B, \mathbf{x}_N \geq \mathbf{0}
\end{aligned}

<p>
si ottiene un <b>tableau</b>, strutturato in questo modo:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(-z_b\)</td>
<td class="org-left">\(r_D\)</td>
<td class="org-left">\(0\)</td>
</tr>

<tr>
<td class="org-left">\(B^{-1}b\)</td>
<td class="org-left">\(B^{-1}N\)</td>
<td class="org-left">\(I\)</td>
</tr>
</tbody>
</table>

<p>
La colonna sinistra rappresenta il valore attuale della funzione obiettivo e gli attuali limiti, tutte costanti.
</p>

<p>
La seconda e terza colonna indicano rispettivamente l'impatto delle variabili fuori base ed in base, sopra per la funzione obiettivo, sotto per i limiti dei vincoli.
</p>
</div>
</div>
<div id="outline-container-org503dd3f" class="outline-5">
<h5 id="org503dd3f">Pseudocodice</h5>
<div class="outline-text-5" id="text-org503dd3f">
<pre class="example" id="org2ed87c5">
while (¬Infeasible(b, c)) ∧ (¬FeasibleBase(b)) do
    Pivot(A, b, c)
if Infeasible(b, c) then
    Stop: problema inammissibile
else
    while (¬Optimal(c)) ∧ (¬Unbounded(A, c)) do
        Pivot(A, b, c)
    if Optimal(c) then
        Stop: soluzione ottima
    else
        Stop: problema illimitato
</pre>
</div>
</div>
<div id="outline-container-org7629784" class="outline-5">
<h5 id="org7629784">Inizializzazione</h5>
<div class="outline-text-5" id="text-org7629784">
<p>
L'algoritmo del simplesso mantiene l'ammissibilità e cerca l'ottimalità.
</p>

<p>
Di solito, il vertice corrispondente all'origine delle variabili di decisione è una soluzione ammissibile, in quanto esse sono fuori base e le variabili di slack associate ad ogni vincolo sono tutte in base e unitarie.
</p>

<p>
Non è detto che questo sia possibile (forse quando lo slack ha un costo che già all'inizio fa superare i vincoli?)
</p>

<p>
Quando la soluzione iniziale non è ammissibile, vanno applicate delle tecniche per trovare un vertice ammissibile da cui partire.
</p>

<p>
Vediamo 3 metodi per farlo.
</p>
</div>
<div id="outline-container-org138ff05" class="outline-6">
<h6 id="org138ff05">Metodo delle variabili artificiali (124 vercellis)</h6>
<div class="outline-text-6" id="text-org138ff05">
<p>
Questo metodo si basa sull'idea di generare un <b>problema ausiliario</b> con un vertice fittizio  ammissibile, introducendo delle variabili artificiali unitarie ad ogni vincolo, effettivamente generando una matrice identità, che rappresenta necessariamente una soluzione con assegnamento delle variabili fittizie uguale ai termini noti.
</p>

<p>
Dato che l'ammissibilità non c'entra nulla con l'ottimalità, possiamo ignorare la funzione obiettivo originale.
</p>

<p>
Invece, la nuova funzione obiettivo diventa quella di minimizzare le variabili fittizie. Se alla fine dell'algoritmo, tale funzione obiettivo fittizia è 0, allora posso tranquillamente eliminare le variabili fittizie, tornare al problema originale e risolvere per la vera funzione obiettivo, partendo dall'assegnamento delle variabili trovato che è ovviamente corretto, dato che rispetta i vincoli senza contributi negativi dalle variabili fittizie.
</p>

<p>
Lo <b>svantaggio</b> di questa tecnica è che richiede di lavorare su un tableau molto più grande ed effettuare molti più step.
</p>

<p>
Per ovviare a questo problema, ragioniamo in questo modo: quando il problema è in forma alle disuguaglianze, impostiamo l'ordine dei vincoli in modo che il termine noto \(b\) sia sempre maggiore uguale di 0. L'importanza di ciò è che in questo modo, ammesso che io trovi una base di partenza valida con coefficienti unitari, la soluzione in quel punto è ammissibile, perchè la soluzione sarà uguale alle variabili di partenza con valore uguale ai termini noti.
</p>

<p>
Possiamo poi dividere i vincoli in:
</p>
<dl class="org-dl">
<dt>\(leq\)</dt><dd>le variabili sono di slack e hanno quindi un impatto positivo, quindi un coefficiente \(1\) e quindi non hanno bisogno di variabili aggiuntive perchè rispettano già la forma canonica e possono formare la matrice identità</dd>
<dt>\(geq\)</dt><dd>le variabili aggiunte sono di surplus, e quindi hanno fattore \(-1\). Allora scelgo fra tutti i vincoli di questo gruppo quello con \(b\) massimo e trasformo tutti gli altri vincoli moltiplicandoli per \(-1\) e sommandoli a questo scelto (o ugualmente trasformandoli nella sottrazione fra quello scelto ed essi).
A questo punto, ognuno di essi avrà la variabile con fattore positivo (perchè ne inverto il segno ma non sommo o sottraggo nulla dato che il vincolo scelto non ha quella variabile).
Soltanto il vincolo scelto avrà bisogno di una variabile fittizia.</dd>
<dt>\(=\)</dt><dd>questi hanno sempre bisogno di una variabile fittizia</dd>
</dl>
</div>
</div>
<div id="outline-container-org31853da" class="outline-6">
<h6 id="org31853da">Metodo "big M"</h6>
<div class="outline-text-6" id="text-org31853da">
<p>
Introduco le variabili artificiali nei vincoli come prima, ma al posto di introdurre le variabili artificiali con coefficiente \(1\) nella funzione obiettivo e poi minimizzarla, lascio le variabili originali nella funzione obiettivo ma ci in più sommo quelle artificiali con un coefficiente molto alto. In questo modo è difficile che la soluzione ottima le contenga in base, ovvero con un valore maggiore di \(0\), perchè è molto probabile che qualunque soluzione in cui una sola di esse sia maggiore di \(0\) sia peggiore di quella ottima.
</p>

<p>
Si evita il passo di inizializzazione, ma è difficile determinare il valore corretto di \(M\) (infatti una variabile artificiale potrebbe far parte della soluzione con un valore molto piccolo) e inoltre provoca instabilità numerica (i solutori usano la consistenza dei valori come "sanity check")
</p>
</div>
</div>
<div id="outline-container-orgac95d4e" class="outline-6">
<h6 id="orgac95d4e">Metodo Balinsky-Gòmory</h6>
<div class="outline-text-6" id="text-orgac95d4e">
<p>
Questo caso è complementare ai precedenti. Infatti, i precedenti garantiva l'ammissibilità durante tutto il processo ammettendo soltanto termini noti positivi, creando poi una soluzione di base artificiale ma ammissibile, eliminando poi le variabili artificiali in modi diversi (portandole a 0 o penalizzandole). Introdurre variabili artificiali era necessario perchè se un problema contiene un vincolo di maggiore uguale con la massimizzazione, la variabile associata a quel vincolo dovrà avere peso negativo e quindi non può essere usata all'inizio con un valore di non negativo perchè sarebbe \(-x=b\) e quindi porterebbe ad una soluzione iniziale non ammissibile. Insomma, il metodo precedente mantiene l'ammissibilità e manipola le variabili.
</p>

<p>
Questo metodo, invece, lascia le variabili come sono, ma inizia da uno stato inammissibile, per poi cercare l'ammissibilità. La funzione obiettivo viene sostituita con il vincolo responsabile dell'inammissibilità. La funzione obiettivo originale è inizialmente ignorata ma continua a far parte del tableau perchè va trasformata insieme al resto.
</p>

<p>
A questo punto si continua applica il simplesso minimizzando il termine noto del vincolo scelto, ovvero portandolo verso \(0\).
</p>

<p>
Se il simplesso termina, ovvero i costi ridotti sono tutti non-negativi, ma il termine noto è ancora negativo, allora il problema è inammissibile.
</p>

<p>
Se il simplesso arriva al punto in cui di solito il problema si definisce illimitato, ovvero una colonna contiene tutti valori negativi ma positivo nella funzione obiettivo, allora non è detto che il problema originale sia illimitato. In realtà, mi basta fare pivot proprio su quella colonna, con il risultato di invertire il termine noto, che diventerà positivo.
</p>

<p>
Nel frattempo, la funzione obiettivo sarà peggiorata di molto perchè non stavamo ottimizzando per quella.
</p>
</div>
</div>
</div>
<div id="outline-container-orge19f8f9" class="outline-5">
<h5 id="orge19f8f9">Iterazione</h5>
<div class="outline-text-5" id="text-orge19f8f9">
<p>
L'obiettivo è spostarsi lungo lo spigolo che conduce al vertice con il maggiore tasso di miglioramento di \(f\).
</p>

<p>
Per capirlo, basta guardare i <a href="#orgb831e0d">coefficienti di costo ridotto</a> e aumentare la variabile associata al coefficiente maggiore, che sarà quindi <i>entrante</i>.
</p>

<p>
Aumentando la variabile entrante, bisogna modificare le altre variabili per rispettare i vincoli funzionali e/o quelli di non-negatività. (Dico e/o perchè le due cose si equivalgono: aumentando troppo, per rispettare il vincolo funzionale dovrò rendere qualche variabile negativa).
</p>

<p>
Avevamo già ricavato le variabili di base in funzione di quelle fuori base e quindi la condizione da rispettare è che queste non diventino negative, ovvero:
</p>

<p>
\[\mathbf{x}_B = B^{-1}\mathbf{b} - B^{-1}N\mathbf{x}_N \geq 0\]
</p>

<p>
Ad ogni iterazione (per motivi legati al passo di riduzione in forma canonica), si avrà sempre che massimo \(n-1\) delle variabili fuori base saranno fissate a \(0\) ed oltre esse <b>una sola</b> variabile in base. Questa variabile in base identifica lo spigolo su cui ci si muoverebbe e sarebbe l'unica ad essere influenzata se la scegliessimo come base uscente.
</p>

<p>
Dato che l'obiettivo è quello di massimizzare la funzione obiettivo, ma rispettando i vincoli funzionali, scegliamo di muoverci lungo lo spigolo che ci permette di aumentare quanto più possibile la variabile entrante senza rendere l'equazione precedente falsa.
</p>

<p>
Per identificare sia lo spigolo che la quantità di cui aumentarla, si usa il <b>test del minimo rapporto</b>, ovvero si sceglie l'equazione per cui \(r = b_i / x_{i}\) è massimo (\(b_i\) indica il parametro del vincolo e \(x_i\) l'unica variabile in base presente nel vincolo) e \(r\) sarà il nuovo valore della variabile entrante che "satura" il vincolo.
</p>

<p>
Il passo di pivot del professore non è altro che un modo meccanico per fare questo ragionamento: data una colonna \(j\) scelta con un certo criterio (es. minimo valore di \(r_D\)), scegliere di "fare pivot" su una riga \(i\) tale per cui \(A_{ij}\) sia positivo e con rapporto con \(b_i\) minimo, vuol dire semplicemente scegliere di muoversi lungo il vincolo che permette di muoversi quanto più lontano senza uscire dal politopo. Se scegliessi una riga con \(A_{ij}\) non positivo, sarebbe come scegliere un vincolo a cui la variabile entrante o non partecipa (caso nullo) o ha un contributo negativo e quindi sarebbe illimitata. Inoltre, facendo pivot con coefficiente negativo, si renderebbe il termine noto negativo, perdendo l'ammissibilità.
</p>

<p>
Da questo consegue anche il caso di illimitatezza: se una variabile ha contributo positivo per la funzione obiettivo, ma tutti contributi negativi per i vincoli, allora posso aumentarla indiscriminatamente, aumentando il guadagno senza mai intaccare i vincoli funzionali. Quindi il problema è illimitato.
</p>
</div>
</div>
<div id="outline-container-orgc3371ab" class="outline-5">
<h5 id="orgc3371ab">Test di ottimalità</h5>
<div class="outline-text-5" id="text-orgc3371ab">
<p>
Nel momento della scelta dello spigolo lungo cui muoversi, si sceglie quello associato alla variabile con massimo tasso di miglioramento in \(f\), ovvero quello della variabile associata al minimo (dato che stiamo massimizzando) fra i valori di \(r_D\).
</p>

<p>
I tassi di miglioramento sono rappresentati dai <a href="#orgb831e0d">coefficienti di costo ridotto</a>.
</p>

<p>
Quando questo vettore non contiene alcuna componente negativa, il vertice è quello ottimo locale, ovvero rispetto ai vertici ad esso adiacenti.
</p>

<p>
Valgono delle proprietà in base alle quali l'ottimalità locale implica quella globale.
</p>

<p>
Quindi, la condizione di ottimalità è semplicemente
\[r_D > 0\]
</p>

<p>
Se la soluzione di base corrente non è degenere, allora la non negatività di \(r_D\) è necessaria e sufficiente per l'ottimalità globale, mentre se è degenere allora non è necessaria: infatti potrebbero degli elementi positivi anche per la soluzione ottima.
</p>
</div>
</div>
</div>
<div id="outline-container-org340ea54" class="outline-4">
<h4 id="org340ea54">Situazioni particolari</h4>
<div class="outline-text-4" id="text-org340ea54">
</div>
<div id="outline-container-org5bf005e" class="outline-5">
<h5 id="org5bf005e"><span class="todo TODO">TODO</span> Soluzioni ottime multiple (89 hillier)</h5>
</div>
<div id="outline-container-org52a7c08" class="outline-5">
<h5 id="org52a7c08">Funzione obiettivo illimitata</h5>
<div class="outline-text-5" id="text-org52a7c08">
<p>
Vedi fine sezione iterazione
</p>
</div>
</div>
<div id="outline-container-orga129fd0" class="outline-5">
<h5 id="orga129fd0"><span class="todo TODO">TODO</span> Degenerazione</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org60e541c" class="outline-2">
<h2 id="org60e541c">Anki idee</h2>
<div class="outline-text-2" id="text-org60e541c">
</div>
<div id="outline-container-org6fee2ed" class="outline-3">
<h3 id="org6fee2ed">Ricava x<sub>b</sub> in funzione di x<sub>d</sub></h3>
</div>
<div id="outline-container-orgd9fff10" class="outline-3">
<h3 id="orgd9fff10">Ricava z in funzione di x<sub>d</sub></h3>
</div>
<div id="outline-container-org12dc142" class="outline-3">
<h3 id="org12dc142">scrivi il modello standard tutto in funzione di x<sub>d</sub></h3>
</div>
</div>
<div id="outline-container-org1c97b49" class="outline-2">
<h2 id="org1c97b49">Esercizi</h2>
<div class="outline-text-2" id="text-org1c97b49">
</div>
<div id="outline-container-orgcea5225" class="outline-3">
<h3 id="orgcea5225"><a href="provamodello.html#ID-364d6722-c4a9-49b4-ba07-eea2bdd63dd6">ProvaModello</a></h3>
</div>
<div id="outline-container-org5ed1240" class="outline-3">
<h3 id="org5ed1240"><a href="blending.html#ID-cbef2798-6596-4a6f-b309-67cc45d6ac14">Blending</a></h3>
</div>
<div id="outline-container-org42b7982" class="outline-3">
<h3 id="org42b7982"><a href="carpentry.html#ID-1b081e61-03de-4734-874d-709f0da9dcb3">Carpentry</a></h3>
</div>
<div id="outline-container-org1bde576" class="outline-3">
<h3 id="org1bde576"><a href="ricop_radioterapia.html#ID-40f7984f-9e03-433d-b969-7a7fd05b593b">RicOp-Radioterapia</a></h3>
</div>
</div>
<div id="outline-container-orgd830ac9" class="outline-2">
<h2 id="orgd830ac9">Domande per il prof</h2>
<div class="outline-text-2" id="text-orgd830ac9">
</div>
<div id="outline-container-orge73b309" class="outline-3">
<h3 id="orge73b309">Percorso di studio per espandere a partire da questo corso ed arrivare a concetti come Computational Social Science, Algorithmic Game Theory</h3>
</div>
</div>
<div id="outline-container-orgc128764" class="outline-2">
<h2 id="orgc128764">Puzzle logici</h2>
<div class="outline-text-2" id="text-orgc128764">
<pre class="example" id="org88494c0">
# Tackling Self-Referential Logic Puzzles in Operations Research

Before diving into techniques for solving your self-referential logic puzzle, it's worth noting that this type of problem presents a fascinating intersection between mathematical logic, constraint programming, and operations research. These puzzles often require systematic approaches rather than trial and error.

## Understanding the Puzzle Structure

Your puzzle belongs to a class of self-referential logic puzzles where statements make claims about the truth values of other statements. This creates a complex web of interdependencies that can be formalized mathematically[1][7].

The key characteristics of your puzzle include:
- Each statement can be either true or false
- Statements refer to the truth values of other statements
- There is an unknown value N that needs to be determined
- The solution must satisfy all logical constraints simultaneously

## Mathematical Modeling Approaches

### Constraint Satisfaction Problem (CSP) Formulation

One powerful approach is to model this as a constraint satisfaction problem:

1. **Define Variables**: For each sentence i, create a binary variable S_i where:
   - S_i = 1 if statement i is true
   - S_i = 0 if statement i is false
   
2. **Translate Statements to Constraints**: Each statement can be converted into mathematical constraints[7][17].

For example, statement 3 ("There are three consecutive false sentences") could be expressed as:
```
∃i such that (1-S_i)*(1-S_{i+1})*(1-S_{i+2}) = 1
```

### Integer Linear Programming (ILP) Approach

You can reformulate this problem as an integer programming model:

1. **Define Binary Variables**: Same as in the CSP approach
   
2. **Express Logical Relations**: Convert logical statements into linear constraints[5]

For instance, the constraint "at least one of the two last sentences is true" can be expressed as:
```
S_9 + S_10 ≥ 1
```

3. **Solve Using ILP Solver**: Once all constraints are formulated, the problem can be solved using standard ILP solvers[4][5].

## Practical Techniques

### Matrix-Based Approach

For certain logic puzzles, researchers have found that using a matrix representation can help track logical implications:

1. Create a grid where rows and columns represent possible values
2. Mark cells as true, false, or unknown
3. Use elimination and logical inference to reduce possibilities[12]

This approach is commonly used in puzzles like the Einstein riddle (also known as the Zebra puzzle)[3][15].

### Inference Chains

Building inference chains is another powerful technique:
1. Start with the most restrictive statements
2. Derive implications
3. Use these to make deductions about other statements[2]

This approach is demonstrated in research on inference-based constraint satisfaction for explanation in logic puzzles[2].

## Programming Implementation Examples

### Prolog Implementation

Constraint Logic Programming is particularly well-suited to these types of puzzles:

```prolog
:- use_module(library(clpfd)).

solve(N, TrueStatements) :-
    % Create variables for each statement
    length(Statements, 10),
    Statements ins 0..1,
    
    % Implement constraints for each statement
    % ...
    
    % Find solution
    label(Statements).
```

Bennycheung's blog provides excellent examples of implementing constraint logic programming for puzzles[10].

### Integer Programming Example

The Sudoku example provides a template for formulating logic puzzles as integer programs:

```
min 0
s.t.
  constraints representing logical relations
  binary variables for truth values
```

This approach has been successfully used for a variety of puzzles[5][16].

## References for Further Study

1. **Academic Papers**:
   - "Mathematical Definition and Systematization of Puzzle Rules" discusses formal frameworks for puzzle rules[1]
   - "Inference-Based Constraint Satisfaction Supports Explanation" shows how inference can be used for logic puzzles[2]

2. **Books and Tutorials**:
   - "Solving Puzzles using Constraint Logic Programming in Prolog" provides practical examples[10]
   - "Operations Research, Sudoko, Rogo, and Puzzles" explores the connection between OR and puzzles[16]

3. **Online Resources**:
   - OR Stack Exchange has discussions on solving logic puzzles through optimization[17]
   - Tutorials on modeling logic puzzles as constraint satisfaction problems[12]

## Suggested Approach for Your Puzzle

1. Formalize each statement mathematically
2. Set up a system of constraints based on these statements
3. Consider the special constraints related to N
4. Use either CSP or ILP techniques to solve the system
5. Verify your solution by checking each original statement

Remember that systematic logical reasoning combined with mathematical formalization is more effective than trial and error for complex puzzles like yours.

Good luck with your puzzle!

Citations:
[1] https://arxiv.org/abs/2501.01433
[2] https://aaai.org/Papers/AAAI/1996/AAAI96-048.pdf
[3] https://blog.adamfurmanek.pl/2016/02/20/ilp-part-27/index.html
[4] https://www.semanticscholar.org/paper/ccd7e210b4c3324c8143a1204353180568832436
[5] https://langvillea.people.charleston.edu/Sudoku/sudoku2.pdf
[6] https://www.semanticscholar.org/paper/ff5ed12d085bac8d8874ff1fc966ea33e72808e4
[7] https://en.wikipedia.org/wiki/Constraint_satisfaction_problem
[8] https://www.semanticscholar.org/paper/e00603a3579ce4fe50d058c8033173ec1266ac09
[9] https://arxiv.org/abs/2502.20238
[10] https://bennycheung.github.io/solving-puzzles-using-clp
[11] https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10081044/
[12] https://mpopov.com/tutorials/logic-puzzle-ompr/
[13] https://www.semanticscholar.org/paper/1cc5d7fd98d0a93a90248e6bf6086e8fc3afacb2
[14] https://fileadmin.cs.lth.se/ai/Proceedings/aaai07/22/AAAI07-361.pdf
[15] https://arxiv.org/abs/2407.03956
[16] https://mat.tepper.cmu.edu/blog/index.php/2010/12/07/operations-research-sudoko-rogo-and-puzzles/
[17] https://or.stackexchange.com/questions/7496/solving-logic-puzzles-through-optimization
[18] https://pubsonline.informs.org/doi/pdf/10.1287/ited.7.2.160
[19] https://engineering.lehigh.edu/news/article/larry-snyder-publishes-book-puzzles
[20] https://giorgionardone.com/en/strategic-logic-and-problem-solving/
[21] https://www.semanticscholar.org/paper/dc5daabc50ed241e371da65e7396b0b6dff95bbf
[22] https://www.semanticscholar.org/paper/e2ac050c92a81368891fb67b8adfe641935271c2
[23] https://www.semanticscholar.org/paper/41669bc5abd53c24d88ea682f1e240638db2669c
[24] https://pubmed.ncbi.nlm.nih.gov/36006535/
[25] https://de.mathworks.com/help/optim/ug/solve-sudoku-puzzles-via-integer-programming-solver-based.html
[26] https://rbcborealis.com/research-blogs/tutorial-10-sat-solvers-ii-algorithms/
[27] https://www.mindlabpro.com/blogs/nootropics/einsteins-riddle
[28] https://blogs.sas.com/content/operations/2017/02/24/solving-kakuro-puzzles-with-sasor/
[29] https://fileadmin.cs.lth.se/ai/Proceedings/aaai07/22/AAAI07-361.pdf
[30] https://langvillea.people.charleston.edu/Sudoku/sudoku2.pdf
[31] https://cse.iitkgp.ac.in/~sourangshu/coursefiles/ComputingLab21A/Computing%20Lab%20-%201%20(2021)%20Tutorial%20on%20SAT%20Solvers.pdf
[32] https://en.wikipedia.org/wiki/Zebra_Puzzle
[33] https://arxiv.org/abs/1304.1628
[34] https://www.mathworks.com/help/optim/ug/sudoku-puzzles-problem-based.html
[35] https://avigad.github.io/lamr/using_sat_solvers.html
[36] https://artificialcognition.github.io/who-owns-the-zebra
[37] https://arxiv.org/abs/2006.06343
[38] https://or.stackexchange.com/questions/8228/common-problems-puzzles-that-can-creatively-be-solved-with-linear-programming
[39] https://www.semanticscholar.org/paper/0f92a7777d01c057ca8debd21c2abe9a555631b7
[40] https://www.semanticscholar.org/paper/cb9551ffe94024ec3a7d67373061048cf72ec4a4
[41] https://www.semanticscholar.org/paper/ab1feb1144e1ebea216c1209f756835a74352efc
[42] https://www.semanticscholar.org/paper/777baa5b67aabf166de297277599a10de135c7c2
[43] https://cs.uwaterloo.ca/~cbright/reports/sat-maple.pdf
[44] https://web.stanford.edu/~jduchi/projects/crossword_writeup.pdf
[45] https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=1df5f2be84521b8caeb820ea04eceb7fbb028bec
[46] https://www.scribd.com/document/210850347/Modelling-Logical-Puzzles-From-Raymond-Smullyan-Using-Integer-Programming
[47] http://lcs.ios.ac.cn/~caisw/Talks/CaiSATtutorial-Indian6.pdf
[48] https://dcyoung.github.io/images/constraint-satisfaction-problems/csp-wordpuzzles.pdf
[49] https://www.youtube.com/watch?v=84amHOgCEe8
[50] https://or.stackexchange.com/questions/7496/solving-logic-puzzles-through-optimization
[51] https://matheo.uliege.be/bitstream/2268.2/17699/5/TFE.pdf
[52] https://elearning.di.unipi.it/mod/resource/view.php?id=3383
[53] http://www.mat.unimi.it/users/djcollins/math340/Lecture33.pdf
[54] http://www.cs.unibo.it/~gabbri/MaterialeCorsi/CP@CS-final.pdf
[55] https://www.semanticscholar.org/paper/78dcaa5d34e6c68df8d19484c743470674ef4f80
[56] https://arxiv.org/abs/1806.04325
[57] https://www.semanticscholar.org/paper/711a265556ea430826c0045bbd546c81d6b7fe07
[58] https://www.semanticscholar.org/paper/ed1a1c698706f2fdfb2dc4f1b2965fef50a54068
[59] https://aixia.it/wp-content/uploads/2018/12/ConstraintProgramming-28-34.pdf
[60] https://ijcai-15.org/downloads/tutorials/T10-ConstraintLogicProgramming.pdf
[61] https://www.cs.ru.nl/bachelors-theses/2022/Laura_Kolijn___1025724___Generating_and_Solving_Skyscrapers_Puzzles_Using_a_SAT_Solver.pdf
[62] https://www.palermo.edu/ingenieria/Cica2009/Papers/64.pdf

---
Answer from Perplexity: pplx.ai/share
</pre>
</div>
</div>
<div id="outline-container-org53247a3" class="outline-2">
<h2 id="org53247a3">Esercizio bonus</h2>
<div class="outline-text-2" id="text-org53247a3">
<p>
Posso associare ad ogni affermazione \(i\) una variabile binaria \(x_i\) e scrivere ogni affermazione come una combinazione lineare di tali variabili.
</p>

<ol class="org-ol">
<li>Almeno una delle ultime due dichiarazioni è vera.
\[x_1 = 1 \rightarrow x_9 + x_{10} \geq 1\]
\[x_1 = 0 \rightarrow x_9 + x_{10} \leq 0\]
Voglio che il primo vincolo sia attivo solo quando \(x_1 = 1\), ovvero \(x_9 + x_{10} \geq x_1\).
Invece il secondo valga solo quando \(x_1 = 0\) e si disattivi altrimenti, ovvero \(x_9+x_{10} \leq 2 x_1\).
Logicamente falsa per la seconda.</li>
<li>Questa è o la prima dichiarazione vera, o la prima dichiarazione falsa.
Se la frase è vera, allora la prima è falsa.
Se la frase è falsa, allora vuol dire che <b>non</b> è nè la prima vera, nè la prima falsa. Il fatto che non sia la prima dichiarazione vera consegue dal fatto che non sia vera. Se non è la prima falsa, allora vuol dire che prima di essa ce n'è un'altra falsa. Quindi la prima è falsa. In ogni caso la prima è falsa.</li>
<li>Ci sono tre dichiarazioni false consecutive.
Siano \(y_i\) con \(i=1...8\) le variabili che indicano che la sequenza \(x_i, x_{i+1}, x_{i+2} \leq 0\), ovvero che una certa sequenza di tre dichiarazioni sia negativa.
Per fare in modo che \(y_i\) abbia questa specificazione serve che \(y_i \geq 1 - (x_{i+1}+x_{i+2}+x_{i+3})\).
Allora \(\sum_{i=1}^8 y_i \geq x_3\) impone che ciò accada almeno una volta se la dichiarazione è vera e si disattiva quando è falsa, mentre \(\sum_{i=1}^8 y_i \leq 8 x_3\) impone che ciò non accada se la dichiarazione è vera e si disattiva quando il vincolo è 1 (perchè la somma è sempre limitata da \(8\)).</li>
<li><p>
La differenza tra il numero d’ordine dell’ultima dichiarazione vera e il numero d’ordine della prima dichiarazione vera è un fattore di \(N\).
Se \(d\) è quella differenza, allora \(dk=N\) per un qualunque \(k\) intero.
Per trovare la differenza mi servono le affermazioni prima e ultima fra quelle vere.
Sia \(f_i = 1\) se la dichiarazione \(i\) è vera e \(0\) altrimenti.
Allora ogni \(f_i\) deve rispettare i seguenti vincoli:
</p>
<ul class="org-ul">
<li>\(f_i \leq x_i\), perchè non può essere vera se la rispettiva dichiarazione non lo è</li>
<li>\(\sum_{i=0}^10 f_i = 1\)</li>
<li>\(f_i \leq 1-f_j, \quad \forall j<i\)</li>
</ul>

<p>
Per l'ultima vale lo stesso ma in senso opposto.
</p>

<p>
Ho ottenuto la differenza ma non è possibile usare il modulo della divisione di \(N\), perchè sarebbe non lineare.
</p>

<p>
Allora creo delle variabili aggiuntive \(d_j\) che sono \(1\) quando \(\sum_{i=1}^{10} l_i i - \sum_{i=1}^{10} f_i i = i\)
</p>

<p>
Queste variabili devono sommare tutte insieme a \(1\), e il valore che selezionano dev'essere uguale alla differenza, ovvero \(\sum_{i=1}^{10} l_i i - \sum_{i=1}^{10} f_i i = \sum_{j=1}^{9} j d_j\)
</p>

<p>
A questo punto, per ogni valore di \(j\), introduco una variabile non-negativa e non vincolata \(k_j\) con il vincolo che se \(y_j = 1\), allora \(N=j\cdot k_j\), mentre se \(y_j = 0\), il vincolo di disattiva. Ovvero \(j\cdot k_j - M(1-y_j) \leq N \leq j\cdot k_j + M(1-y_j)\).
</p>

<p>
Infine, voglio che questo vincolo su \(N\) si attivi soltanto quando questa dichiarazione è vera, quindi ottengo \(j\cdot k_j - M(1-y_j) - M'(1-x_4) \leq N \leq j\cdot k_j + M(1-y_j)+ M'(1-x_4)\).
</p>

<p>
Potrei infine introdurre un vincolo che impedisca ad \(N\) di essere uguale ad un multiplo della distanza, ma data la bassa probabilità, evito e al massimo rieseguo il solutore escludendo manualmente quella soluzione.
</p></li>
<li>La somma dei numeri delle dichiarazioni vere è \(N\).</li>
<li>Questa non è l’ultima dichiarazione vera.
Allora o una delle successive è vera, o sono tutte false.
\(\sum_{i=7}^10 \geq x_6\) e \(\sum_{i=7}^10 \leq 4 x_6\).</li>
<li>Il numero d’ordine di ogni dichiarazione vera è un fattore di \(N\).</li>
<li>N è uguale alla percentuale delle dichiarazioni vere.</li>
<li>Il numero dei diversi fattori di N (non necessariamente primi, ma diversi da 1 e N) è maggiore della somma dei numeri d’ordine delle dichiarazioni vere.</li>
<li>Non ci sono tre dichiarazioni consecutive vere.</li>
</ol>
</div>
</div>
<div id="outline-container-org4e5a82a" class="outline-2">
<h2 id="org4e5a82a">Domande</h2>
<div class="outline-text-2" id="text-org4e5a82a">
<p>
Perchè vogliamo variabili non negative, e quindi sostituiamo le variabili libere con differenze fra variabili, perchè la minimizzazione vuole vincoli maggiori uguali e viceversa?
</p>
</div>
</div>
<div id="outline-container-org63d30ad" class="outline-2">
<h2 id="org63d30ad">AI</h2>
<div class="outline-text-2" id="text-org63d30ad">
<p>
I'll help you reason through your integer programming model with precise mathematical formulation. Let's analyze the first sentence.
</p>

<p>
## First Sentence Analysis
The sentence states: "At least one of the two last sentences is wrong."
</p>

<p>
You've modeled this using the following constraints:
\[x_9 + x_{10} \geq x_1\]
\[x_9 + x_{10} \leq 2x_1\]
</p>

<p>
Let me analyze this formulation:
</p>

<p>
### Interpretation
</p>
<ul class="org-ul">
<li>\(x_1 = 1\) if sentence 1 is true, \(x_1 = 0\) if false</li>
<li>\(x_9, x_{10}\) are binary variables for sentences 9 and 10 (1 = true, 0 = false)</li>
</ul>

<p>
### Issue with Current Formulation
Your current constraints don't correctly capture the sentence's meaning. Let's see why:
</p>

<p>
If sentence 1 is true (\(x_1 = 1\)), then at least one of sentences 9 and 10 must be false. This means \(x_9 + x_{10} \leq 1\).
</p>

<p>
If sentence 1 is false (\(x_1 = 0\)), then both sentences 9 and 10 must be true, so \(x_9 = x_{10} = 1\).
</p>

<p>
### Correct Formulation
The constraints should be:
\[x_9 + x_{10} \leq 1 + (1-x_1)\]
\[x_9 + x_{10} \geq 2(1-x_1)\]
</p>

<p>
Which can be simplified to:
\[x_9 + x_{10} \leq 2 - x_1\]
\[x_9 + x_{10} \geq 2 - 2x_1\]
</p>

<p>
Would you like to continue with the remaining sentences, or should we discuss this formulation further?
</p>

<p>
Let's analyze the second sentence: "This is the first true sentence, or the first wrong sentence."
</p>

<p>
Your model: \(x_1 + x_2 \leq 1\)
</p>

<p>
I believe your constraint is incomplete for this logical statement. The sentence claims that sentence 2 is either:
</p>
<ol class="org-ol">
<li>The first true sentence (meaning \(x_1 = 0\) and \(x_2 = 1\)), or</li>
<li>The first wrong/false sentence (meaning \(x_1 = 1\) and \(x_2 = 0\))</li>
</ol>

<p>
This is an exclusive OR (XOR) relationship between \(x_1\) and \(x_2\). Your constraint \(x_1 + x_2 \leq 1\) ensures that at most one of the sentences is true, but it doesn't ensure that at least one of them is true.
</p>

<p>
For a proper XOR relationship, the complete constraint should be:
\(x_1 + x_2 = 1\)
</p>

<p>
This can be expressed as two constraints:
</p>
<ul class="org-ul">
<li>\(x_1 + x_2 \leq 1\) (at most one is true)</li>
<li>\(x_1 + x_2 \geq 1\) (at least one is true)</li>
</ul>

<p>
Would you like to adjust your model with this additional constraint?
</p>

<p>
I notice there seems to be some metadata accidentally included in your message. Let me focus on what appears to be your third sentence for the integer programming model:
</p>

<p>
<b><b>Sentence 3</b></b>: "There are three consecutive false sentences."
</p>

<p>
This is an interesting constraint that requires us to model the existence of three consecutive false sentences somewhere in the sequence. Let me formalize this:
</p>

<p>
For this sentence to be true (\(x_3 = 1\)), we need to ensure that there exist three consecutive sentences that are all false. For this sentence to be false (\(x_3 = 0\)), there should be no such consecutive triplet.
</p>

<p>
To model this mathematically, we need auxiliary variables:
</p>
<ul class="org-ul">
<li>Let \(y_i\) be 1 if sentences \(i\), \(i+1\), and \(i+2\) are all false, and 0 otherwise</li>
<li>We need these variables for \(i \in \{1, 2, ..., 8\}\) (since we can't go beyond sentence 10)</li>
</ul>

<p>
For each \(i\), we need:
\(y_i \leq 1-x_i\)
\(y_i \leq 1-x_{i+1}\)
\(y_i \leq 1-x_{i+2}\)
\(y_i \geq (1-x_i) + (1-x_{i+1}) + (1-x_{i+2}) - 2\)
</p>

<p>
Then the relationship with \(x_3\) is:
\(\sum_{i=1}^8 y_i \geq x_3\)
\(\sum_{i=1}^8 y_i \leq M \cdot x_3\) (where \(M\) is a sufficiently large number, e.g., 8)
</p>

<p>
These constraints ensure that \(x_3 = 1\) if and only if there are three consecutive false sentences somewhere in the sequence.
</p>

<p>
Would you like me to explain any part of this formulation further?
</p>

<p>
Thank you for sharing the fourth sentence and your approach. The problem is indeed challenging!
</p>

<p>
<b><b>Sentence 4</b></b>: "The difference between the number of the last true declaration and of the first true declaration is a factor of N."
</p>

<p>
You're right about the two main challenges:
</p>
<ol class="org-ol">
<li>The division \(N/d = w\) creates a non-linear constraint</li>
<li>Determining the first and last true declarations requires careful modeling</li>
</ol>

<p>
Here's a direction you might consider:
</p>

<ol class="org-ol">
<li>Create binary variables to identify the first and last true declarations:
<ul class="org-ul">
<li>Let \(f_i = 1\) if sentence \(i\) is the first true sentence (and 0 otherwise)</li>
<li>Let \(l_i = 1\) if sentence \(i\) is the last true sentence (and 0 otherwise)</li>
</ul></li>

<li>Add constraints to ensure proper definition of \(f_i\):
<ul class="org-ul">
<li>\(f_i \leq x_i\) (first true must be true)</li>
<li>\(f_i \leq 1 - x_j\) for all \(j < i\) (all earlier sentences must be false)</li>
<li>Plus constraints ensuring exactly one \(f_i\) equals 1 (if any sentence is true)</li>
</ul></li>

<li>Similarly, define constraints for \(l_i\):
<ul class="org-ul">
<li>\(l_i \leq x_i\) (last true must be true)</li>
<li>\(l_i \leq 1 - x_j\) for all \(j > i\) (all later sentences must be false)</li>
<li>Plus constraints ensuring exactly one \(l_i\) equals 1 (if any sentence is true)</li>
</ul></li>

<li>Calculate the difference:
<ul class="org-ul">
<li>\(d = \sum_{i=1}^{10} i \cdot l_i - \sum_{i=1}^{10} i \cdot f_i\)</li>
</ul></li>

<li>For the "factor of N" relationship, since we have only 10 sentences, the maximum difference is 9. You could use a discrete approach:
<ul class="org-ul">
<li>Create binary variables \(y_d\) for each possible difference value \(d \in \{1,2,...,9\}\)</li>
<li>Ensure only one \(y_d = 1\)</li>
<li>Add constraints: if \(y_d = 1\), then \(N \bmod d = 0\)</li>
</ul></li>
</ol>

<p>
This avoids non-linearity by considering all possible values of \(d\) explicitly.
</p>

<p>
Let's start fresh with this sentence:
</p>

<p>
<b><b>Sentence 4</b></b>: "The difference between the number of the last true declaration and of the first true declaration is a factor of N."
</p>

<p>
To model this properly in integer programming:
</p>

<ol class="org-ol">
<li>First, create binary variables to identify the first and last true declarations:
<ul class="org-ul">
<li>Let \(f_i = 1\) if sentence \(i\) is the first true sentence, 0 otherwise (for \(i = 1,2,...,10\))</li>
<li>Let \(l_i = 1\) if sentence \(i\) is the last true sentence, 0 otherwise (for \(i = 1,2,...,10\))</li>
</ul></li>

<li><p>
Define constraints to ensure \(f_i\) and \(l_i\) work correctly:
</p>
<ul class="org-ul">
<li>\(f_i \leq x_i\) (first true must be true)</li>
<li>\(f_i \leq 1 - x_j\) for all \(j < i\) (all earlier must be false)</li>
<li>\(\sum_{i=1}^{10} f_i = \min(1, \sum_{i=1}^{10} x_i)\) (exactly one first if any are true)</li>
</ul>

<p>
Similarly for \(l_i\):
</p>
<ul class="org-ul">
<li>\(l_i \leq x_i\) (last true must be true)</li>
<li>\(l_i \leq 1 - x_j\) for all \(j > i\) (all later must be false)</li>
<li>\(\sum_{i=1}^{10} l_i = \min(1, \sum_{i=1}^{10} x_i)\) (exactly one last if any are true)</li>
</ul></li>

<li>Calculate the difference:
<ul class="org-ul">
<li>\(d = \sum_{i=1}^{10} i \cdot l_i - \sum_{i=1}^{10} i \cdot f_i\)</li>
</ul></li>

<li>For the "factor of N" relationship in MATHPROG, since modulo can't be used directly in constraints, you can:
<ul class="org-ul">
<li>Introduce integer variable \(k\) representing the multiplier</li>
<li>Add the constraint: \(d \cdot k = N\)</li>
<li>This enforces that \(d\) is a factor of \(N\) without using modulo</li>
</ul></li>

<li>To ensure sentence 4 is correctly modeled:
<ul class="org-ul">
<li>If \(x_4 = 1\) (sentence is true), the constraints enforce that \(d\) is a factor of \(N\)</li>
<li>If \(x_4 = 0\) (sentence is false), we need to break this relationship</li>
</ul></li>
</ol>

<p>
For \(x_4 = 0\) case, you can use a big-M approach:
</p>
<ul class="org-ul">
<li>\(d \cdot k \leq N + M \cdot (1-x_4)\)</li>
<li>\(d \cdot k \geq N - M \cdot (1-x_4)\)</li>
</ul>

<p>
Where \(M\) is a sufficiently large constant. When \(x_4 = 0\), these constraints become inactive.
</p>

<p>
Does this approach make sense for your MATHPROG model?
</p>

<p>
You're absolutely correct - I made an error in my suggestion. The constraint \(d \cdot k = N\) is indeed non-linear because it involves multiplication of two variables (\(d\) and \(k\)). This would make the model non-linear, which standard linear integer programming solvers like GLPSOL cannot handle directly.
</p>

<p>
Let me correct my approach:
</p>

<p>
Since you have at most 10 sentences, the difference \(d\) can only take values from the set \(\{0,1,2,...,9\}\). We can use this finite set of possibilities to create a linear formulation:
</p>

<ol class="org-ol">
<li>Create binary variables \(y_j\) for each possible difference value \(j \in \{1,2,...,9\}\)
<ul class="org-ul">
<li>\(y_j = 1\) if the difference equals \(j\), otherwise \(y_j = 0\)</li>
</ul></li>

<li>Ensure that the calculated difference matches the selected \(y_j\):
<ul class="org-ul">
<li>\(\sum_{i=1}^{10} i \cdot l_i - \sum_{i=1}^{10} i \cdot f_i = \sum_{j=1}^{9} j \cdot y_j\)</li>
</ul></li>
</ol>



<ol class="org-ol">
<li>Ensure exactly one \(y_j\) is selected when there is at least one true statement:
<ul class="org-ul">
<li>\(\sum_{j=1}^{9} y_j = \min(1, \sum_{i=1}^{10} x_i)\)</li>
</ul></li>

<li>For each possible value of \(j\), introduce integer variables \(k_j\) and constraints:
<ul class="org-ul">
<li>If \(y_j = 1\), then \(N = j \cdot k_j\) (using big-M constraints)</li>
<li>If \(y_j = 0\), then \(k_j = 0\)</li>
</ul></li>

<li>Finally, connect this to \(x_4\) (the truth of sentence 4):
<ul class="org-ul">
<li>If \(x_4 = 1\), the factor relationship must hold</li>
<li>If \(x_4 = 0\), the factor relationship must be broken</li>
</ul></li>
</ol>

<p>
This approach avoids the non-linear multiplication while capturing the logic of the sentence.
</p>

<p>
Let me focus on the logical formulation for sentence 3: "Ci sono tre dichiarazioni false consecutive."
</p>

<p>
Your approach using auxiliary variables \(y_i\) is logical, but there's a critical component missing:
</p>

<p>
You need to define the relationship between each \(y_i\) and the corresponding \(x\) variables. Currently, you've defined what \(y_i\) should represent (three consecutive false statements), but haven't established the mathematical constraints that enforce this definition.
</p>

<p>
To properly link \(y_i\) to the original variables:
</p>

<p>
\(y_i = 1\) if and only if \((x_i = 0 \text{ AND } x_{i+1} = 0 \text{ AND } x_{i+2} = 0)\)
</p>

<p>
This can be expressed with these linear constraints:
</p>
<ul class="org-ul">
<li>\(y_i \leq 1 - x_i\) (if \(x_i = 1\), then \(y_i\) must be 0)</li>
<li>\(y_i \leq 1 - x_{i+1}\) (if \(x_{i+1} = 1\), then \(y_i\) must be 0)</li>
<li>\(y_i \leq 1 - x_{i+2}\) (if \(x_{i+2} = 1\), then \(y_i\) must be 0)</li>
<li>\(y_i \geq 1 - (x_i + x_{i+1} + x_{i+2})\) (if all three are 0, then \(y_i\) must be 1)</li>
</ul>

<p>
With these linking constraints added, your formulation for sentence 3 will be correct:
</p>
<ul class="org-ul">
<li>\(\sum_{i=1}^8 y_i \geq x_3\) ensures there's at least one sequence of three consecutive false statements when statement 3 is true</li>
<li>\(\sum_{i=1}^8 y_i \leq 8 \cdot x_3\) ensures there are no such sequences when statement 3 is false</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-05-30 Fri 07:58</p>
</div>
</body>
</html>
