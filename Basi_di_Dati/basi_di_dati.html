<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-06-07 Sat 16:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Basi di dati</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Basi di dati</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9b561b0">Modello relazionale</a></li>
<li><a href="#orge905b20">Algebra relazionale (59 pdf atzeni)</a>
<ul>
<li><a href="#orgf4583ea"><span class="todo TODO">TODO</span> Equivalenza fra espressioni e ottimizzazione</a></li>
<li><a href="#org61f7db3">Viste</a></li>
</ul>
</li>
<li><a href="#org41cc0cf">SQL</a>
<ul>
<li><a href="#orga4ab0e8">Istruzioni</a>
<ul>
<li><a href="#orge4785da">SELECT</a></li>
<li><a href="#org848cd8a">Operatori aggregati</a></li>
<li><a href="#orgab9516d">Raggruppamento</a></li>
<li><a href="#org0362afe">Operatori insiemistici</a></li>
<li><a href="#org27d8067">Interrogazioni nidificate</a></li>
<li><a href="#org5f75e49"><span class="todo TODO">TODO</span> Continuare da 4.3.7</a></li>
</ul>
</li>
<li><a href="#org2ebdc19">Programma</a></li>
<li><a href="#orga17ab93">Domini elementari</a></li>
</ul>
</li>
<li><a href="#org618fc09">Modello Entità Relazione (progettazione concettuale)</a>
<ul>
<li><a href="#org6747221">Costrutti di base (entità, relazioni, attributi)</a></li>
</ul>
</li>
<li><a href="#org56951a6">Progettazione logica</a>
<ul>
<li><a href="#org5bff971">Ristrutturazione</a></li>
<li><a href="#orgfc04f5d">Traduzione a modello relazionale</a></li>
<li><a href="#orge62db05"><span class="todo TODO">TODO</span> Reverse Engineering</a></li>
<li><a href="#org4489564">Normalizzazione di Schemi Relazionali</a>
<ul>
<li><a href="#orge38ffbb">Dipendenza Funzionale</a></li>
<li><a href="#org0c3b93d">Regole di Inferenza sulle Dipendenze Funzionali</a></li>
<li><a href="#orgb54d095">Individuazione delle Dipendenze Funzionali</a></li>
<li><a href="#orgcf483ab">Normalizzazione di Relazioni</a></li>
<li><a href="#org736749d">Forme Normali</a>
<ul>
<li><a href="#org33e892b">Prima Forma Normale (1NF)</a></li>
<li><a href="#org1cad199">Seconda Forma Normale (2NF)</a></li>
<li><a href="#org27a9a90">Terza Forma Normale (3NF)</a></li>
<li><a href="#orgc85feca">Forma Normale di Boyce-Codd (BCNF)</a></li>
</ul>
</li>
<li><a href="#org7ce2b50">Riassunto delle Proprietà della Normalizzazione</a></li>
<li><a href="#org7309663">Esempio di Decomposizione in 3NF</a></li>
<li><a href="#orge2afa43">Note Finali</a>
<ul>
<li><a href="#orgcdfc43f">Verifica di correttezza</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8478db7">Progettazione Fisica: Strutture e Metodi d'Accesso ai Dati su Disco</a>
<ul>
<li><a href="#orgafde17f">DBMS e sistema operativo</a></li>
<li><a href="#org0ca3ea3">Fattore di blocco</a></li>
<li><a href="#org03b1d15">Strutture primarie dei file</a></li>
<li><a href="#orga8e47af">Strutture ad accesso sequenziale</a>
<ul>
<li><a href="#orgc1e8f0b">Struttura non ordinata (file heap)</a></li>
<li><a href="#org9954a3f">Struttura sequenziale ad array</a></li>
<li><a href="#org8c2c3d1">Struttura sequenziale ordinata</a></li>
</ul>
</li>
<li><a href="#orgbc1ddf4">Strutture ad accesso calcolato (hash)</a></li>
<li><a href="#org2399872">Alberi (indici)</a>
<ul>
<li><a href="#orgbb93c2c">Indici primari</a></li>
<li><a href="#org9a90d3b">Indici secondari</a></li>
</ul>
</li>
<li><a href="#org434d37c">Considerazioni sugli indici</a></li>
<li><a href="#org4a455f1">Alberi di ricerca</a></li>
<li><a href="#orgc189ed7">Tips</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc40ce0a">Progetto</a>
<ul>
<li><a href="#org266508c">Usare bootstrap con supporto SAAS (forse)</a></li>
<li><a href="#orgd3753a8">Presentazione</a>
<ul>
<li><a href="#orgc7e7fa6">La discussione serve per capire quello che c'è dietro</a>
<ul>
<li><a href="#orga256f47">Giustificare le scelte</a>
<ul>
<li><a href="#orgf20ed8d">Come scrivere un trigger in un altro modo?</a></li>
<li><a href="#org5d6a9fd">Domande su viste</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge364219">La parte di progettazione è importante</a>
<ul>
<li><a href="#org9d8e77e">DDL, progettazione degli schema, integrità referenziale</a></li>
</ul>
</li>
<li><a href="#orgf08af85">Specifiche</a>
<ul>
<li><a href="#orgbf8816e">Non è detto che il manager sia il responsabile, sono due cose diverse</a></li>
<li><a href="#org0bc5694">Informazioni di tipo testuale suggerisce il tipo di dominio da usare</a></li>
<li><a href="#org0a8ccfa">Il prezzo di un prodotto non dipende dal prodotto stesso, ma dal prodotto e dal negozio in cui è in vendita</a></li>
<li><a href="#orgd1c2601">I clienti possono acquistare da negozi diversi nella stessa fattura</a></li>
<li><a href="#orgda40b9e">Anche i fornitori forniscono prezzi diversi</a></li>
<li><a href="#org1dbd577">Un cliente può avere o non avere una tessera. La tessera è associata ad un negozio specifico e il cliente può averne una sola.</a>
<ul>
<li><a href="#orgda52999">È importante tenere traccia la data e il negozio in cui è stata effettuata</a></li>
</ul>
</li>
<li><a href="#org0eb19a0">Queste sono le specifiche che dobbiamo tener presente quando progettiamo lo schema concettuale e passiamo a quello logico</a></li>
</ul>
</li>
<li><a href="#orgc7d5baf">2.2</a>
<ul>
<li><a href="#orga0b64f6">Tutto implementato con viste, viste materializzate, funzioni, trigger, procedure</a></li>
<li><a href="#org60a3aee">Applicazione sconto</a>
<ul>
<li><a href="#org55353f6">Sono un cliente, faccio un acquisto, decido di usare lo sconto del 15%, mi viene proposto di applicare lo sconto</a></li>
<li><a href="#org1e1aa51">Si può usare un solo sconto per acquisto (si può fare anche diversamente ma va motivato)</a></li>
</ul>
</li>
<li><a href="#org972a1c7">Ordine prodotti da fornitore</a>
<ul>
<li><a href="#orgb74e63b">Mentre il cliente sceglie autonomamente il negozio da cui comprare, il fornitore di un negozio è scelto sulla base di un criterio di economicità</a></li>
</ul>
</li>
<li><a href="#org9c2b875">L'elenco dei saldi punti &gt; 300 dev'essere mantenuto e non calcolato a volo</a></li>
</ul>
</li>
<li><a href="#orgafdf17b">Consegna</a>
<ul>
<li><a href="#org0550496">Due folder, una con il dump (non in esadecimale ma in testo) e l'altro è l'insieme delle pagine pgp</a></li>
</ul>
</li>
<li><a href="#org762d0bd">Struttura orale</a>
<ul>
<li><a href="#org7743b1c">Ci lascia 5 minuti per mostrare le funzionalità principali o pirotecniche</a></li>
<li><a href="#orga7e0150">Ci fa domande sul codice sorgente, fa fare qualche modifica</a></li>
<li><a href="#org98714eb">Guardiamo la progettazione e la correggiamo</a></li>
<li><a href="#org0bfa77f">Qualche domandina su PHP</a></li>
</ul>
</li>
<li><a href="#org77afa91">Pg query non va usato, ma si usa prepare and execute</a></li>
</ul>
</li>
<li><a href="#org3a200d5">Tabelle derivate (trigger) o materialized view?</a></li>
<li><a href="#orgd53ed62">PGquery non va usato, ma va usato pg<sub>prepare</sub> e pg<sub>execute</sub> (o anche pg<sub>query</sub> params)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org9b561b0" class="outline-2">
<h2 id="org9b561b0">Modello relazionale</h2>
<div class="outline-text-2" id="text-org9b561b0">
<p>
Un'<b>entità</b> rappresenta un oggetto o concetto del mondo reale.
</p>

<p>
Un <b>attributo</b> rappresenta una proprietà di interesse che descrive ulteriormente un'entità. Il <b>dominio</b> è l'insieme di possibili valori sui quali sono definiti degli attributi (es. interi, stringhe). In un sistema tabellare corrisponde alle intestazioni delle colonne.
</p>

<p>
Una <b>relazione</b> tra due o più entità rappresenta un'associazione tra le entità. Formalmente è definita come <b>sottoinsieme</b> del <b>prodotto cartesiano</b> dei <b>domini</b> degli <b>attributi</b> sui quali è definita la relazione. In un sistema tabellare corrisponde alla singola tabella.
</p>

<p>
Una <b>tupla</b> in una relazione è un record (entrata) i cui valori sono posizionalmente coerenti con i domini della relazione. In un sistema tabellare corrisponde alla singola entrata.
</p>

<p>
Uno <b>schema</b> è la descrizione di un database (aspetto <b>intensionale</b>) e viene specificato durante la progettazione del database. Si prevede che non cambi frequentemente. L'<b>istanza</b> invece è l'insieme di valori attuali (aspetto <b>estensionale</b>) e cambia rapidamente.
</p>

<p>
Viene definito il valore <b>NULL</b> che ha un significato semantico doppio: dato <b>inesistente/non applicabile</b> oppure <b>dato esistente ma sconosciuto</b>. I due significati sono indistinguibili.
</p>

<p>
Un <b>vincolo di integrità</b> è una proprietà che deve essere soddisfatta da un <b>istanza</b> ed è in forma di <b>predicato</b> logico.
</p>

<p>
Un vincolo è <b>intrarelazionale</b> se il suo soddisfacimento è definito rispetto a singole relazioni della base di dati, mentre è <b>interrelazionale</b> se coinvolge più relazioni.
</p>

<p>
In particolare è <b>di tupla</b> se è valutato sulla singola tupla indipendetemente dalle altre e <b>di dominio</b>, quando restringe il valore del <b>singolo attributo</b>.
</p>

<p>
Fra i vincoli <b>intrarelazionali</b> il più importante è quello <b>di chiave</b>.
</p>

<p>
Una <b>superchiave</b> è un insieme di attributi che identifica univocamente ogni tupla in una relazione. Formalmente, dato uno schema di relazione \(R(A_1, A_2, \ldots, A_n)\), un insieme di attributi \(K \subseteq \{A_1, A_2, \ldots, A_n\}\) è una superchiave per \(R\) se e solo se
\[ \forall t_1, t_2 \in r(R) : t_1 \neq t_2 \Rightarrow t_1[K] \neq t_2[K] \]
Dove \(r(R)\) è un'istanza della relazione \(R\), e \(t[K]\) denota la proiezione della tupla \(t\) sugli attributi in \(K\).
Una <b>superchiave</b> ha la proprietà di <b>identificazione univoca</b>, ovvero garantisce che non esistano tuple distinte con stessi valori negli attributi chiave.
L'insieme di tutti gli attributi è sempre superchiave, perchè non possono esistere più tuple con gli stessi valori.
</p>

<p>
Una <b>chiave</b> \(K\) è una superchiave <b>minimale</b>, ovvero tale per cui \(K\subseteq S\) e non esiste un'altra chiave \(K' \subseteq K\).
</p>

<p>
Una <b>chiave minimale</b> è una chiave che <b>non ammette</b> valori <code>NULL</code>. Rispetta le proprietà di integrità, minimalità e non nullità.
</p>

<p>
Fra i vincoli <b>interrelazionali</b>, il più importante è quello di <b>integrità referenziale</b>.
Un <b>vincolo di integrità referenziale</b> fra un insieme di attributi \(X\) (detto <b>foreign key</b>) di una relazione \(R_1\) e un'altra relazione \(R_2\) è soddisfatto se i valori \(X\) di ciascuna tupla di \(R_1\) compaiono come attributi in \(R_2\).
</p>
</div>
</div>
<div id="outline-container-orge905b20" class="outline-2">
<h2 id="orge905b20">Algebra relazionale (59 pdf atzeni)</h2>
<div class="outline-text-2" id="text-orge905b20">
<p>
Operazioni:
</p>
<dl class="org-dl">
<dt>Insiemistiche</dt><dd>definite sullo stesso insieme di attributi
<dl class="org-dl">
<dt>Unione</dt><dd>restituisci tuple che appartengono all'una, all'altra o ad entrambe le relazioni;</dd>
<dt>Differenza</dt><dd>le tuple che appartengono alla prima ma non alla seconda relazione;</dd>
<dt>Intersezione</dt><dd>le tuple che appartengono sia all'una che all'altra relazione. Definibile mediante l'unione e la differenza, infatti \(r\cap s = r - (r - s)\)</dd>
</dl></dd>
<dt>Ridenominazione</dt><dd>modifica lo schema, sostituendo il nome di un attributo con un altro. Si indica con \(\rho_{B_1...B_k\leftarrow A_1...A_k}(r)\). Viene usata per rendere i nomi di attributi uguali per effettuare operazioni che lo richiedono.</dd>
<dt>Selezione</dt><dd>sia \(F\) una <b>formula proposizionale</b>, ovvero combinando confronti mediante AND, OR e NOT, allora \(\sigma_F(r)\) produce una relazione con <b>stessi attributi</b> e contenente <b>soltanto le *tuple</b> di \(r\) per cui \(F\) è vera .</dd>
<dt>Proiezione</dt><dd>$&pi;<sub>A<sub>1&#x2026;A</sub><sub>k</sub></sub>(r) riduce gli attributi della relazione \(r\). Il numero di tuple è uguale se il gruppo di attributi proiettati è superchiave, altrimenti più tuple collassano (perchè si trovano ad avere i valori per gli attributi proiettati diversi).</dd>
<dt>Join</dt><dd>permette di correlare dati contenuti in relazioni diverse
<dl class="org-dl">
<dt>Join naturale</dt><dd><p>
produce una relazione che ha come attributi l'unione degli attributi e combinando le tuple degli operandi con valori uguali su attributi comuni. Può essere ottenuto mediante la proiezione, la selezione e il prodotto cartesiano, in questo modo \(R\bowtie S = \pi_{A_1,A_2,...,A_n}(\sigma_C (R \times S))\), dove la condizione \(C\) è quella che pone come uguali gli attributi comuni e gli attributi proiettati sono tutti, senza duplicati.
</p>

<p>
Il grado della relazione può essere \(0\) se non esistono tuple con valori uguali su gli attributi comuni agli operandi, o il prodotto delle cardinalità se tutte le tuple hanno gli stessi valori.
</p></dd>
<dt>Join esterno</dt><dd>si comporta come il join naturale, ma nel caso in cui per un certo valore dell'attributo comune non esista una controparte nell'altra tabella, la tupla viene inserita lo stesso, inserendo valori null per l'altra relazione. Esistono le varianti destra, sinistra e full, che preservano i valori di di uno, l'altro o entrambi i lati anche quando manca una controparte.</dd>
<dt>Semi join</dt><dd>restituisce le tuple che partecipano ad una join con un altra tabella, senza restituire i valori dell'altra tabella. Non è altro che una proiezione sugli attributi di \(X_1\) del join fra \(r_1\) e \(r_2\)</dd>
<dt>Theta join</dt><dd>un prodotto cartesiano, come il join senza attributi comuni, seguito da una selezione. Spesso è l'unico join disponibile nei sistemi reali, in quanto non sempre vengono usati nomi per identificare gli attributi. Per ottenere un operazione con lo stesso risultato del join naturale, si fa così: 1. ridenomina gli attributi per renderli tutti diversi 2. effettua una theta join dove la condizione è quella che i valori per gli attributi precedentemente comuni, appena rinominati, siano uguali nelle due relazioni 3. proietta gli attributi eliminando i doppioni</dd>
</dl></dd>
<dt>Divisione</dt><dd><p>
il contrario del prodotto cartesiano. Se date due tabelle, il prodotto cartesiano restituisce tutte le tuple della prima concatenate con tutte le tuple dell'altra, la divisione prende una tabella composta da più attributi, una tabella che contiene un sottoinsieme degli attributi del dividendo e resituisce una tabella che contiene i soli restanti attributi, soltanto quando questi siano associati a ogni valore del divisore.
In sostanza, si buttano via i campi che non sono associati a ogni campo del divisore e si restituisce la proiezione sui campi della dividendo ma non del divisore.
</p>

<p>
È utile per trovare in una tabella soltanto i campi che sono associati ad <b>ogni</b> valore di un altra tabella.
</p>

<p>
Si ottiene con la seguente sequenza di operazioni:
</p>
<ul class="org-ul">
<li>proietta soltanto gli attributi del dividendo non presenti nel divisore</li>
<li>costruisci il prodotto cartesiano di tale proiezione e il dividendo, ovvero</li>
<li>sottrai dal prodotto cartesiano il divisore. A questo punto ottengo tutte le tuple che contengono i valori del dividendo che <b>non</b> erano associati a ogni valore del divisore (altrimenti sarebbero scomparsi con la divisione)</li>
<li>proietta dal risultato ottenuto soltanto gli attributi del dividendo (in questo modo la tabella collassa e conterrà i soli valori non comuni)</li>
<li><p>
sottrai il valore così ottenuto dalla proiezione sui soli attributi non comuni del dividendo
</p>

<p>
\[
   \pi_X(R) - \pi_X\left((\pi_X(R) \times S) - R\right)
   \]
</p></li>
</ul></dd>
</dl>
</div>
<div id="outline-container-orgf4583ea" class="outline-3">
<h3 id="orgf4583ea"><span class="todo TODO">TODO</span> Equivalenza fra espressioni e ottimizzazione</h3>
</div>
<div id="outline-container-org61f7db3" class="outline-3">
<h3 id="org61f7db3">Viste</h3>
<div class="outline-text-3" id="text-org61f7db3">
<p>
Brevemente, sono delle relazioni virtuali definite in base ad altre. Quando viene effettuata un'interrogazione su esse, viene in realtà sostituito ad essa il suo vero contenuto. I vantaggi sono di nascondere complessità, garantire sicurezza garantendo accesso soltanto ad alcune viste, oppure mantenere la compatibilità (se una relazione viene eliminata ma è ancora derivabile, definire una vista permette di lasciare il codice uguale).
</p>

<p>
L'aggiornamento di viste è delicato perchè un aggiornamento della vista non è univoco nelle relazioni originali (potrebbero esserci dei campi che sono stati ignorati)
</p>
</div>
</div>
</div>
<div id="outline-container-org41cc0cf" class="outline-2">
<h2 id="org41cc0cf">SQL</h2>
<div class="outline-text-2" id="text-org41cc0cf">
<p>
SQL è un linguaggio <b>dichiarativo</b> e non funzionale, ovvero è basato sulla descrizione dell'obiettivo dell'operazione e non del suo svolgimento. L'interprete SQL del DBMS analizza l'istruzione e formula un'interrogazione equivalente, possibilmente ottimizzata, nel suo linguaggio procedurale interno, nascosto all'utente
</p>
</div>
<div id="outline-container-orga4ab0e8" class="outline-3">
<h3 id="orga4ab0e8">Istruzioni</h3>
<div class="outline-text-3" id="text-orga4ab0e8">
</div>
<div id="outline-container-orge4785da" class="outline-4">
<h4 id="orge4785da">SELECT</h4>
<div class="outline-text-4" id="text-orge4785da">
<p>
L'istruzione <code>SELECT ListaAttributi FROM ListaTabelle [WHERE Condizione]</code> permette di estrarre delle righe dalle relazione indicate in base alla condizione.
</p>

<p>
Questa istruzione crea il prodotto cartesiano della lista tabelle, ne filtra le righe secondo la condizione e poi proietta gli attributi indicati come primo argomento.
</p>

<p>
Per fare pattern matching di stringhe si usa la clausola <code>LIKE</code>, di solito usando una regex con %, che indica un numero variabile di caratteri, del tipo <code>LIKE '%parola%'</code>.
</p>

<p>
La clausola <code>AS</code> permette di effettuare la ridenominazione di un attributo o di una relazione.
</p>

<p>
A differenza dell'algebra relazionale, se il restringimento degli attributi comporta valori ripetuti, questi vengono comunque mostrati. Per avere valori distinti si specifica <code>SELECT DISTINCT</code>
</p>

<p>
Una sintassi alternativa è <code>SELECT ListaAttributi FROM Tabella [TIPO JOIN] JOIN Tabella ON Condizione</code>, che si comporta come una select con clausola WHERE ma rispecchia più da vicino il theta-join dell'algebra relazionale. I tipi di JOIN ammessi sono INNER (default), RIGHT OUTER, LEFT OUTER, FULL OUTER (o anche solo FULL).
</p>

<p>
Per includere o escludere i <code>null</code> si usa <code>Attributo is [not] null</code>
</p>

<p>
Per ordinare si usa la clausola <code>ORDER BY AttributiDaOrdinare [ asc | desc ]</code> con attributi multipli separati da virgole.
</p>
</div>
</div>
<div id="outline-container-org848cd8a" class="outline-4">
<h4 id="org848cd8a">Operatori aggregati</h4>
<div class="outline-text-4" id="text-org848cd8a">
<p>
Permettono di esprimere proprietà possedute da più tuple, ad esempio la cardinalità, altrimenti inesprimibili mediante l'algebra relazionale.
</p>

<p>
<code>COUNT([DISTINCT|ALL Attributi)</code>, che conta il numero di righe per Attributi considerando o meno i duplicati e senza contare i NULL, oppure <code>COUNT( * )</code> che considera anche i NULL
</p>

<p>
Gli altri operatori aggregati sono <code>sum</code>, <code>max</code>, <code>min</code>, <code>avg</code>, che usano la stessa sintassi di count eccetto l'asterisco.
</p>
</div>
</div>
<div id="outline-container-orgab9516d" class="outline-4">
<h4 id="orgab9516d">Raggruppamento</h4>
<div class="outline-text-4" id="text-orgab9516d">
<p>
Gli operatori aggregati lavorano su un insieme di righe. Per dividere la tabella in sottogruppi e applicarvi le funzioni aggregate.
</p>

<p>
La clausola <code>GROUP BY Attributo</code> in una SELECT divide la tabella in vari gruppi, ognuno caratterizzato da un certo valore di Attributo.
</p>

<p>
<code>SELECT AttributoDaDividere, aggregato(AltroAttributo) FROM Tabella GROUP BY AttributoDaDividere</code> restituisce l'operatore aggregato applicato ai gruppi in cui la tabella è stata divisa
</p>

<p>
Quando si vuole considerare soltanto alcuni dei gruppi in base a una certa condizione, si usa la clausola <code>HAVING Condizione</code>
</p>
</div>
</div>
<div id="outline-container-org0362afe" class="outline-4">
<h4 id="org0362afe">Operatori insiemistici</h4>
<div class="outline-text-4" id="text-org0362afe">
<p>
<code>UNION</code>, <code>INTERSECT</code> e <code>EXCEPT</code> (differenza)
</p>

<p>
Sono generalmente poco efficienti. Solo l'unione è necessaria, mentre le altre operazioni possono essere espresse mediante altri comandi. Assumono tutti la clausola <code>DISTINCT</code> e quindi bisogna specificare <code>ALL</code> quando è il contrario.
</p>
</div>
</div>
<div id="outline-container-org27d8067" class="outline-4">
<h4 id="org27d8067">Interrogazioni nidificate</h4>
<div class="outline-text-4" id="text-org27d8067">
<p>
Il caso d'uso tipico è quando nella condizione nel WHERE si vogliono confrontare un attributo della tabella nel FROM e il risultato di un'altra interrogazione, sorge il problema della disomogeneità, infatti si confronterebbe la singola riga con il contenuto di un'intera interrogazione.
</p>

<p>
Per questo si usano le keyword <code>all</code> e <code>any</code>, che indicano che la riga debba soddisfare la condizione per rispettivamente tutte o almeno una delle righe dell'interrogazione nidificata.
</p>

<p>
Inoltre vengono forniti gli operatori  <code>[not] in</code> che risultano veri solo quando il valore del primo attributo per quella riga si trova nella tabella frutto dell'interrogazione nidificata
</p>

<p>
L'operatore unario <code>[not] exists</code> invece restituisce vero soltanto quando la tabella nidificata è non vuota. Ha senso usarlo soltanto con delle variabili dichiarate al primo livello.
</p>

<p>
Si possono usare anche costruttori di tupla, che vengono usati per racchiudere vari attributi in un solo oggetto che poi può essere confrontato
</p>
</div>
</div>
<div id="outline-container-org5f75e49" class="outline-4">
<h4 id="org5f75e49"><span class="todo TODO">TODO</span> Continuare da 4.3.7</h4>
</div>
</div>
<div id="outline-container-org2ebdc19" class="outline-3">
<h3 id="org2ebdc19">Programma</h3>
<div class="outline-text-3" id="text-org2ebdc19">
<p>
19/03/25
</p>
<ul class="org-ul">
<li>introduzione a SQL</li>
<li>istruzione select</li>
<li>clausola where nel comando select</li>
<li>operatori booleani</li>
<li>operatore like</li>
<li>funzioni lower/upper/trim</li>
</ul>

<p>
25/03/25
</p>
<ul class="org-ul">
<li>query SQL: operatori between, in, like, is null</li>
<li>query SQL: alias di attributi</li>
<li>query SQL: ordinamento del risultato</li>
<li>query SQL: operazioni di join</li>
<li>query SQL: alias di relazione</li>
</ul>

<p>
26/03/25
</p>
<ul class="org-ul">
<li>query SQL: self join</li>
<li>viste in SQL</li>
<li>clausola WITH e tabelle temporanee (query CTE)</li>
<li>valutazione del piano di esecuzione di una query (EXPLAIN)</li>
<li>query SQL: operatori insiemistici (UNION, INTERSECT, EXCEPT)</li>
<li>query innestate (o subquery)</li>
</ul>

<p>
01/04/2025
</p>
<ul class="org-ul">
<li>query SQL: join esterni (left/right/full)</li>
<li>applicazioni dei join esterni</li>
<li>operatore EXISTS</li>
</ul>

<p>
08/04/2025
</p>
<ul class="org-ul">
<li>query SQL: operatori aggregati</li>
<li>query con raggruppamento</li>
<li>query SQL: clausola GROUP BY</li>
<li>query SQL: clausola HAVING</li>
</ul>

<p>
09/04/2025
</p>
<ul class="org-ul">
<li>query SQL: query correlate</li>
<li>query SQL: correlate con aggregazione</li>
<li>divisione in SQL</li>
</ul>

<p>
15/04/2024
</p>
<ul class="org-ul">
<li>interrogazioni ricorsive in SQL</li>
<li>basi di dati attive (asserzioni e trigger)</li>
<li>viste materializzate</li>
<li>viste aggiornabili</li>
</ul>
</div>
</div>
<div id="outline-container-orga17ab93" class="outline-3">
<h3 id="orga17ab93">Domini elementari</h3>
<div class="outline-text-3" id="text-orga17ab93">
<p>
<code>character</code>, <code>numeric</code>
</p>
</div>
</div>
</div>
<div id="outline-container-org618fc09" class="outline-2">
<h2 id="org618fc09">Modello Entità Relazione (progettazione concettuale)</h2>
<div class="outline-text-2" id="text-org618fc09">
</div>
<div id="outline-container-org6747221" class="outline-3">
<h3 id="org6747221">Costrutti di base (entità, relazioni, attributi)</h3>
<div class="outline-text-3" id="text-org6747221">
<p>
Le <b>entità</b> rappresentano classi di oggetti che hanno proprietà comuni. Vengono rappresentate mediante un <b>rettangolo</b>.
</p>

<p>
Le <b>relazioni (associazioni)</b> rappresentano legami logici significativi per la relazione di interesse. Una sua occorrenza è una ennupla contenente occorrenze delle entità coinvolte. Vengono rappresentate mediante un <b>rombo</b>.
Possono essere ricorsive, e in tal caso se non sono simmetriche allora va indicato con un identificatore alle linee uscenti dalla relazione ricorsiva.
Possono essere specificate delle <b>cardinalità</b> per ciascuna partecipazione di un entità ad una relazione. In generale si usano i valori 0, 1 e N. La cardinalità minima può essere 0, opzionale, o 1, obbligatoria. Quella massima può essere 1, in tal caso la relazione è come una funzione, o N, ovvero arbitraria. In base alla cardinalità massima si possono classificare le relazioni come uno-a-uno, uno-a-molti, molti-a-molti.
</p>

<p>
Gli <b>attributi</b> descrivono proprietà elementari di attributi o relazioni. Possono essere raggrupati in attributi composti (ma non vengono usati spesso).
Possono essere obbligatori se la loro cardinalità minima è 1, opzionali altrimenti. Quando la cardinalità massima è N, sono detti multivalore e vuol dire che ad un'occorrenza di entità possono essere associati più valori.
</p>

<p>
Un <b>identificatore</b> è specificato per un'entità e descrive i concetti (attributi ed entità) che identificano univocamente un'occorrenza dell'entità. Quando un sottoinsieme degli attributi è identificatore, si parla di identificatori interni.
A volte è invece necessario includere altre entità. In tal caso sono identificatori esterni e si indicano collegando l'attributo interno che fa da id con la linea che collega l'entità in questione con l'entità identificatrice.
Gli attributi identificativi devono avere cardinalità uno-ad-uno, e le relazioni che collegano all'entità identificativa devono avere cardinalità uno-ad-uno con l'entità in questione. Se queste condizioni non avvengono, allora lo stesso attributo potrebbe riferirsi a più occorrenze e alla stessa occorrenza potrebbero essere associate più entità esterne, quindi non potrebbero essere identificatori.
</p>

<p>
Una <b>generalizzazione</b> rappresenta legami logici fra un entità genitore e le entità figlie. L'entità genitore è una <b>generalizzazione</b> di quelle figlie e le comprende come caso particolare. Le figlie <b>specializzano</b> quella genitore ed ogni loro occorrenza è anche un occorrenza dell'entità genitore.
Inoltre, ogni attributo dell'entità genitore lo è anche delle entità figlie.
In generale, ogni sottoclasse <b>eredita</b> tutte le proprietà della superclasse, ovvero attributi, identificatori e relazioni.
Se ogni occorrenza dell'entità generale lo è di almeno una delle figlie, allora la generalizzazione è <b>totale</b> ed è indicata con la freccia piena. Altrimenti esiste qualche occorrenza che non è inclusa in nessun'entità figlia e la generalizzazione è <b>parziale</b>.
Se ogni occorrenza è occorrenza di al massimo una delle entità figlie, allora è <b>esclusiva</b>. Altrimenti esistono occorrenze che appartengono a più figlie ed è <b>sovrapposta</b>.
Se esiste una sola entità figlia, si parla di <b>sottoinsieme</b>.
Può esistere una serie di generalizzazioni, detta <b>gerarchia</b>.
</p>


<p>
Sia cardinalità che identificatori sono vincoli di integrità su relazioni ed entità.
</p>
</div>
</div>
</div>
<div id="outline-container-org56951a6" class="outline-2">
<h2 id="org56951a6">Progettazione logica</h2>
<div class="outline-text-2" id="text-org56951a6">
<p>
Una volta creato un modello ER completo, bisogna ristrutturarlo e poi tradurlo nel modello relazionale.
</p>
</div>
<div id="outline-container-org5bff971" class="outline-3">
<h3 id="org5bff971">Ristrutturazione</h3>
<div class="outline-text-3" id="text-org5bff971">
<p>
Si basano su valutazioni legate ai parametri di carico della basi di dati. Questi parametri includono:
</p>
<ul class="org-ul">
<li>Volume dei dati, compreso numerosità delle occorrenze delle entità e quante di esse partecipano a relazioni</li>
<li>Tipo di operazioni svolte più frequentemente</li>
<li>Interattiva o batch (?)</li>
<li>Frequenza (quante operazioni per unità di tempo)</li>
</ul>

<p>
Le modifiche effettuate sono le tre seguenti:
</p>
<ul class="org-ul">
<li>Analisi dei dati derivati (eliminazione ridondanza)</li>
<li>Eliminazione delle gerarchie di generalizzazione</li>
<li>Scelta degli identificatori primari</li>
</ul>

<p>
Alcuni dati (attributi) possono essere <b>derivati</b> da altri dati già immagazzinati. In questo caso possono essere eliminati, con il vantaggio di ridurre il volume dei dati e non essere più costretti a mantenere la coerenza. Lo svantaggio è che servirà uno overhead maggiore per calcolarli. Bisogna quindi valutare il tradeoff fra il risparmio di memoria e il guadagno in efficienza nell'evitare di mantenere la coerenza rispetto all'aumento dell'overhead nel calcolare il dato ogni volta.
</p>

<p>
Le gerarchie di generalizzazione non possono essere rappresentate direttamente dal modello relazionale e quindi vanno eliminate. Ci sono 3 opzioni:
</p>
<dl class="org-dl">
<dt>mantenimento dell'entità padre</dt><dd>aggiungo l'attributo "tipo" all'entità padre, che indica a quale sottoclasse ogni occorrenza appartenga. Se la generalizzazione non è totale (ma parziale), allora può assumere valori nulli. Se le generalizzazione non è esclusiva (ma sovrapposta) allora è un attributo multivalore. Questa soluzione è sempre applicabile.
Il vantaggio è un numero minore di accessi, ma porta ad un volume maggiore perchè ci saranno degli attributi aggiuntivi e dei valori null.</dd>
<dt>mantenimento delle entità figlie</dt><dd>elimino l'entità padre e trasferisco tutti gli attributi e tutte le partecipazioni a relazione a ogni entità figlia. La generalizzazione dev'essere totale (altrimenti perderei le occorrenze solo in padre) e esclusiva (altrimenti avrei occorrenze identiche in posti separati).
Il vantaggio è di evitare l'accesso all'entità generica.</dd>
<dt>mantenimento di tutte le entità</dt><dd>introduco la relazione IS<sub>A</sub> che indica la generalizzazione. Diventa necessario che ogni occorrenza delle specializzazioni sia riflettuta nel padre, e se la generalizzazione è totale, anche il viceversa.
Sebbene si richiedono più accessi, essi hanno meno attributi è questo permette un accesso più veloce.</dd>
</dl>

<p>
Gli <b>attributi multivalore</b> in generale vengono "reificati" introducendo una nuova relazione con la stessa cardinalità dell'attributo in questione.
</p>
</div>
</div>
<div id="outline-container-orgfc04f5d" class="outline-3">
<h3 id="orgfc04f5d">Traduzione a modello relazionale</h3>
<div class="outline-text-3" id="text-orgfc04f5d">
<p>
Le <b>entità</b> vengono tradotte in relazioni (tabelle) la cui chiave primaria è l'identificatore interno.
</p>

<p>
Le <b>relazioni ER N a N</b> vengono trasformate in relazioni (tabelle) la cui chiave è l'unione delle chiavi delle entità che vi partecipano. GLi attributi aggiuntivi sono gli altri attributi e possono essere inclusi nella chiave quando se si vuole rendere possibili più relazioni fra stesse occorrenze con attributi propri della relazione diversi (es. Milan-Inter 0-0, Milan-Inter 3-1)
</p>

<p>
Le <b>relazioni ER 1 a 1</b> vengono trasformate inglobando una delle chiavi nell'altra relazione, accompagnata dagli attributi della relazione.
</p>

<p>
Le <b>relazioni 1 a N</b> sono trasformate o inglobando nell'entità con cardinalità 1 la chiave dell'altra, oppure creando una nuova relazione che contenga entrambe le chiavi e gli attributi dell'entità con cardinalità 1. In questo caso la chiave primaria è composta solo dagli attributi dell'entità con cardinalità 1, quindi si permettono più valori dell'altra.
</p>

<p>
<b>Relazioni n-arie</b>: si traducono come le relazioni N:M con una chiave esterna per ogni entità implicata nell’associazione.
<b>Relazioni ricorsive</b>: si traducono come normali associazioni ma ridenominando le chiavi esterne in modo da evidenziarne il ruolo nell’associazione.
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Tipo di Relazione</th>
<th scope="col" class="org-left">Trasformazione in Modello Relazionale</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>N:N</b></td>
<td class="org-left">Creazione di una nuova tabella con chiave primaria composta dalle chiavi delle entità partecipanti. Gli attributi della relazione diventano attributi della nuova tabella. Possono entrare nella chiave per permettere relazioni multiple tra stesse entità.</td>
</tr>

<tr>
<td class="org-left"><b>1:1</b></td>
<td class="org-left">Inglobame                                                                             mnnto di una delle chiavi nell'altra relazione, insieme agli   attributi della relazione.</td>
</tr>

<tr>
<td class="org-left"><b>1:N</b></td>
<td class="org-left">Due opzioni: (1) Inglobare nella tabella dell'entità con cardinalità 1 la chiave dell'altra entità, o (2) Creare una nuova tabella con entrambe le chiavi e gli attributi della relazione, dove la chiave primaria è solo l'attributo dell'entità con cardinalità 1.</td>
</tr>

<tr>
<td class="org-left"><b>n-arie</b></td>
<td class="org-left">Si traducono come le relazioni N:M, creando una tabella con una chiave esterna per ogni entità implicata nell'associazione.</td>
</tr>

<tr>
<td class="org-left"><b>ricorsive</b></td>
<td class="org-left">Si traducono come normali associazioni, ridenominando le chiavi esterne per evidenziare il loro ruolo specifico nell'associazione.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge62db05" class="outline-3">
<h3 id="orge62db05"><span class="todo TODO">TODO</span> Reverse Engineering</h3>
</div>
<div id="outline-container-org4489564" class="outline-3">
<h3 id="org4489564">Normalizzazione di Schemi Relazionali</h3>
<div class="outline-text-3" id="text-org4489564">
</div>
<div id="outline-container-orge38ffbb" class="outline-4">
<h4 id="orge38ffbb">Dipendenza Funzionale</h4>
<div class="outline-text-4" id="text-orge38ffbb">
<p>
Una <b>dipendenza funzionale</b> \(X \rightarrow Y\) tra due sottoinsiemi di attributi \(X\) e \(Y\) di una relazione \(R\) stabilisce un vincolo sulle ennuple che possono formare uno stato di relazione \(r\) di \(R\):
</p>

<p>
Per ogni coppia di ennuple \(t_1\) e \(t_2\) in \(r\) per cui \(t_1[X] = t_2[X]\), si ha \(t_1[Y] = t_2[Y]\), ovvero \(t_1[X] = t_2[X] \rightarrow t_1[Y] = t_2[Y]\).
</p>

<ul class="org-ul">
<li>Se \(X\) è una chiave di \(R\), allora \(X \rightarrow Y\) vale per ogni sottoinsieme \(Y\) di attributi di \(R\).</li>
<li>\(X \rightarrow Y\) <b>NON</b> implica \(Y \rightarrow X\).</li>
</ul>
</div>
</div>
<div id="outline-container-org0c3b93d" class="outline-4">
<h4 id="org0c3b93d">Regole di Inferenza sulle Dipendenze Funzionali</h4>
<div class="outline-text-4" id="text-org0c3b93d">
<ol class="org-ol">
<li><b>Regola riflessiva:</b> Se \(Y \subseteq X\), allora \(X \rightarrow Y\)</li>
<li><b>Regola di arricchimento:</b> Da \(X \rightarrow Y\), segue \(XZ \rightarrow YZ\)</li>
<li><b>Regola transitiva:</b> Da \(X \rightarrow Y\) e \(Y \rightarrow Z\), segue \(X \rightarrow Z\)</li>
<li><b>Regola di decomposizione:</b> Da \(X \rightarrow YZ\), segue \(X \rightarrow Y\) e \(X \rightarrow Z\)</li>
<li><b>Regola di unione:</b> Da \(X \rightarrow Y\) e \(X \rightarrow Z\), segue \(X \rightarrow YZ\)</li>
<li><b>Regola pseudo-transitiva:</b> Da \(X \rightarrow Y\) e \(WY \rightarrow Z\), segue \(WX \rightarrow Z\)</li>
</ol>
</div>
</div>
<div id="outline-container-orgb54d095" class="outline-4">
<h4 id="orgb54d095">Individuazione delle Dipendenze Funzionali</h4>
<div class="outline-text-4" id="text-orgb54d095">
<ul class="org-ul">
<li>È il progettista della base di dati a individuare le dipendenze funzionali in base alla conoscenza del dominio.</li>
<li>Dato un insieme iniziale di dipendenze funzionali \(F\), è possibile dedurne altre tramite le regole di inferenza.</li>
<li>L'insieme \(F^+\) delle dipendenze funzionali individuate dal progettista unito a quelle inferite si chiama <b>chiusura di \(F\)</b>.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcf483ab" class="outline-4">
<h4 id="orgcf483ab">Normalizzazione di Relazioni</h4>
<div class="outline-text-4" id="text-orgcf483ab">
<ul class="org-ul">
<li>Le <b>forme normali</b> sono proprietà delle relazioni definite con riferimento alle dipendenze funzionali, utili per evitare anomalie.</li>
<li>Se una relazione non è compatibile con una forma normale, si decompone in relazioni più piccole che rispettano la forma normale desiderata.</li>
<li>Obiettivi:
<ul class="org-ul">
<li><b>Join senza perdita:</b> la ricostruzione della relazione dalle sue parti decomposte non deve generare ennuple non inizialmente presenti.</li>
<li><b>Conservazione delle dipendenze:</b> ogni dipendenza funzionale deve essere rispettata nello schema normalizzato.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org736749d" class="outline-4">
<h4 id="org736749d">Forme Normali</h4>
<div class="outline-text-4" id="text-org736749d">
</div>
<div id="outline-container-org33e892b" class="outline-5">
<h5 id="org33e892b">Prima Forma Normale (1NF)</h5>
<div class="outline-text-5" id="text-org33e892b">
<ul class="org-ul">
<li>Uno schema di relazione \(R(X)\) è in 1NF se ogni attributo di \(X\) è semplice, cioè atomico.</li>
<li>Esclude attributi multivalore e strutturati.</li>
</ul>
</div>
</div>
<div id="outline-container-org1cad199" class="outline-5">
<h5 id="org1cad199">Seconda Forma Normale (2NF)</h5>
<div class="outline-text-5" id="text-org1cad199">
<ul class="org-ul">
<li>Risolve il problema delle <b>dipendenze parziali</b></li>
<li>Si applica a relazioni con chiave composta.</li>
<li>Una dipendenza funzionale \(X \rightarrow Y\) è <b>completa</b> se la rimozione di qualsiasi attributo da \(X\) rende la dipendenza non più valida.</li>
<li>Uno schema è in 2NF se ogni attributo non primo dipende funzionalmente in modo completo dalla chiave primaria (anche transitivamente).</li>
<li>Un attributo è <b>primo</b> se fa parte di almeno una chiave di \(R\).</li>
<li>Normalizzazione: per ogni dipendenza parziale, si crea una relazione distinta.</li>

<li>Un ruolo della chiave primaria è quello di "discernere" nella sua interezza le tuple. Come se ogni chiave rappresentasse un istanza i cui attributi sono le sue caratteristiche. (che è come dire che dalla combinnazione di attributi della chiave dipendono i valori degli altri attributi, definizione)</li>
<li>Se invece il valore di un attributo dipende soltanto da una parte della chiave, allora una chiave distinta non rappresenta più una nuova istanza, restringendo a quell'attributo</li>
<li>A stessi valori di \(X\) corrispondono stessi valori di \(Y\), sebbene la chiave sia diversa.</li>
<li>Questo causa problemi per:
<ul class="org-ul">
<li>aggiornamento: i valori ridondanti di \(Y\) vanno aggiornati tutti ogni volta</li>
<li>cancellazione: se vengono cancellati tutti i valori del resto della chiave, devo cancellare l'intera tupla (essendo chiave) e perdo anche l'associazione di \(X\) a \(Y\)</li>
<li>inserimento: non posso inserire l'informazione che ad una certa istanza di \(X\) è associato \(Y\) se non conosco già il resto della chiave</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org27a9a90" class="outline-5">
<h5 id="org27a9a90">Terza Forma Normale (3NF)</h5>
<div class="outline-text-5" id="text-org27a9a90">
<ul class="org-ul">
<li>Risolve il problema delle dipendenze ricorsive</li>
<li>Uno schema \(R\) è in 3NF se, per ogni dipendenza funzionale non banale \(X \rightarrow A\):
<ul class="org-ul">
<li>\(X\) è una superchiave, <b>oppure</b></li>
<li>\(A\) appartiene ad almeno una chiave di \(R\)</li>
<li>Ovvero, in ogni dipendenza funzionale è coinvolta almeno una chiave o parte di essa.</li>
</ul></li>
<li>Un'altra definizione è che lo schema \(R\) rispetti la 2NF <b>e</b> esiste un attributo non primo che dipende in modo transitivo dalla chiave primaria.
<ul class="org-ul">
<li>Questa forma equivale alla precedente perchè se \(X \rightarrow A\) e X non è una superchiave e A non fa parte di alcuna chiave:
<ul class="org-ul">
<li>X dipende necessariamente da K chiave perchè questo vale sempre</li>
<li>allora A dipende funzionalmente da K mediante X e quindi è transitiva</li>
</ul></li>
<li>Al contrario, se K -&gt; X -&gt; A, allora X non è una superchiave (altrimenti non potrebbe dipendere funzionalmente da K) e A non fa parte di una chiave (altrimenti sarebbe parte di K)</li>
</ul></li>
<li>La 3NF è sempre raggiungibile senza perdita e conservando le dipendenze.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc85feca" class="outline-5">
<h5 id="orgc85feca">Forma Normale di Boyce-Codd (BCNF)</h5>
<div class="outline-text-5" id="text-orgc85feca">
<ul class="org-ul">
<li>Notare che in 3NF si ammette anche il caso in cui X non è una superchiave e A invece fa parte di una chiave.
<ul class="org-ul">
<li>Abbiamo un elemento che fa parte della chiave, e quindi che collabora a determinare ogni altro attributo</li>
<li>Ma questo stesso elemento è a sua volta determinato da un altro attributo.</li>
<li><p>
Ovvero ho una situazione AB-&gt;C, C-&gt;A, dove AB è chiave
per ogni Progetto e Sede c'è un solo manager, e per ogni manager c'è una sola branch.    
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Manager (C)</th>
<th scope="col" class="org-left">Progetto (B)</th>
<th scope="col" class="org-left">Sede  (A)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Brown</td>
<td class="org-left">Mars</td>
<td class="org-left">Chicago</td>
</tr>

<tr>
<td class="org-left">Green</td>
<td class="org-left">Jupiter</td>
<td class="org-left">Birmingham</td>
</tr>

<tr>
<td class="org-left">Green</td>
<td class="org-left">Mars</td>
<td class="org-left">Birmingham</td>
</tr>

<tr>
<td class="org-left">Hoskin</td>
<td class="org-left">Saturn</td>
<td class="org-left">Birmingham</td>
</tr>
</tbody>
</table></li>
<li>Questa forma potrebbe causare problemi: c'è ridondanza perchè le colonne A e C accadono sempre insieme, in quanto dipendono l'una dall'altra. Se modifico il valore di una tupla, devo modificarlo anche per ogni altra tupla con lo stesso valore.</li>
<li>In effetti l'informazione che lega A e C esiste aldilà di questa relazione e quindi può essere scorporato.</li>
</ul></li>
<li>Uno schema \(R\) è in BCNF se, per ogni dipendenza funzionale non banale \(X \rightarrow A\), \(X\) è una superchiave.</li>
<li>Normalizzazione: decomporre \(R\) in modo che esista una relazione per ogni dipendenza, con chiave il lato sinistro della dipendenza.</li>
<li>La BCNF non è sempre raggiungibile senza perdita di dipendenze.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7ce2b50" class="outline-4">
<h4 id="org7ce2b50">Riassunto delle Proprietà della Normalizzazione</h4>
<div class="outline-text-4" id="text-org7ce2b50">
<ul class="org-ul">
<li>Una forma normale garantisce l'assenza di determinati difetti (ridondanze, anomalie di aggiornamento/inserimento/cancellazione).</li>
<li>La normalizzazione consiste nel decomporre uno schema in sottoschemi normalizzati.</li>
<li>Ogni decomposizione deve essere:
<ul class="org-ul">
<li><b>Senza perdita</b>, cioè permettere la ricostruzione esatta della relazione originaria.</li>
<li><b>Conservativa delle dipendenze</b>, per evitare query complesse di verifica dei vincoli.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7309663" class="outline-4">
<h4 id="org7309663">Esempio di Decomposizione in 3NF</h4>
<div class="outline-text-4" id="text-org7309663">
<p>
Supponiamo di avere lo schema \(R(ABCDEFG)\) con le seguenti dipendenze funzionali:
</p>
<ul class="org-ul">
<li>\(AB \rightarrow CD\)</li>
<li>\(AB \rightarrow E\)</li>
<li>\(C \rightarrow F\)</li>
<li>\(F \rightarrow G\)</li>
</ul>

<p>
La decomposizione in 3NF produrrà:
</p>
<ul class="org-ul">
<li>\(R_1(ABCDE)\)</li>
<li>\(R_2(CF)\)</li>
<li>\(R_3(FG)\)</li>
</ul>

<p>
Alla fine si verifica che almeno una relazione contenga una chiave della relazione originaria.
</p>
</div>
</div>
<div id="outline-container-orge2afa43" class="outline-4">
<h4 id="orge2afa43">Note Finali</h4>
<div class="outline-text-4" id="text-orge2afa43">
<ul class="org-ul">
<li>La <b>terza forma normale</b> è meno restrittiva della BCNF e può ammettere ancora qualche anomalia, ma garantisce sempre la conservazione delle dipendenze.</li>
<li>Se una relazione ha una sola chiave, allora è in BCNF se e solo se è in 3NF.</li>
<li>La normalizzazione è una tecnica di verifica degli schemi, non una metodologia di progettazione.</li>
</ul>
</div>
<div id="outline-container-orgcdfc43f" class="outline-5">
<h5 id="orgcdfc43f">Verifica di correttezza</h5>
<div class="outline-text-5" id="text-orgcdfc43f">
<p>
Le informazioni presentate nel testo sono corrette e riflettono accuratamente la teoria della normalizzazione degli schemi relazionali. In particolare:
</p>

<ul class="org-ul">
<li>Le definizioni delle forme normali sono precise</li>
<li>Le regole di inferenza rappresentano l'insieme completo degli assiomi di Armstrong</li>
<li>L'esempio di decomposizione fornito è corretto</li>
<li>È vero che la 3NF è sempre raggiungibile preservando dipendenze e senza perdita di informazione</li>
<li>È corretto che la BCNF è più restrittiva ma non sempre garantisce la conservazione delle dipendenze</li>
</ul>

<p>
La frase conclusiva "Normalizzare uno schema significa decomporlo in sottoschemi; ogni decomposizione deve essere senza perdita e, preferibilmente, conservare le dipendenze funzionali" sintetizza accuratamente il concetto di normalizzazione.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8478db7" class="outline-3">
<h3 id="org8478db7">Progettazione Fisica: Strutture e Metodi d'Accesso ai Dati su Disco</h3>
<div class="outline-text-3" id="text-org8478db7">
</div>
<div id="outline-container-orgafde17f" class="outline-4">
<h4 id="orgafde17f">DBMS e sistema operativo</h4>
<div class="outline-text-4" id="text-orgafde17f">
<ul class="org-ul">
<li>I dati sono memorizzati su memoria secondaria per garantire persistenza</li>
<li>L'organizzazione avviene in blocchi di dimensione fissa</li>
<li>L'elaborazione avviene in memoria principale</li>
<li>Il buffer:
<ul class="org-ul">
<li>Gestisce i dati in memoria principale</li>
<li>Applica strategie per minimizzare i trasferimenti da/verso la memoria secondaria</li>
<li>È organizzato in pagine di dimensione X blocchi</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0ca3ea3" class="outline-4">
<h4 id="org0ca3ea3">Fattore di blocco</h4>
<div class="outline-text-4" id="text-org0ca3ea3">
<ul class="org-ul">
<li>Il fattore di blocco (bfr) rappresenta il numero di record per blocco</li>
<li>Formula: \[bfr = \left\lfloor \frac{B}{R} \right\rfloor\]
dove \(B\) è la dimensione del blocco e \(R\) è la dimensione media del record</li>
<li>I record possono essere a lunghezza fissa o variabile</li>
</ul>
</div>
</div>
<div id="outline-container-org03b1d15" class="outline-4">
<h4 id="org03b1d15">Strutture primarie dei file</h4>
<div class="outline-text-4" id="text-org03b1d15">
<ul class="org-ul">
<li>Determinano la disposizione delle tuple/record nei file</li>
<li>Si distinguono per metodo d'accesso:
<ul class="org-ul">
<li>Sequenziale (non ordinato, ad array, ordinato)</li>
<li>Calcolato (hash)</li>
<li>Albero</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga8e47af" class="outline-4">
<h4 id="orga8e47af">Strutture ad accesso sequenziale</h4>
<div class="outline-text-4" id="text-orga8e47af">
</div>
<div id="outline-container-orgc1e8f0b" class="outline-5">
<h5 id="orgc1e8f0b">Struttura non ordinata (file heap)</h5>
<div class="outline-text-5" id="text-orgc1e8f0b">
<ul class="org-ul">
<li>Sequenza basata sull'ordine di inserimento</li>
<li>Inserimento efficiente</li>
<li>Ricerca lineare</li>
<li>Cancellazione logica</li>
</ul>
</div>
</div>
<div id="outline-container-org9954a3f" class="outline-5">
<h5 id="org9954a3f">Struttura sequenziale ad array</h5>
<div class="outline-text-5" id="text-org9954a3f">
<ul class="org-ul">
<li>Solo con record a lunghezza fissa</li>
<li>Ogni tupla ha un indice che ne determina la posizione</li>
</ul>
</div>
</div>
<div id="outline-container-org8c2c3d1" class="outline-5">
<h5 id="org8c2c3d1">Struttura sequenziale ordinata</h5>
<div class="outline-text-5" id="text-org8c2c3d1">
<ul class="org-ul">
<li>Ordinamento fisico basato su chiave (pseudochiave)</li>
<li>Efficiente per ricerche sul campo chiave</li>
<li>Richiede indici per ricerche efficienti</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbc1ddf4" class="outline-4">
<h4 id="orgbc1ddf4">Strutture ad accesso calcolato (hash)</h4>
<div class="outline-text-4" id="text-orgbc1ddf4">
<ul class="org-ul">
<li>La posizione dipende dal valore di un campo chiave</li>
<li>Utilizza una funzione hash \(h\) per calcolare la posizione</li>
<li>Efficiente per ricerca puntuale, inefficiente per intervalli</li>
<li>Richiede gestione delle collisioni</li>
</ul>
</div>
</div>
<div id="outline-container-org2399872" class="outline-4">
<h4 id="org2399872">Alberi (indici)</h4>
<div class="outline-text-4" id="text-org2399872">
</div>
<div id="outline-container-orgbb93c2c" class="outline-5">
<h5 id="orgbb93c2c">Indici primari</h5>
<div class="outline-text-5" id="text-orgbb93c2c">
<ul class="org-ul">
<li>Contengono i dati della relazione</li>
<li>Garantiscono accesso basato sulla pseudochiave</li>
<li>Ogni voce contiene valore della pseudochiave e puntatore</li>
<li>Sono sempre indici sparsi (una voce per blocco)</li>
</ul>
</div>
</div>
<div id="outline-container-org9a90d3b" class="outline-5">
<h5 id="org9a90d3b">Indici secondari</h5>
<div class="outline-text-5" id="text-org9a90d3b">
<ul class="org-ul">
<li>Forniscono struttura di accesso aggiuntiva</li>
<li>Sono sempre densi (una voce per valore chiave)</li>
<li>Possono riferirsi a campi non chiave (con gestione dei duplicati)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org434d37c" class="outline-4">
<h4 id="org434d37c">Considerazioni sugli indici</h4>
<div class="outline-text-4" id="text-org434d37c">
<ul class="org-ul">
<li>Un file può avere un solo indice primario</li>
<li>Può avere numerosi indici secondari</li>
<li>Gli indici sono file di piccole dimensioni</li>
<li>Rendono efficienti le ricerche</li>
<li>Hanno tempi di accesso logaritmico</li>
</ul>
</div>
</div>
<div id="outline-container-org4a455f1" class="outline-4">
<h4 id="org4a455f1">Alberi di ricerca</h4>
<div class="outline-text-4" id="text-org4a455f1">
<ul class="org-ul">
<li>Un albero di ordine \(p\) ha nodi con massimo \(p-1\) valori e \(p\) puntatori</li>
<li>È importante mantenere il bilanciamento per ricerche efficienti</li>
</ul>

<p>
Questa struttura organizza i dati fisici per ottimizzare l'accesso, minimizzando le operazioni di I/O e migliorando l'efficienza del database.
</p>
</div>
</div>
<div id="outline-container-orgc189ed7" class="outline-4">
<h4 id="orgc189ed7">Tips</h4>
<div class="outline-text-4" id="text-orgc189ed7">
<ul class="org-ul">
<li>Inserire una chiave id quando l'entità non abbia una chiave esplicita</li>
<li>Quando un attributo di una relazione vuole essere usato come chiave (non possibile normalmente), trasformarlo in un entità che partecipa alla stessa relazione, che quindi diventa molteplice</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc40ce0a" class="outline-2">
<h2 id="orgc40ce0a">Progetto</h2>
<div class="outline-text-2" id="text-orgc40ce0a">
</div>
<div id="outline-container-org266508c" class="outline-3">
<h3 id="org266508c">Usare bootstrap con supporto SAAS (forse)</h3>
</div>
<div id="outline-container-orgd3753a8" class="outline-3">
<h3 id="orgd3753a8">Presentazione</h3>
<div class="outline-text-3" id="text-orgd3753a8">
</div>
<div id="outline-container-orgc7e7fa6" class="outline-4">
<h4 id="orgc7e7fa6">La discussione serve per capire quello che c'è dietro</h4>
<div class="outline-text-4" id="text-orgc7e7fa6">
</div>
<div id="outline-container-orga256f47" class="outline-5">
<h5 id="orga256f47">Giustificare le scelte</h5>
<div class="outline-text-5" id="text-orga256f47">
</div>
<div id="outline-container-orgf20ed8d" class="outline-6">
<h6 id="orgf20ed8d">Come scrivere un trigger in un altro modo?</h6>
</div>
<div id="outline-container-org5d6a9fd" class="outline-6">
<h6 id="org5d6a9fd">Domande su viste</h6>
</div>
</div>
</div>
<div id="outline-container-orge364219" class="outline-4">
<h4 id="orge364219">La parte di progettazione è importante</h4>
<div class="outline-text-4" id="text-orge364219">
</div>
<div id="outline-container-org9d8e77e" class="outline-5">
<h5 id="org9d8e77e">DDL, progettazione degli schema, integrità referenziale</h5>
</div>
</div>
<div id="outline-container-orgf08af85" class="outline-4">
<h4 id="orgf08af85">Specifiche</h4>
<div class="outline-text-4" id="text-orgf08af85">
</div>
<div id="outline-container-orgbf8816e" class="outline-5">
<h5 id="orgbf8816e">Non è detto che il manager sia il responsabile, sono due cose diverse</h5>
</div>
<div id="outline-container-org0bc5694" class="outline-5">
<h5 id="org0bc5694">Informazioni di tipo testuale suggerisce il tipo di dominio da usare</h5>
</div>
<div id="outline-container-org0a8ccfa" class="outline-5">
<h5 id="org0a8ccfa">Il prezzo di un prodotto non dipende dal prodotto stesso, ma dal prodotto e dal negozio in cui è in vendita</h5>
</div>
<div id="outline-container-orgd1c2601" class="outline-5">
<h5 id="orgd1c2601">I clienti possono acquistare da negozi diversi nella stessa fattura</h5>
</div>
<div id="outline-container-orgda40b9e" class="outline-5">
<h5 id="orgda40b9e">Anche i fornitori forniscono prezzi diversi</h5>
</div>
<div id="outline-container-org1dbd577" class="outline-5">
<h5 id="org1dbd577">Un cliente può avere o non avere una tessera. La tessera è associata ad un negozio specifico e il cliente può averne una sola.</h5>
<div class="outline-text-5" id="text-org1dbd577">
</div>
<div id="outline-container-orgda52999" class="outline-6">
<h6 id="orgda52999">È importante tenere traccia la data e il negozio in cui è stata effettuata</h6>
</div>
</div>
<div id="outline-container-org0eb19a0" class="outline-5">
<h5 id="org0eb19a0">Queste sono le specifiche che dobbiamo tener presente quando progettiamo lo schema concettuale e passiamo a quello logico</h5>
</div>
</div>
<div id="outline-container-orgc7d5baf" class="outline-4">
<h4 id="orgc7d5baf">2.2</h4>
<div class="outline-text-4" id="text-orgc7d5baf">
</div>
<div id="outline-container-orga0b64f6" class="outline-5">
<h5 id="orga0b64f6">Tutto implementato con viste, viste materializzate, funzioni, trigger, procedure</h5>
</div>
<div id="outline-container-org60a3aee" class="outline-5">
<h5 id="org60a3aee">Applicazione sconto</h5>
<div class="outline-text-5" id="text-org60a3aee">
</div>
<div id="outline-container-org55353f6" class="outline-6">
<h6 id="org55353f6">Sono un cliente, faccio un acquisto, decido di usare lo sconto del 15%, mi viene proposto di applicare lo sconto</h6>
</div>
<div id="outline-container-org1e1aa51" class="outline-6">
<h6 id="org1e1aa51">Si può usare un solo sconto per acquisto (si può fare anche diversamente ma va motivato)</h6>
</div>
</div>
<div id="outline-container-org972a1c7" class="outline-5">
<h5 id="org972a1c7">Ordine prodotti da fornitore</h5>
<div class="outline-text-5" id="text-org972a1c7">
</div>
<div id="outline-container-orgb74e63b" class="outline-6">
<h6 id="orgb74e63b">Mentre il cliente sceglie autonomamente il negozio da cui comprare, il fornitore di un negozio è scelto sulla base di un criterio di economicità</h6>
</div>
</div>
<div id="outline-container-org9c2b875" class="outline-5">
<h5 id="org9c2b875">L'elenco dei saldi punti &gt; 300 dev'essere mantenuto e non calcolato a volo</h5>
</div>
</div>
<div id="outline-container-orgafdf17b" class="outline-4">
<h4 id="orgafdf17b">Consegna</h4>
<div class="outline-text-4" id="text-orgafdf17b">
</div>
<div id="outline-container-org0550496" class="outline-5">
<h5 id="org0550496">Due folder, una con il dump (non in esadecimale ma in testo) e l'altro è l'insieme delle pagine pgp</h5>
</div>
</div>
<div id="outline-container-org762d0bd" class="outline-4">
<h4 id="org762d0bd">Struttura orale</h4>
<div class="outline-text-4" id="text-org762d0bd">
</div>
<div id="outline-container-org7743b1c" class="outline-5">
<h5 id="org7743b1c">Ci lascia 5 minuti per mostrare le funzionalità principali o pirotecniche</h5>
</div>
<div id="outline-container-orga7e0150" class="outline-5">
<h5 id="orga7e0150">Ci fa domande sul codice sorgente, fa fare qualche modifica</h5>
</div>
<div id="outline-container-org98714eb" class="outline-5">
<h5 id="org98714eb">Guardiamo la progettazione e la correggiamo</h5>
</div>
<div id="outline-container-org0bfa77f" class="outline-5">
<h5 id="org0bfa77f">Qualche domandina su PHP</h5>
</div>
</div>
<div id="outline-container-org77afa91" class="outline-4">
<h4 id="org77afa91">Pg query non va usato, ma si usa prepare and execute</h4>
</div>
</div>
<div id="outline-container-org3a200d5" class="outline-3">
<h3 id="org3a200d5">Tabelle derivate (trigger) o materialized view?</h3>
<div class="outline-text-3" id="text-org3a200d5">
<p>
Materialized view, ma le tabelle derivate mostrano che si sa come funziona. Comunque bisogna sapere come fare con le tabelle derivate. (Domanda classica)
</p>
</div>
</div>
<div id="outline-container-orgd53ed62" class="outline-3">
<h3 id="orgd53ed62">PGquery non va usato, ma va usato pg<sub>prepare</sub> e pg<sub>execute</sub> (o anche pg<sub>query</sub> params)</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-06-07 Sat 16:49</p>
</div>
</body>
</html>
