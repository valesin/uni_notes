<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2025-05-30 Fri 07:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Basi di dati</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" onerror="this.onerror=null;this.href='local.css';" />
<script>
    window.MathJax = {
      tex: {
        ams: { multlineWidth: '85%' },
        {packages: {'[+]': ['mathtools']}},
        tags: 'ams',
        tagSide: 'right',
        tagIndent: '.8em'
      },
      chtml: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      svg: {
        scale: 1.0,
        displayAlign: 'center',
        displayIndent: '0em'
      },
      output: {
        font: 'mathjax-modern',
        displayOverflow: 'scale'
      },
      loader: {
        load: ['[tex]/mathtools']
      },
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Basi di dati</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9b561b0">Modello relazionale</a></li>
<li><a href="#orge905b20">Algebra relazionale (59 pdf atzeni)</a>
<ul>
<li><a href="#orgf4583ea"><span class="todo TODO">TODO</span> Equivalenza fra espressioni e ottimizzazione</a></li>
<li><a href="#org61f7db3">Viste</a></li>
</ul>
</li>
<li><a href="#org41cc0cf">SQL</a>
<ul>
<li><a href="#orga4ab0e8">Istruzioni</a>
<ul>
<li><a href="#orge4785da">SELECT</a></li>
<li><a href="#org848cd8a">Operatori aggregati</a></li>
<li><a href="#orgab9516d">Raggruppamento</a></li>
<li><a href="#org0362afe">Operatori insiemistici</a></li>
<li><a href="#org27d8067">Interrogazioni nidificate</a></li>
<li><a href="#org5f75e49"><span class="todo TODO">TODO</span> Continuare da 4.3.7</a></li>
</ul>
</li>
<li><a href="#org2ebdc19">Programma</a></li>
<li><a href="#orga17ab93">Domini elementari</a></li>
</ul>
</li>
<li><a href="#org618fc09">Modello Entità Relazione (progettazione concettuale)</a>
<ul>
<li><a href="#org6747221">Costrutti di base (entità, relazioni, attributi)</a></li>
</ul>
</li>
<li><a href="#org56951a6">Progettazione logica</a>
<ul>
<li><a href="#orgca2d74e">Ristruttazione</a></li>
<li><a href="#orgfc04f5d">Traduzione a modello relazionale</a></li>
<li><a href="#orge62db05"><span class="todo TODO">TODO</span> Reverse Engineering</a></li>
</ul>
</li>
<li><a href="#orgc40ce0a">Progetto</a>
<ul>
<li><a href="#org266508c">Usare bootstrap con supporto SAAS (forse)</a></li>
<li><a href="#orgd3753a8">Presentazione</a>
<ul>
<li><a href="#orgc7e7fa6">La discussione serve per capire quello che c'è dietro</a>
<ul>
<li><a href="#orga256f47">Giustificare le scelte</a>
<ul>
<li><a href="#orgf20ed8d">Come scrivere un trigger in un altro modo?</a></li>
<li><a href="#org5d6a9fd">Domande su viste</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge364219">La parte di progettazione è importante</a>
<ul>
<li><a href="#org9d8e77e">DDL, progettazione degli schema, integrità referenziale</a></li>
</ul>
</li>
<li><a href="#orgf08af85">Specifiche</a>
<ul>
<li><a href="#orgbf8816e">Non è detto che il manager sia il responsabile, sono due cose diverse</a></li>
<li><a href="#org0bc5694">Informazioni di tipo testuale suggerisce il tipo di dominio da usare</a></li>
<li><a href="#org0a8ccfa">Il prezzo di un prodotto non dipende dal prodotto stesso, ma dal prodotto e dal negozio in cui è in vendita</a></li>
<li><a href="#orgd1c2601">I clienti possono acquistare da negozi diversi nella stessa fattura</a></li>
<li><a href="#orgda40b9e">Anche i fornitori forniscono prezzi diversi</a></li>
<li><a href="#org1dbd577">Un cliente può avere o non avere una tessera. La tessera è associata ad un negozio specifico e il cliente può averne una sola.</a>
<ul>
<li><a href="#orgda52999">È importante tenere traccia la data e il negozio in cui è stata effettuata</a></li>
</ul>
</li>
<li><a href="#org0eb19a0">Queste sono le specifiche che dobbiamo tener presente quando progettiamo lo schema concettuale e passiamo a quello logico</a></li>
</ul>
</li>
<li><a href="#orgc7d5baf">2.2</a>
<ul>
<li><a href="#orga0b64f6">Tutto implementato con viste, viste materializzate, funzioni, trigger, procedure</a></li>
<li><a href="#org60a3aee">Applicazione sconto</a>
<ul>
<li><a href="#org55353f6">Sono un cliente, faccio un acquisto, decido di usare lo sconto del 15%, mi viene proposto di applicare lo sconto</a></li>
<li><a href="#org1e1aa51">Si può usare un solo sconto per acquisto (si può fare anche diversamente ma va motivato)</a></li>
</ul>
</li>
<li><a href="#org972a1c7">Ordine prodotti da fornitore</a>
<ul>
<li><a href="#orgb74e63b">Mentre il cliente sceglie autonomamente il negozio da cui comprare, il fornitore di un negozio è scelto sulla base di un criterio di economicità</a></li>
</ul>
</li>
<li><a href="#org9c2b875">L'elenco dei saldi punti &gt; 300 dev'essere mantenuto e non calcolato a volo</a></li>
</ul>
</li>
<li><a href="#orgafdf17b">Consegna</a>
<ul>
<li><a href="#org0550496">Due folder, una con il dump (non in esadecimale ma in testo) e l'altro è l'insieme delle pagine pgp</a></li>
</ul>
</li>
<li><a href="#org762d0bd">Struttura orale</a>
<ul>
<li><a href="#org7743b1c">Ci lascia 5 minuti per mostrare le funzionalità principali o pirotecniche</a></li>
<li><a href="#orga7e0150">Ci fa domande sul codice sorgente, fa fare qualche modifica</a></li>
<li><a href="#org98714eb">Guardiamo la progettazione e la correggiamo</a></li>
<li><a href="#org0bfa77f">Qualche domandina su PHP</a></li>
</ul>
</li>
<li><a href="#org77afa91">Pg query non va usato, ma si usa prepare and execute</a></li>
</ul>
</li>
<li><a href="#org3a200d5">Tabelle derivate (trigger) o materialized view?</a></li>
<li><a href="#orgd53ed62">PGquery non va usato, ma va usato pg<sub>prepare</sub> e pg<sub>execute</sub> (o anche pg<sub>query</sub> params)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org9b561b0" class="outline-2">
<h2 id="org9b561b0">Modello relazionale</h2>
<div class="outline-text-2" id="text-org9b561b0">
<p>
Un'<b>entità</b> rappresenta un oggetto o concetto del mondo reale.
</p>

<p>
Un <b>attributo</b> rappresenta una proprietà di interesse che descrive ulteriormente un'entità. Il <b>dominio</b> è l'insieme di possibili valori sui quali sono definiti degli attributi (es. interi, stringhe). In un sistema tabellare corrisponde alle intestazioni delle colonne.
</p>

<p>
Una <b>relazione</b> tra due o più entità rappresenta un'associazione tra le entità. Formalmente è definita come <b>sottoinsieme</b> del <b>prodotto cartesiano</b> dei <b>domini</b> degli <b>attributi</b> sui quali è definita la relazione. In un sistema tabellare corrisponde alla singola tabella.
</p>

<p>
Una <b>tupla</b> in una relazione è un record (entrata) i cui valori sono posizionalmente coerenti con i domini della relazione. In un sistema tabellare corrisponde alla singola entrata.
</p>

<p>
Uno <b>schema</b> è la descrizione di un database (aspetto <b>intensionale</b>) e viene specificato durante la progettazione del database. Si prevede che non cambi frequentemente. L'<b>istanza</b> invece è l'insieme di valori attuali (aspetto <b>estensionale</b>) e cambia rapidamente.
</p>

<p>
Viene definito il valore <b>NULL</b> che ha un significato semantico doppio: dato <b>inesistente/non applicabile</b> oppure <b>dato esistente ma sconosciuto</b>. I due significati sono indistinguibili.
</p>

<p>
Un <b>vincolo di integrità</b> è una proprietà che deve essere soddisfatta da un <b>istanza</b> ed è in forma di <b>predicato</b> logico.
</p>

<p>
Un vincolo è <b>intrarelazionale</b> se il suo soddisfacimento è definito rispetto a singole relazioni della base di dati, mentre è <b>interrelazionale</b> se coinvolge più relazioni.
</p>

<p>
In particolare è <b>di tupla</b> se è valutato sulla singola tupla indipendetemente dalle altre e <b>di dominio</b>, quando restringe il valore del <b>singolo attributo</b>.
</p>

<p>
Fra i vincoli <b>intrarelazionali</b> il più importante è quello <b>di chiave</b>.
</p>

<p>
Una <b>superchiave</b> è un insieme di attributi che identifica univocamente ogni tupla in una relazione. Formalmente, dato uno schema di relazione \(R(A_1, A_2, \ldots, A_n)\), un insieme di attributi \(K \subseteq \{A_1, A_2, \ldots, A_n\}\) è una superchiave per \(R\) se e solo se
\[ \forall t_1, t_2 \in r(R) : t_1 \neq t_2 \Rightarrow t_1[K] \neq t_2[K] \]
Dove \(r(R)\) è un'istanza della relazione \(R\), e \(t[K]\) denota la proiezione della tupla \(t\) sugli attributi in \(K\).
Una <b>superchiave</b> ha la proprietà di <b>identificazione univoca</b>, ovvero garantisce che non esistano tuple distinte con stessi valori negli attributi chiave.
L'insieme di tutti gli attributi è sempre superchiave, perchè non possono esistere più tuple con gli stessi valori.
</p>

<p>
Una <b>chiave</b> \(K\) è una superchiave <b>minimale</b>, ovvero tale per cui \(K\subseteq S\) e non esiste un'altra chiave \(K' \subseteq K\).
</p>

<p>
Una <b>chiave minimale</b> è una chiave che <b>non ammette</b> valori <code>NULL</code>. Rispetta le proprietà di integrità, minimalità e non nullità.
</p>

<p>
Fra i vincoli <b>interrelazionali</b>, il più importante è quello di <b>integrità referenziale</b>.
Un <b>vincolo di integrità referenziale</b> fra un insieme di attributi \(X\) (detto <b>foreign key</b>) di una relazione \(R_1\) e un'altra relazione \(R_2\) è soddisfatto se i valori \(X\) di ciascuna tupla di \(R_1\) compaiono come attributi in \(R_2\).
</p>
</div>
</div>
<div id="outline-container-orge905b20" class="outline-2">
<h2 id="orge905b20">Algebra relazionale (59 pdf atzeni)</h2>
<div class="outline-text-2" id="text-orge905b20">
<p>
Operazioni:
</p>
<dl class="org-dl">
<dt>Insiemistiche</dt><dd>definite sullo stesso insieme di attributi
<dl class="org-dl">
<dt>Unione</dt><dd>restituisci tuple che appartengono all'una, all'altra o ad entrambe le relazioni;</dd>
<dt>Differenza</dt><dd>le tuple che appartengono alla prima ma non alla seconda relazione;</dd>
<dt>Intersezione</dt><dd>le tuple che appartengono sia all'una che all'altra relazione. Definibile mediante l'unione e la differenza, infatti \(r\cap s = r - (r - s)\)</dd>
</dl></dd>
<dt>Ridenominazione</dt><dd>modifica lo schema, sostituendo il nome di un attributo con un altro. Si indica con \(\rho_{B_1...B_k\leftarrow A_1...A_k}(r)\). Viene usata per rendere i nomi di attributi uguali per effettuare operazioni che lo richiedono.</dd>
<dt>Selezione</dt><dd>sia \(F\) una <b>formula proposizionale</b>, ovvero combinando confronti mediante AND, OR e NOT, allora \(\sigma_F(r)\) produce una relazione con <b>stessi attributi</b> e contenente <b>soltanto le *tuple</b> di \(r\) per cui \(F\) è vera .</dd>
<dt>Proiezione</dt><dd>$&pi;<sub>A<sub>1&#x2026;A</sub><sub>k</sub></sub>(r) riduce gli attributi della relazione \(r\). Il numero di tuple è uguale se il gruppo di attributi proiettati è superchiave, altrimenti più tuple collassano (perchè si trovano ad avere i valori per gli attributi proiettati diversi).</dd>
<dt>Join</dt><dd>permette di correlare dati contenuti in relazioni diverse
<dl class="org-dl">
<dt>Join naturale</dt><dd><p>
produce una relazione che ha come attributi l'unione degli attributi e combinando le tuple degli operandi con valori uguali su attributi comuni. Può essere ottenuto mediante la proiezione, la selezione e il prodotto cartesiano, in questo modo \(R\bowtie S = \pi_{A_1,A_2,...,A_n}(\sigma_C (R \times S))\), dove la condizione \(C\) è quella che pone come uguali gli attributi comuni e gli attributi proiettati sono tutti, senza duplicati.
</p>

<p>
Il grado della relazione può essere \(0\) se non esistono tuple con valori uguali su gli attributi comuni agli operandi, o il prodotto delle cardinalità se tutte le tuple hanno gli stessi valori.
</p></dd>
<dt>Join esterno</dt><dd>si comporta come il join naturale, ma nel caso in cui per un certo valore dell'attributo comune non esista una controparte nell'altra tabella, la tupla viene inserita lo stesso, inserendo valori null per l'altra relazione. Esistono le varianti destra, sinistra e full, che preservano i valori di di uno, l'altro o entrambi i lati anche quando manca una controparte.</dd>
<dt>Semi join</dt><dd>restituisce le tuple che partecipano ad una join con un altra tabella, senza restituire i valori dell'altra tabella. Non è altro che una proiezione sugli attributi di \(X_1\) del join fra \(r_1\) e \(r_2\)</dd>
<dt>Theta join</dt><dd>un prodotto cartesiano, come il join senza attributi comuni, seguito da una selezione. Spesso è l'unico join disponibile nei sistemi reali, in quanto non sempre vengono usati nomi per identificare gli attributi. Per ottenere un operazione con lo stesso risultato del join naturale, si fa così: 1. ridenomina gli attributi per renderli tutti diversi 2. effettua una theta join dove la condizione è quella che i valori per gli attributi precedentemente comuni, appena rinominati, siano uguali nelle due relazioni 3. proietta gli attributi eliminando i doppioni</dd>
</dl></dd>
<dt>Divisione</dt><dd><p>
il contrario del prodotto cartesiano. Se date due tabelle, il prodotto cartesiano restituisce tutte le tuple della prima concatenate con tutte le tuple dell'altra, la divisione prende una tabella composta da più attributi, una tabella che contiene un sottoinsieme degli attributi del dividendo e resituisce una tabella che contiene i soli restanti attributi, soltanto quando questi siano associati a ogni valore del divisore.
In sostanza, si buttano via i campi che non sono associati a ogni campo del divisore e si restituisce la proiezione sui campi della dividendo ma non del divisore.
</p>

<p>
È utile per trovare in una tabella soltanto i campi che sono associati ad <b>ogni</b> valore di un altra tabella.
</p>

<p>
Si ottiene con la seguente sequenza di operazioni:
</p>
<ul class="org-ul">
<li>proietta soltanto gli attributi del dividendo non presenti nel divisore</li>
<li>costruisci il prodotto cartesiano di tale proiezione e il dividendo, ovvero</li>
<li>sottrai dal prodotto cartesiano il divisore. A questo punto ottengo tutte le tuple che contengono i valori del dividendo che <b>non</b> erano associati a ogni valore del divisore (altrimenti sarebbero scomparsi con la divisione)</li>
<li>proietta dal risultato ottenuto soltanto gli attributi del dividendo (in questo modo la tabella collassa e conterrà i soli valori non comuni)</li>
<li><p>
sottrai il valore così ottenuto dalla proiezione sui soli attributi non comuni del dividendo
</p>

<p>
\[
   \pi_X(R) - \pi_X\left((\pi_X(R) \times S) - R\right)
   \]
</p></li>
</ul></dd>
</dl>
</div>
<div id="outline-container-orgf4583ea" class="outline-3">
<h3 id="orgf4583ea"><span class="todo TODO">TODO</span> Equivalenza fra espressioni e ottimizzazione</h3>
</div>
<div id="outline-container-org61f7db3" class="outline-3">
<h3 id="org61f7db3">Viste</h3>
<div class="outline-text-3" id="text-org61f7db3">
<p>
Brevemente, sono delle relazioni virtuali definite in base ad altre. Quando viene effettuata un'interrogazione su esse, viene in realtà sostituito ad essa il suo vero contenuto. I vantaggi sono di nascondere complessità, garantire sicurezza garantendo accesso soltanto ad alcune viste, oppure mantenere la compatibilità (se una relazione viene eliminata ma è ancora derivabile, definire una vista permette di lasciare il codice uguale).
</p>

<p>
L'aggiornamento di viste è delicato perchè un aggiornamento della vista non è univoco nelle relazioni originali (potrebbero esserci dei campi che sono stati ignorati)
</p>
</div>
</div>
</div>
<div id="outline-container-org41cc0cf" class="outline-2">
<h2 id="org41cc0cf">SQL</h2>
<div class="outline-text-2" id="text-org41cc0cf">
<p>
SQL è un linguaggio <b>dichiarativo</b> e non funzionale, ovvero è basato sulla descrizione dell'obiettivo dell'operazione e non del suo svolgimento. L'interprete SQL del DBMS analizza l'istruzione e formula un'interrogazione equivalente, possibilmente ottimizzata, nel suo linguaggio procedurale interno, nascosto all'utente
</p>
</div>
<div id="outline-container-orga4ab0e8" class="outline-3">
<h3 id="orga4ab0e8">Istruzioni</h3>
<div class="outline-text-3" id="text-orga4ab0e8">
</div>
<div id="outline-container-orge4785da" class="outline-4">
<h4 id="orge4785da">SELECT</h4>
<div class="outline-text-4" id="text-orge4785da">
<p>
L'istruzione <code>SELECT ListaAttributi FROM ListaTabelle [WHERE Condizione]</code> permette di estrarre delle righe dalle relazione indicate in base alla condizione.
</p>

<p>
Questa istruzione crea il prodotto cartesiano della lista tabelle, ne filtra le righe secondo la condizione e poi proietta gli attributi indicati come primo argomento.
</p>

<p>
Per fare pattern matching di stringhe si usa la clausola <code>LIKE</code>, di solito usando una regex con %, che indica un numero variabile di caratteri, del tipo <code>LIKE '%parola%'</code>.
</p>

<p>
La clausola <code>AS</code> permette di effettuare la ridenominazione di un attributo o di una relazione.
</p>

<p>
A differenza dell'algebra relazionale, se il restringimento degli attributi comporta valori ripetuti, questi vengono comunque mostrati. Per avere valori distinti si specifica <code>SELECT DISTINCT</code>
</p>

<p>
Una sintassi alternativa è <code>SELECT ListaAttributi FROM Tabella [TIPO JOIN] JOIN Tabella ON Condizione</code>, che si comporta come una select con clausola WHERE ma rispecchia più da vicino il theta-join dell'algebra relazionale. I tipi di JOIN ammessi sono INNER (default), RIGHT OUTER, LEFT OUTER, FULL OUTER (o anche solo FULL).
</p>

<p>
Per includere o escludere i <code>null</code> si usa <code>Attributo is [not] null</code>
</p>

<p>
Per ordinare si usa la clausola <code>ORDER BY AttributiDaOrdinare [ asc | desc ]</code> con attributi multipli separati da virgole.
</p>
</div>
</div>
<div id="outline-container-org848cd8a" class="outline-4">
<h4 id="org848cd8a">Operatori aggregati</h4>
<div class="outline-text-4" id="text-org848cd8a">
<p>
Permettono di esprimere proprietà possedute da più tuple, ad esempio la cardinalità, altrimenti inesprimibili mediante l'algebra relazionale.
</p>

<p>
<code>COUNT([DISTINCT|ALL Attributi)</code>, che conta il numero di righe per Attributi considerando o meno i duplicati e senza contare i NULL, oppure <code>COUNT( * )</code> che considera anche i NULL
</p>

<p>
Gli altri operatori aggregati sono <code>sum</code>, <code>max</code>, <code>min</code>, <code>avg</code>, che usano la stessa sintassi di count eccetto l'asterisco.
</p>
</div>
</div>
<div id="outline-container-orgab9516d" class="outline-4">
<h4 id="orgab9516d">Raggruppamento</h4>
<div class="outline-text-4" id="text-orgab9516d">
<p>
Gli operatori aggregati lavorano su un insieme di righe. Per dividere la tabella in sottogruppi e applicarvi le funzioni aggregate.
</p>

<p>
La clausola <code>GROUP BY Attributo</code> in una SELECT divide la tabella in vari gruppi, ognuno caratterizzato da un certo valore di Attributo.
</p>

<p>
<code>SELECT AttributoDaDividere, aggregato(AltroAttributo) FROM Tabella GROUP BY AttributoDaDividere</code> restituisce l'operatore aggregato applicato ai gruppi in cui la tabella è stata divisa
</p>

<p>
Quando si vuole considerare soltanto alcuni dei gruppi in base a una certa condizione, si usa la clausola <code>HAVING Condizione</code>
</p>
</div>
</div>
<div id="outline-container-org0362afe" class="outline-4">
<h4 id="org0362afe">Operatori insiemistici</h4>
<div class="outline-text-4" id="text-org0362afe">
<p>
<code>UNION</code>, <code>INTERSECT</code> e <code>EXCEPT</code> (differenza)
</p>

<p>
Sono generalmente poco efficienti. Solo l'unione è necessaria, mentre le altre operazioni possono essere espresse mediante altri comandi. Assumono tutti la clausola <code>DISTINCT</code> e quindi bisogna specificare <code>ALL</code> quando è il contrario.
</p>
</div>
</div>
<div id="outline-container-org27d8067" class="outline-4">
<h4 id="org27d8067">Interrogazioni nidificate</h4>
<div class="outline-text-4" id="text-org27d8067">
<p>
Il caso d'uso tipico è quando nella condizione nel WHERE si vogliono confrontare un attributo della tabella nel FROM e il risultato di un'altra interrogazione, sorge il problema della disomogeneità, infatti si confronterebbe la singola riga con il contenuto di un'intera interrogazione.
</p>

<p>
Per questo si usano le keyword <code>all</code> e <code>any</code>, che indicano che la riga debba soddisfare la condizione per rispettivamente tutte o almeno una delle righe dell'interrogazione nidificata.
</p>

<p>
Inoltre vengono forniti gli operatori  <code>[not] in</code> che risultano veri solo quando il valore del primo attributo per quella riga si trova nella tabella frutto dell'interrogazione nidificata
</p>

<p>
L'operatore unario <code>[not] exists</code> invece restituisce vero soltanto quando la tabella nidificata è non vuota. Ha senso usarlo soltanto con delle variabili dichiarate al primo livello.
</p>

<p>
Si possono usare anche costruttori di tupla, che vengono usati per racchiudere vari attributi in un solo oggetto che poi può essere confrontato
</p>
</div>
</div>
<div id="outline-container-org5f75e49" class="outline-4">
<h4 id="org5f75e49"><span class="todo TODO">TODO</span> Continuare da 4.3.7</h4>
</div>
</div>
<div id="outline-container-org2ebdc19" class="outline-3">
<h3 id="org2ebdc19">Programma</h3>
<div class="outline-text-3" id="text-org2ebdc19">
<p>
19/03/25
</p>
<ul class="org-ul">
<li>introduzione a SQL</li>
<li>istruzione select</li>
<li>clausola where nel comando select</li>
<li>operatori booleani</li>
<li>operatore like</li>
<li>funzioni lower/upper/trim</li>
</ul>

<p>
25/03/25
</p>
<ul class="org-ul">
<li>query SQL: operatori between, in, like, is null</li>
<li>query SQL: alias di attributi</li>
<li>query SQL: ordinamento del risultato</li>
<li>query SQL: operazioni di join</li>
<li>query SQL: alias di relazione</li>
</ul>

<p>
26/03/25
</p>
<ul class="org-ul">
<li>query SQL: self join</li>
<li>viste in SQL</li>
<li>clausola WITH e tabelle temporanee (query CTE)</li>
<li>valutazione del piano di esecuzione di una query (EXPLAIN)</li>
<li>query SQL: operatori insiemistici (UNION, INTERSECT, EXCEPT)</li>
<li>query innestate (o subquery)</li>
</ul>

<p>
01/04/2025
</p>
<ul class="org-ul">
<li>query SQL: join esterni (left/right/full)</li>
<li>applicazioni dei join esterni</li>
<li>operatore EXISTS</li>
</ul>

<p>
08/04/2025
</p>
<ul class="org-ul">
<li>query SQL: operatori aggregati</li>
<li>query con raggruppamento</li>
<li>query SQL: clausola GROUP BY</li>
<li>query SQL: clausola HAVING</li>
</ul>

<p>
09/04/2025
</p>
<ul class="org-ul">
<li>query SQL: query correlate</li>
<li>query SQL: correlate con aggregazione</li>
<li>divisione in SQL</li>
</ul>

<p>
15/04/2024
</p>
<ul class="org-ul">
<li>interrogazioni ricorsive in SQL</li>
<li>basi di dati attive (asserzioni e trigger)</li>
<li>viste materializzate</li>
<li>viste aggiornabili</li>
</ul>
</div>
</div>
<div id="outline-container-orga17ab93" class="outline-3">
<h3 id="orga17ab93">Domini elementari</h3>
<div class="outline-text-3" id="text-orga17ab93">
<p>
<code>character</code>, <code>numeric</code>
</p>
</div>
</div>
</div>
<div id="outline-container-org618fc09" class="outline-2">
<h2 id="org618fc09">Modello Entità Relazione (progettazione concettuale)</h2>
<div class="outline-text-2" id="text-org618fc09">
</div>
<div id="outline-container-org6747221" class="outline-3">
<h3 id="org6747221">Costrutti di base (entità, relazioni, attributi)</h3>
<div class="outline-text-3" id="text-org6747221">
<p>
Le <b>entità</b> rappresentano classi di oggetti che hanno proprietà comuni. Vengono rappresentate mediante un <b>rettangolo</b>.
</p>

<p>
Le <b>relazioni (associazioni)</b> rappresentano legami logici significativi per la relazione di interesse. Una sua occorrenza è una ennupla contenente occorrenze delle entità coinvolte. Vengono rappresentate mediante un <b>rombo</b>.
Possono essere ricorsive, e in tal caso se non sono simmetriche allora va indicato con un identificatore alle linee uscenti dalla relazione ricorsiva.
Possono essere specificate delle <b>cardinalità</b> per ciascuna partecipazione di un entità ad una relazione. In generale si usano i valori 0, 1 e N. La cardinalità minima può essere 0, opzionale, o 1, obbligatoria. Quella massima può essere 1, in tal caso la relazione è come una funzione, o N, ovvero arbitraria. In base alla cardinalità massima si possono classificare le relazioni come uno-a-uno, uno-a-molti, molti-a-molti.
</p>

<p>
Gli <b>attributi</b> descrivono proprietà elementari di attributi o relazioni. Possono essere raggrupati in attributi composti (ma non vengono usati spesso).
Possono essere obbligatori se la loro cardinalità minima è 1, opzionali altrimenti. Quando la cardinalità massima è N, sono detti multivalore e vuol dire che ad un'occorrenza di entità possono essere associati più valori.
</p>

<p>
Un <b>identificatore</b> è specificato per un'entità e descrive i concetti (attributi ed entità) che identificano univocamente un'occorrenza dell'entità. Quando un sottoinsieme degli attributi è identificatore, si parla di identificatori interni.
A volte è invece necessario includere altre entità. In tal caso sono identificatori esterni e si indicano collegando l'attributo interno che fa da id con la linea che collega l'entità in questione con l'entità identificatrice.
Gli attributi identificativi devono avere cardinalità uno-ad-uno, e le relazioni che collegano all'entità identificativa devono avere cardinalità uno-ad-uno con l'entità in questione. Se queste condizioni non avvengono, allora lo stesso attributo potrebbe riferirsi a più occorrenze e alla stessa occorrenza potrebbero essere associate più entità esterne, quindi non potrebbero essere identificatori.
</p>

<p>
Una <b>generalizzazione</b> rappresenta legami logici fra un entità genitore e le entità figlie. L'entità genitore è una <b>generalizzazione</b> di quelle figlie e le comprende come caso particolare. Le figlie <b>specializzano</b> quella genitore ed ogni loro occorrenza è anche un occorrenza dell'entità genitore.
Inoltre, ogni attributo dell'entità genitore lo è anche delle entità figlie.
In generale, ogni sottoclasse <b>eredita</b> tutte le proprietà della superclasse, ovvero attributi, identificatori e relazioni.
Se ogni occorrenza dell'entità generale lo è di almeno una delle figlie, allora la generalizzazione è <b>totale</b> ed è indicata con la freccia piena. Altrimenti esiste qualche occorrenza che non è inclusa in nessun'entità figlia e la generalizzazione è <b>parziale</b>.
Se ogni occorrenza è occorrenza di al massimo una delle entità figlie, allora è <b>esclusiva</b>. Altrimenti esistono occorrenze che appartengono a più figlie ed è <b>sovrapposta</b>.
Se esiste una sola entità figlia, si parla di <b>sottoinsieme</b>.
Può esistere una serie di generalizzazioni, detta <b>gerarchia</b>.
</p>


<p>
Sia cardinalità che identificatori sono vincoli di integrità su relazioni ed entità.
</p>
</div>
</div>
</div>
<div id="outline-container-org56951a6" class="outline-2">
<h2 id="org56951a6">Progettazione logica</h2>
<div class="outline-text-2" id="text-org56951a6">
<p>
Una volta creato un modello ER completo, bisogna ristrutturarlo e poi tradurlo nel modello relazionale.
</p>
</div>
<div id="outline-container-orgca2d74e" class="outline-3">
<h3 id="orgca2d74e">Ristruttazione</h3>
<div class="outline-text-3" id="text-orgca2d74e">
<p>
Si basano su valutazioni legate ai parametri di carico della basi di dati. Questi parametri includono:
</p>
<ul class="org-ul">
<li>Volume dei dati, compreso numerosità delle occorrenze delle entità e quante di esse partecipano a relazioni</li>
<li>Tipo di operazioni svolte più frequentemente</li>
<li>Interattiva o batch (?)</li>
<li>Frequenza (quante operazioni per unità di tempo)</li>
</ul>

<p>
Le modifiche effettuate sono le tre seguenti:
</p>
<ul class="org-ul">
<li>Analisi dei dati derivati (eliminazione ridondanza)</li>
<li>Eliminazione delle gerarchie di generalizzazione</li>
<li>Scelta degli identificatori primari</li>
</ul>

<p>
Alcuni dati (attributi) possono essere <b>derivati</b> da altri dati già immagazzinati. In questo caso possono essere eliminati, con il vantaggio di ridurre il volume dei dati e non essere più costretti a mantenere la coerenza. Lo svantaggio è che servirà uno overhead maggiore per calcolarli. Bisogna quindi valutare il tradeoff fra il risparmio di memoria e il guadagno in efficienza nell'evitare di mantenere la coerenza rispetto all'aumento dell'overhead nel calcolare il dato ogni volta.
</p>

<p>
Le gerarchie di generalizzazione non possono essere rappresentate direttamente dal modello relazionale e quindi vanno eliminate. Ci sono 3 opzioni:
</p>
<dl class="org-dl">
<dt>mantenimento dell'entità padre</dt><dd>aggiungo l'attributo "tipo" all'entità padre, che indica a quale sottoclasse ogni occorrenza appartenga. Se la generalizzazione non è totale (ma parziale), allora può assumere valori nulli. Se le generalizzazione non è esclusiva (ma sovrapposta) allora è un attributo multivalore. Questa soluzione è sempre applicabile.
Il vantaggio è un numero minore di accessi, ma porta ad un volume maggiore perchè ci saranno degli attributi aggiuntivi e dei valori null.</dd>
<dt>mantenimento delle entità figlie</dt><dd>elimino l'entità padre e trasferisco tutti gli attributi e tutte le partecipazioni a relazione a ogni entità figlia. La generalizzazione dev'essere totale (altrimenti perderei le occorrenze solo in padre) e esclusiva (altrimenti avrei occorrenze identiche in posti separati).
Il vantaggio è di evitare l'accesso all'entità generica.</dd>
<dt>mantenimento di tutte le entità</dt><dd>introduco la relazione IS<sub>A</sub> che indica la generalizzazione. Diventa necessario che ogni occorrenza delle specializzazioni sia riflettuta nel padre, e se la generalizzazione è totale, anche il viceversa.
Sebbene si richiedono più accessi, essi hanno meno attributi è questo permette un accesso più veloce.</dd>
</dl>

<p>
Gli <b>attributi multivalore</b> in generale vengono "reificati" introducendo una nuova relazione con la stessa cardinalità dell'attributo in questione.
</p>
</div>
</div>
<div id="outline-container-orgfc04f5d" class="outline-3">
<h3 id="orgfc04f5d">Traduzione a modello relazionale</h3>
<div class="outline-text-3" id="text-orgfc04f5d">
<p>
Le <b>entità</b> vengono tradotte in relazioni (tabelle) la cui chiave primaria è l'identificatore interno.
</p>

<p>
Le <b>relazioni ER N a N</b> vengono trasformate in relazioni (tabelle) la cui chiave è l'unione delle chiavi delle entità che vi partecipano. GLi attributi aggiuntivi sono gli altri attributi e possono essere inclusi nella chiave quando se si vuole rendere possibili più relazioni fra stesse occorrenze con attributi propri della relazione diversi (es. Milan-Inter 0-0, Milan-Inter 3-1)
</p>

<p>
Le <b>relazioni ER 1 a 1</b> vengono trasformate inglobando una delle chiavi nell'altra relazione, accompagnata dagli attributi della relazione.
</p>

<p>
Le <b>relazioni 1 a N</b> sono trasformate o inglobando nell'entità con cardinalità 1 la chiave dell'altra, oppure creando una nuova relazione che contenga entrambe le chiavi e gli attributi dell'entità con cardinalità 1. In questo caso la chiave primaria è composta solo dagli attributi dell'entità con cardinalità 1, quindi si permettono più valori dell'altra.
</p>

<p>
<b>Relazioni n-arie</b>: si traducono come le relazioni N:M con una chiave esterna per ogni entità implicata nell’associazione.
<b>Relazioni ricorsive</b>: si traducono come normali associazioni ma ridenominando le chiavi esterne in modo da evidenziarne il ruolo nell’associazione.
</p>
</div>
</div>
<div id="outline-container-orge62db05" class="outline-3">
<h3 id="orge62db05"><span class="todo TODO">TODO</span> Reverse Engineering</h3>
</div>
</div>
<div id="outline-container-orgc40ce0a" class="outline-2">
<h2 id="orgc40ce0a">Progetto</h2>
<div class="outline-text-2" id="text-orgc40ce0a">
</div>
<div id="outline-container-org266508c" class="outline-3">
<h3 id="org266508c">Usare bootstrap con supporto SAAS (forse)</h3>
</div>
<div id="outline-container-orgd3753a8" class="outline-3">
<h3 id="orgd3753a8">Presentazione</h3>
<div class="outline-text-3" id="text-orgd3753a8">
</div>
<div id="outline-container-orgc7e7fa6" class="outline-4">
<h4 id="orgc7e7fa6">La discussione serve per capire quello che c'è dietro</h4>
<div class="outline-text-4" id="text-orgc7e7fa6">
</div>
<div id="outline-container-orga256f47" class="outline-5">
<h5 id="orga256f47">Giustificare le scelte</h5>
<div class="outline-text-5" id="text-orga256f47">
</div>
<div id="outline-container-orgf20ed8d" class="outline-6">
<h6 id="orgf20ed8d">Come scrivere un trigger in un altro modo?</h6>
</div>
<div id="outline-container-org5d6a9fd" class="outline-6">
<h6 id="org5d6a9fd">Domande su viste</h6>
</div>
</div>
</div>
<div id="outline-container-orge364219" class="outline-4">
<h4 id="orge364219">La parte di progettazione è importante</h4>
<div class="outline-text-4" id="text-orge364219">
</div>
<div id="outline-container-org9d8e77e" class="outline-5">
<h5 id="org9d8e77e">DDL, progettazione degli schema, integrità referenziale</h5>
</div>
</div>
<div id="outline-container-orgf08af85" class="outline-4">
<h4 id="orgf08af85">Specifiche</h4>
<div class="outline-text-4" id="text-orgf08af85">
</div>
<div id="outline-container-orgbf8816e" class="outline-5">
<h5 id="orgbf8816e">Non è detto che il manager sia il responsabile, sono due cose diverse</h5>
</div>
<div id="outline-container-org0bc5694" class="outline-5">
<h5 id="org0bc5694">Informazioni di tipo testuale suggerisce il tipo di dominio da usare</h5>
</div>
<div id="outline-container-org0a8ccfa" class="outline-5">
<h5 id="org0a8ccfa">Il prezzo di un prodotto non dipende dal prodotto stesso, ma dal prodotto e dal negozio in cui è in vendita</h5>
</div>
<div id="outline-container-orgd1c2601" class="outline-5">
<h5 id="orgd1c2601">I clienti possono acquistare da negozi diversi nella stessa fattura</h5>
</div>
<div id="outline-container-orgda40b9e" class="outline-5">
<h5 id="orgda40b9e">Anche i fornitori forniscono prezzi diversi</h5>
</div>
<div id="outline-container-org1dbd577" class="outline-5">
<h5 id="org1dbd577">Un cliente può avere o non avere una tessera. La tessera è associata ad un negozio specifico e il cliente può averne una sola.</h5>
<div class="outline-text-5" id="text-org1dbd577">
</div>
<div id="outline-container-orgda52999" class="outline-6">
<h6 id="orgda52999">È importante tenere traccia la data e il negozio in cui è stata effettuata</h6>
</div>
</div>
<div id="outline-container-org0eb19a0" class="outline-5">
<h5 id="org0eb19a0">Queste sono le specifiche che dobbiamo tener presente quando progettiamo lo schema concettuale e passiamo a quello logico</h5>
</div>
</div>
<div id="outline-container-orgc7d5baf" class="outline-4">
<h4 id="orgc7d5baf">2.2</h4>
<div class="outline-text-4" id="text-orgc7d5baf">
</div>
<div id="outline-container-orga0b64f6" class="outline-5">
<h5 id="orga0b64f6">Tutto implementato con viste, viste materializzate, funzioni, trigger, procedure</h5>
</div>
<div id="outline-container-org60a3aee" class="outline-5">
<h5 id="org60a3aee">Applicazione sconto</h5>
<div class="outline-text-5" id="text-org60a3aee">
</div>
<div id="outline-container-org55353f6" class="outline-6">
<h6 id="org55353f6">Sono un cliente, faccio un acquisto, decido di usare lo sconto del 15%, mi viene proposto di applicare lo sconto</h6>
</div>
<div id="outline-container-org1e1aa51" class="outline-6">
<h6 id="org1e1aa51">Si può usare un solo sconto per acquisto (si può fare anche diversamente ma va motivato)</h6>
</div>
</div>
<div id="outline-container-org972a1c7" class="outline-5">
<h5 id="org972a1c7">Ordine prodotti da fornitore</h5>
<div class="outline-text-5" id="text-org972a1c7">
</div>
<div id="outline-container-orgb74e63b" class="outline-6">
<h6 id="orgb74e63b">Mentre il cliente sceglie autonomamente il negozio da cui comprare, il fornitore di un negozio è scelto sulla base di un criterio di economicità</h6>
</div>
</div>
<div id="outline-container-org9c2b875" class="outline-5">
<h5 id="org9c2b875">L'elenco dei saldi punti &gt; 300 dev'essere mantenuto e non calcolato a volo</h5>
</div>
</div>
<div id="outline-container-orgafdf17b" class="outline-4">
<h4 id="orgafdf17b">Consegna</h4>
<div class="outline-text-4" id="text-orgafdf17b">
</div>
<div id="outline-container-org0550496" class="outline-5">
<h5 id="org0550496">Due folder, una con il dump (non in esadecimale ma in testo) e l'altro è l'insieme delle pagine pgp</h5>
</div>
</div>
<div id="outline-container-org762d0bd" class="outline-4">
<h4 id="org762d0bd">Struttura orale</h4>
<div class="outline-text-4" id="text-org762d0bd">
</div>
<div id="outline-container-org7743b1c" class="outline-5">
<h5 id="org7743b1c">Ci lascia 5 minuti per mostrare le funzionalità principali o pirotecniche</h5>
</div>
<div id="outline-container-orga7e0150" class="outline-5">
<h5 id="orga7e0150">Ci fa domande sul codice sorgente, fa fare qualche modifica</h5>
</div>
<div id="outline-container-org98714eb" class="outline-5">
<h5 id="org98714eb">Guardiamo la progettazione e la correggiamo</h5>
</div>
<div id="outline-container-org0bfa77f" class="outline-5">
<h5 id="org0bfa77f">Qualche domandina su PHP</h5>
</div>
</div>
<div id="outline-container-org77afa91" class="outline-4">
<h4 id="org77afa91">Pg query non va usato, ma si usa prepare and execute</h4>
</div>
</div>
<div id="outline-container-org3a200d5" class="outline-3">
<h3 id="org3a200d5">Tabelle derivate (trigger) o materialized view?</h3>
<div class="outline-text-3" id="text-org3a200d5">
<p>
Materialized view, ma le tabelle derivate mostrano che si sa come funziona. Comunque bisogna sapere come fare con le tabelle derivate. (Domanda classica)
</p>
</div>
</div>
<div id="outline-container-orgd53ed62" class="outline-3">
<h3 id="orgd53ed62">PGquery non va usato, ma va usato pg<sub>prepare</sub> e pg<sub>execute</sub> (o anche pg<sub>query</sub> params)</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-05-30 Fri 07:58</p>
</div>
</body>
</html>
